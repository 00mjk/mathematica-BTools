(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Subsection:: *)
(*GitHub*)



$GitHubUsername::usage=
	"The user's github username";
$GitHubPassword::usage=
	"The user's github password";
FormatGitHubPath::usage="";
GitHubPath::usage=
	"Represents a github path";
GitHubRepoQ::usage=
	"Returns if the path could be a github repo";
GitHubPathQ::usage="";
GitHubCreate::usage="";
GitHubDelete::usage="";
GitHubDeployments::usage="";
GitHubCreateRelease::usage="";
GitHubEditRelease::usage="";
GitHubDeleteRelease::usage="";
GitHubUploadReleaseAsset::usage="";
GitHubGetReleaseAsset::usage="";
GitHubEditReleaseAsset::usage="";
GitHubDeleteReleaseAsset::usage="";
GitHubReleases::usage="";
GitHubRepositories::usage="";
$GitHubActions::usage=
	"A collection of known calls for the GitHub function";
GitHubImport::usage=
	"Imports and converts GitHub JSON";


Begin["`Private`"];


(* ::Subsection:: *)
(*Basics*)



If[Length@OwnValues[$GitHubUseKeychain]==0,
	$GitHubUseKeychain:=
		TrueQ@Lookup[$GitHubConfig, "UseKeychain", False]
	];


(* ::Subsubsection::Closed:: *)
(*$GitHubConfig*)



If[Not@ValueQ@$GitHubConfig,
	$GitHubConfig:=
		Replace[
			Do[
				With[{f=PackageFilePath["Private", "Config", d]},
					If[FileExistsQ@f,
						Return[
							$GitHubConfig=
								Replace[Quiet@Import@f,
									{ 
										o_?OptionQ:>Association@o,
										_-><||>
										}
									]
								];
						Break[]
						]
					],
				{d,
					{
						"GitHubConfig.m",
						"GitHubConfig.wl"
						}
					}
				],
			Null-><||>
			]
	]


(* ::Subsubsection::Closed:: *)
(*$GitHubUsername*)



If[Length[OwnValues@$GitHubUsername]===0,
	$GitHubUsername:=
		Replace[
			If[$GitHubUseKeychain, $Keychain["$GitHubUsername"], None],
			Except[_String]:>
				Replace[$GitHubConfig["Username"],
					Except[_String?StringQ]:>
						GitHubSetUsernameAndPassword[
							"", 
							""
							][[1]]
					]
			]
	];


(* ::Subsubsection::Closed:: *)
(*$GitHubEncodePassword*)



$GitHubEncodePassword:=
	TrueQ@$GitHubConfig["EncodePassword"];


(* ::Subsubsection::Closed:: *)
(*$GitHubPassword*)



$GitHubStorePassword:=
	Lookup[$GitHubConfig, "CachePassword", False]


GitHubPassword[s_String]:=
	With[
		{
			base=
				Replace[gitHubPasswordCache[s],
					Except[_String]:>
						If[$GitHubUseKeychain, KeychainGet[{"github.com",	s}, False]]
					]
			},
		If[StringQ@base,
			base,
			If[$GitHubUseKeychain&&$GitHubStorePassword,
				KeychainGet[{"github.com",	s}, True],
				(* Create an auth dialog for the found username *)
				AuthDialog[
					Dynamic@$ghauth,
					"",
					None,
					{{"github.com", Automatic}, s}
					];
				If[AssociationQ[$ghauth]&&StringQ@$ghauth["github.com"][[2]],
					gitHubPasswordCache[s]=
						$ghauth["github.com"][[2]],
					gitHubPasswordCache[s]=None
					];
				Clear@$ghauth;
				gitHubPasswordCache[s]
				]
			]
		];
GitHubPassword[Optional[Automatic,Automatic]]:=
	GitHubPassword[$GitHubUsername];
Clear@$GitHubPassword;
$GitHubPassword:=
	GitHubPassword[Automatic];


(*If[ValueQ@$GitHubUsername&&!KeyMemberQ[$gitHubPassCache,$GitHubUsername],
	$gitHubPassCache[$GitHubUsername]:=
		Do[
			With[{f=
				FileNameJoin@{
					$PackageDirectory,
					"Private",
					d}
				},
				If[FileExistsQ@f,
					Replace[Import@f,
						s_String:>
							($gitHubPassCache[$GitHubUsername]=s);
						];
					Return[True]
					]
				],
			{d,
				{
					"GitHubPassword.m",
					"GitHubPassword.wl"
					}
				}
			]
	];*)


(* ::Subsubsection::Closed:: *)
(*$GitHubSSHConnected*)



$GitHubSSHConnected:=
	($GitHubSSHConnected=
		Quiet[processRunDupe[{"ssh","-T","git@github.com"}];
			Length@$MessageList===0
			]
		);


(* ::Subsubsection::Closed:: *)
(*Actions*)



$GitHubActions=<||>


(* ::Subsubsection::Closed:: *)
(*Lol*)



$GitHubActions["CurrentUser"]=
	Function[$GitHubUsername]


(* ::Subsection:: *)
(*Paths*)



(* ::Subsubsection::Closed:: *)
(*GitHubPath*)



ClearAll[GitHubPath, FormatGitHubPath]


Options[GitHubPath]=
	{
		"Username"->Automatic,
		"Password"->None,
		"Branch"->"master",
		"Tree"->"tree"
		};
Options[FormatGitHubPath]=
	Options[GitHubPath];
FormatGitHubPath[path___String,ops:OptionsPattern[]]:=
	URLBuild@<|
		"Scheme"->
			"https",
		"Domain"->
			"github.com",
		If[$GitHubEncodePassword||
			MatchQ[OptionValue@"Password",_String|Automatic],
			"Username"->
				Replace[OptionValue["Username"],
					{
						Automatic:>
							Replace[OptionValue@"Password",
								Automatic|_String:>$GitHubUsername
								],
						Except[_String]->None
						}
					],
			Nothing
			],
		If[$GitHubEncodePassword||
			MatchQ[OptionValue@"Password",_String|Automatic],
			"Password"->
				Replace[
					Replace[OptionValue["Username"],{
						Automatic:>$GitHubUsername,
						Except[_String]->None
						}],
					s_String:>
						Replace[OptionValue["Password"],
							Automatic:>GitHubPassword[s]
							]
					],
			Nothing
			],
		"Path"->
			{
				Replace[OptionValue@"Username",
					Automatic:>$GitHubUsername
					],
				If[Length@{path}>1,
					Sequence@@Flatten@
						Insert[{path}, 
							{OptionValue["Tree"], OptionValue["Branch"]}, 
							2
							],
					Sequence@@{path}
					]
				}
		|>;
GitHubPath[repo_String, 
	t:"tree"|"raw"|"trunk", 
	branch_String, 
	p___String, 
	ops:OptionsPattern[]
	]:=
	GitHubPath[repo,
		If[t==="trunk", branch, Sequence@@{}],
		p, 
		"Branch"->If[t==="trunk", Nothing, branch],
		"Tree"->t,
		ops
		];
GitHubPath[path___String,ops:OptionsPattern[]]/;(TrueQ@$GitHubPathFormat):=
	FormatGitHubPath[path,ops];
GitHubPath[
	s_String?(
		(
			URLParse[#, "Scheme"]===None&&
				URLParse[#, "Domain"]===None&&
				Length@URLParse[#, "Path"]>1
			)||
		URLParse[#, "Scheme"]==="github"&
		),
	o:OptionsPattern[]
	]:=
	GitHubPathParse[
		If[URLParse[s, "Scheme"]===None&&URLParse[s, "Domain"]===None,
			"github:"<>s,
			s
			],
		o
		];
GitHubPath[URL[s_String], ops:OptionsPattern[]]:=GitHubPath[s, ops];
GitHubPath[GitHubPath[p___String, o___?OptionQ], op:OptionsPattern[]]:=
	GitHubPath[p, Sequence@@DeleteDuplicatesBy[Flatten@{op, o}, First]]


GitHubPath/:
	Normal[GitHubPath[repos___,ops___?OptionQ]]:=
		{
			FirstCase[{ops},
				("Username"->u_):>u,
				$GitHubUsername
				],
			repos
			};
GitHubPath/:
	URL[GitHubPath[path___String,ops:OptionsPattern[]]]:=
		FormatGitHubPath[path,ops]


Format[g:GitHubPath[path___String,ops:OptionsPattern[]]]:=
	RawBoxes@
		BoxForm`ArrangeSummaryBox[
			"GitHubPath",
			g,
			None,
			{
				BoxForm`MakeSummaryItem[{"Path: ", URLBuild[{path}]}, StandardForm],
				BoxForm`MakeSummaryItem[
					{"URL: ", 
						Hyperlink[FormatGitHubPath@@g]
						}, StandardForm]
				},
			Map[
				BoxForm`MakeSummaryItem[
					{
						Row@{#[[1]], ": "}, #[[2]]
						},
					StandardForm
					]&,
				Flatten[Normal/@{ops}]
				],
			StandardForm
			]


(* ::Subsubsection::Closed:: *)
(*GitHubPathQ*)



GitHubPathQ[path:_String|_URL]:=
	With[{p=URLParse[path]},
		(
			(MatchQ[p["Scheme"],"http"|"https"|None]&&p["Domain"]==="github.com")||
			p["Scheme"]==="github"&&p["Domain"]===None
			)
			&&
		Length@p["Path"]>0
		];
GitHubPathQ[_GitHubPath]:=
	True;


(* ::Subsubsection::Closed:: *)
(*GitHubPathParse*)



Options[GitHubPathParse]=
	Options[GitHubPath];
GitHubPathParse[path:_String|_URL, o:OptionsPattern[]]:=
	If[GitHubPathQ[path],
		Replace[
			DeleteCases[""]@
				URLParse[path, "Path"],
			{
				{user_, parts___}:>
					GitHubPath[parts, "Username"->user, o]
				}
			],
		$Failed
		];


(* ::Subsubsection::Closed:: *)
(*GitHubRepoParse*)



GitHubRepoParse[path:_String|_URL]:=
	If[GitHubPathQ[path],
		Replace[
			DeleteCases[""]@
				URLParse[path,"Path"],{
			{"repos",user_,parts__}|
			{user_,parts__,"releases"|"deployments"}|
			{user_,parts__,"releases"|"deployments","tag",___}:>
				GitHubPath[parts,"Username"->user]
			}],
		$Failed
		];


(* ::Subsubsection::Closed:: *)
(*GitHubRepoQ*)



iGitHubRepoQ[path:_String|_URL]:=
	GitHubPathQ[path]&&
	With[{p=URLParse[path]},
		!MatchQ[p["Path"],
			{"repos",__}|
			{__,"releases"|"deployments"}|
			{__,"releases"|"deployments","tag",___}
			]
		];
GitHubRepoQ[p:GitHubPath[___String,___?OptionQ]]:=
	iGitHubRepoQ[URL@p]
GitHubRepoQ[path:_String|_URL]:=
	GitHubRepoQ[GitHubPath@path];
GitHubRepoQ[_]:=False


(* ::Subsubsection::Closed:: *)
(*GitHubReleaseQ*)



GitHubReleaseQ[GitHubPath[p__String,___?OptionQ]]:=
	MatchQ[{p},
		{__,"releases"}|
		{__,"releases","tag",_}
		];
GitHubReleaseQ[path:_String|_URL]:=
	If[GitHubPathQ@path,
		Replace[GitHubPathParse[path],{
			g_GitHubPath:>
				GitHubReleaseQ@g,
			_->False
			}],
		False
		];


(* ::Subsection:: *)
(*Queries*)



(* ::Subsubsection::Closed:: *)
(*GitHubQuery*)



(* ::Subsubsubsection::Closed:: *)
(*GitHubQueryAttachAuth*)



GitHubQueryAttachAuth[headers_]:=
	ReplacePart[headers,
		{
			"Headers":>
				ReplaceAll[headers["Headers"],
					{
						("Authorization"->Automatic):>
							("Authorization"->GitHubAuthHeader[] ),
						("Authorization"->{u__}):>
							("Authorization"->GitHubAuthHeader[u])
						}
					],
			"Username":>
				Replace[
					headers["Username"],
					Automatic:>
						Replace[$GitHubUsername,
							Except[_String?(StringLength[#]>0&)]:>
								GitHubSetUsernameAndPassword[
									Automatic, 
									Lookup[headers, "Password", $GitHubPassword]
									]
							]
					],
			"Password":>
				Replace[
					headers["Password"],
					Automatic:>
						Replace[$GitHubPassword,
							Except[_String?(StringLength[#]>0&)]:>
								GitHubSetUsernameAndPassword[
									Lookup[headers, "Username", $GitHubPassword], 
									Automatic
									]
							]
					]
			}
		]


(* ::Subsubsubsection::Closed:: *)
(*GitHubQueryPrepBody*)



GitHubQueryPrepBody[headers_]:=
	If[headers["Body"]==={},
		KeyDrop[headers, "Body"],
		ReplacePart[headers,
			"Body":>
				Replace[o_?OptionQ:>
					ExportString[o, "JSON"]
					]@
				ReplaceAll[
					headers["Body"],
					f_File:>Developer`EncodeBase64[ReadString[f]]
					]
			]
		]


(* ::Subsubsubsection::Closed:: *)
(*GitHubQuery*)



GitHubQuery[
	path:_?(MatchQ[Flatten@{#},{___String}]&):{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>]:=
	Block[
		{
			$GitHubUsername=$GitHubUsername,
			$GitHubPassword=$GitHubPassword
			},
		Catch@
			HTTPRequest[
				URLBuild@<|
					"Scheme"->"https",
					"Domain"->"api.github.com",
					"Path"->Flatten@{path},
					"Query"->{query}
					|>,
				Association@Normal@
					GitHubQueryPrepBody@
						GitHubQueryAttachAuth@headers
				]
			];


(* ::Subsubsection::Closed:: *)
(*GitHubQueryParamFilter*)



$GitHubParamMap=<||>;


GitHubQueryParamFilter[s_Symbol, ops_?OptionQ]:=
	With[{kd=Dispatch[$GitHubParamMap[s]]},
		Replace[
			FilterRules[
				Flatten@{
					ops,
					Options[s]
					},
				Keys[$GitHubParamMap[s]]
				],
			{
				(k_->v:_String|_?NumberQ|True|False):>
					Replace[k, kd]->v,
				_->Nothing
				},
			1
			]
		]


(* ::Subsection:: *)
(*Auth*)



(* ::Subsubsection::Closed:: *)
(*Auth*)



(*GitHubAuth[
	user:_String|Automatic:Automatic,
	scopes:_String|{__String}:{"public_repo"}]:=
	GitHubQuery[
		Replace[user,Automatic:>$GitHubUsername],
		<|
			"Headers"\[Rule]{
				"Authorization"\[Rule]"token OAUTH-TOKEN",
				"
				}
			|>
		];*)


(* ::Subsubsection::Closed:: *)
(*GitHubGetUsernameAndPassword*)



GitHubGetUsernameAndPassword[u_, p_]:=
	Block[
		{
			username=Replace[u, Automatic:>$GitHubUsername], 
			password=Replace[u, Automatic:>$GitHubPassword]
			},
		If[
			Not[
				StringQ@username&&StringQ@password&&
				StringLength[username]>0&&StringLength[password]>0
				],
			If[StringQ@username&&$GitHubUseKeychain,
				password=
					KeychainGet[{"github.com", username}]
				]
			];
		If[
			Not[
				StringQ@username&&StringQ@password&&
				StringLength[username]>0&&StringLength[password]>0
				],
				Replace[
					AuthDialog[
						{
							"GitHub", 
							If[StringQ[username], username, ""], 
							If[StringQ[password], password, ""]
							}],
					a_Association?AssociationQ:>
						(
							Set[username, a[["GitHub", 1]]];
							Set[password, a[["GitHub", 2]]];
							)
					]
				];
		{username, password}
		];


(* ::Subsubsection::Closed:: *)
(*GitHubSetUsernameAndPassword*)



GitHubSetUsernameAndPassword[u_, p_]:=
	Function[gitHubPasswordCache[#[[1]]]=#[[2]];#]@
		Set[
			{$GitHubUsername, $GitHubPassword},
			GitHubGetUsernameAndPassword[u, p]
			]


(* ::Subsubsection::Closed:: *)
(*AuthHeader*)



GitHubAuthHeader[
	user:_String|Automatic:Automatic,
	password:_String|Automatic:Automatic
	]:=
	With[{up=GitHubGetUsernameAndPassword[user, password]},
		If[Not[AllTrue[up, StringQ[#]&&StringLength[#]>0&]],
			Message[GitHub::noauth];
			Throw@$Failed,
			StringJoin@{
				"Basic ",
				Developer`EncodeBase64@
					StringJoin@{up[[1]],":",up[[2]]}
				}
			]
		];


(* ::Subsection:: *)
(*UserAPI*)



(* ::Subsubsection::Closed:: *)
(*UserAPI*)



GitHubUserAPI[
	type:"users"|"org":"users",
	user:_String|Automatic:Automatic,
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubQuery[{
		type,
		Replace[user, Automatic:>$GitHubUsername],
		Flatten@path
		},
		query,
		headers
		];


(* ::Subsection:: *)
(*Repos Basics*)



(* ::Subsubsection::Closed:: *)
(*ReposAPI*)



GitHubReposAPI[
	repo_GitHubPath?GitHubRepoQ,
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubQuery[
		Flatten@{
			"repos",
			Sequence@@Normal@repo,
			path
			},
		query,
		headers
		];
GitHubReposAPI[
	s_String?GitHubRepoQ,
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubReposAPI[
		GitHubPathParse[If[URLParse[s, "Scheme"]===None, "github:"<>s, s]],
		path,
		query,
		headers
		];


(* ::Subsubsection::Closed:: *)
(*Repositories*)



$GitHubActions["ListRepositories"]=
	GitHubRepositories;


GitHubRepositories//Clear


GitHubRepositories[
	type:"users"|"org":"users",
	user:_String|Automatic:Automatic,
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubUserAPI[type, user, {"repos"}, query, headers];


(* ::Subsubsection::Closed:: *)
(*ListMyRepositories*)



Options[GitHubListMyRepositories]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubListMyRepositories[
	type:"users"|"org":"users",
	ops:OptionsPattern[]
	]:=
	GitHubUserAPI[type, 
		{"repos"}, 
		{},
		<|
			"Headers"->
				{	
					"Authorization"->
						OptionValue[{"Username", "Password"}]
					}
			|>
		];


(* ::Subsubsection::Closed:: *)
(*RepositoryInfo*)



$GitHubActions["GetRepository"]=
	GitHubRepositoryInfo;


GitHubRepositoryInfo[
	repo:(_String|_GitHubPath)?GitHubRepoQ
	]:=
	GitHubReposAPI[
		repo
		]


(* ::Subsubsection::Closed:: *)
(*Create*)



$GitHubActions["CreateRepository"]=GitHubCreate;


$GitHubParamMap[GitHubCreate]=
	{
		"Name"->"name",
		"Description"->"description",
		"Private"->"private",
		"HomePage"->"homepage",
		"AutoInit"->"auto_init",
		"HasWiki"->"has_issues",
		"HasProjects"->"has_projects",
		"HasIssues"->"has_wiki",
		"Private"->"team_id",
		"GitIgnore"->"gitignore_template",
		"LicenseTemplate"->"license_template",
		"AllowSquashMerge"->"allow_squash_merge",
		"AllowMergeCommit"->"allow_merge_commit",
		"AllowRebaseMerge"->"allow_rebase_merge"
		};


Options[GitHubCreate]=
	Join[
		Thread[Keys[$GitHubParamMap[GitHubCreate]]->Automatic],
		{
			"Username"->Automatic,
			"Password"->Automatic
			}
		];
GitHubCreate[
	repo:_String,
	ops:OptionsPattern[]
	]:=
	GitHubReposAPI[
		repo,
		<|
			"Method"->"POST",
			"Body"->
				ExportString[
					GitHubQueryParamFilter[
						GitHubCreate,
						{
							"Name"->repo,
							ops
							}
						],
					"JSON"
					],
			"Headers"->
				{
					"Authorization"->
						OptionValue[{"Username", "Password"}]
						}
			|>
		];


(* ::Subsubsection::Closed:: *)
(*EditRepository*)



$GitHubActions["EditRepository"]=GitHubEdit;


$GitHubParamMap[GitHubEdit]=
	$GitHubParamMap[GitHubCreate];
Options[GitHubEdit]=
	Join[
		Thread[Keys[$GitHubParamMap[GitHubEdit]]->Automatic],
		{
			"Username"->Automatic,
			"Password"->Automatic
			}
		];
GitHubEditRepository[
	repo:(_String|_GitHubPath)?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	GitHubReposAPI[
		repo,
		<|
			"Method"->"PATCH",
			"Body"->
				ExportString[
					GitHubQueryParamFilter[
						GitHubEdit,
						{
							ops
							}
						],
					"JSON"
					],
			"Headers"->
				{
					"Authorization"->
						OptionValue[{"Username", "Password"}]
						}
			|>
		]


(* ::Subsubsection::Closed:: *)
(*Delete*)



$GitHubActions["DeleteRepository"]=GitHubDelete;


GitHubDelete//ClearAll


Options[GitHubDelete]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubDelete[
	repo_GitHubPath?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	With[{uu=URLParse[URL@repo]},
		GitHubReposAPI[
			repo,
			<|
				"Method"->"DELETE",
				"Headers"->
					{
						"Authorization"->
							OptionValue[{"Username", "Password"}]
							}
				|>
			]
		];
GitHubDelete[
	s_String?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	Block[{$GitHubPathFormat=False},
		GitHubDelete[
			GitHubPath[s, FilterRules[{ops}, Options@GitHubPath]],
			ops
			]
		];
(*GitHubDelete[
	s_String?(
		URLParse[#,"Scheme"]===None&&
		Length@URLParse[#,"Path"]===1&
		),
	ops:OptionsPattern[]
	]:=
	GitHubDelete[
		GitHubPath[s,
			FilterRules[{ops},Options@GitHubPath]
			],
		ops]*)


(* ::Subsubsection::Closed:: *)
(*Contributors*)



$GitHubParamMap[GitHubRepositoryContributors]=
	{
		"AnonymousContributors"->"anon"
		};


Options[GitHubRepositoryContributors]=
	$GitHubParamMap[GitHubRepositoryContributors];
GitHubRepositoryContributors[
	repo:(_String|_GitHubPath)?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	GitHubReposAPI[
		repo,
		{"contributors"}
		];


(* ::Subsection:: *)
(*GitDataAPI*)



(* ::Subsubsection::Closed:: *)
(*GitDataAPI*)



GitHubGitDataAPI[
	repo_GitHubPath?GitHubRepoQ,
	part:"blobs"|"commits"|"refs"|"tags"|"trees",
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubReposAPI[
		repo,
		Flatten[{"git", part, path}],
		query,
		headers
		];
GitHubGitDataAPI[
	s_String?GitHubRepoQ,
	part:"blobs"|"commits"|"refs"|"tags"|"trees",
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubGitDataAPI[
		GitHubPathParse[If[URLParse[s, "Scheme"]===None, "github:"<>s, s]],
		part,
		path,
		query,
		headers
		];


(* ::Subsection:: *)
(*Branches*)



(* ::Subsubsection::Closed:: *)
(*Branches*)



GitHubRepositoryBranches[
	repo:(_String|_GitHubPath)?GitHubRepoQ
	]:=
	GitHubReposAPI[
		repo,
		{"branches"}
		];


(* ::Subsubsection::Closed:: *)
(*BranchInfo*)



GitHubRepositoryBranchInfo[
	repo:(_String|_GitHubPath)?GitHubRepoQ,
	branch_String
	]:=
	GitHubReposAPI[
		repo,
		{"branches", branch}
		];


(* ::Subsection:: *)
(*Forks*)



(* ::Subsubsection::Closed:: *)
(*ListForks *)



Options[GitHubListForks]=
	{
		"Sort"->None
		};
GitHubListForks[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	GitHubReposAPI[
		repo,
		{"forks"},
		Replace[OptionValue["Sort"],
			{
				Except[_String]:>Sequence@@{},
				s_String:>("sort"->s)
				}
			]
		]


(* ::Subsubsection::Closed:: *)
(*Fork *)



GitHubFork//Clear


Options[GitHubFork]=
	{
		"Organization"->None,
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubFork[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	GitHubReposAPI[
		repo,
		{"forks"},
		Replace[OptionValue["Organization"],
			{
				Except[_String]:>Sequence@@{},
				s_String:>("organization"->s)
				}
			],
		<|
			"Method"->"POST",
			"Headers"->
				{
					"Authorization"->
						OptionValue[{"Username", "Password"}]
					}
			|>
		]
			


(* ::Subsection:: *)
(*Blobs*)



(* ::Subsubsection::Closed:: *)
(*GetBlob*)



$GitHubActions["GetBlob"]=GitHubGetBlob;


GitHubGetBlob[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	sha:_String?(StringMatchQ[Repeated[WordCharacter, {30, Infinity}]])
	]:=
	GitHubGitDataAPI[
		repo,
		"blobs",
		{sha},
		<|
			|>
		]


(* ::Subsubsection::Closed:: *)
(*CreateBlob*)



$GitHubActions["CreateBlob"]=GitHubCreateBlob;


Options[GitHubCreateBlob]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubCreateBlob[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	blob:_String|_File,
	ops:OptionsPattern[]
	]:=
	GitHubGitDataAPI[
		repo,
		"blobs",
		{},
		<|
			"Method"->"POST",
			"Body"->
				ExportString[
					{
						"content"->
							If[StringQ@blob,
								If[StringLength[blob]>10^6,
									With[{f=CreateFile[]}, 
										WriteString[f, blob];
										Close@f;
										File[f]
										],
									Developer`EncodeBase64[blob]
									],
								blob
								],
						"encoding"->"base64"
						},
					"JSON"
					],
			"Headers"->
				{
					"Authorization"->
						OptionValue[{"Username", "Password"}]
					}
			|>
		]
			


(* ::Subsection:: *)
(*Commits*)



(* ::Subsubsection::Closed:: *)
(*GetCommit*)



$GitHubActions["GetCommit"]=GitHubGetCommit;


GitHubGetCommit[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	sha:_String?(StringMatchQ[Repeated[WordCharacter, {30, Infinity}]])
	]:=
	GitHubGitDataAPI[
		repo,
		"commits",
		{sha},
		<|
			|>
		]


(* ::Subsection:: *)
(*References*)



(* ::Subsubsection::Closed:: *)
(*GetReference*)



$GitHubActions["GetReference"]=GitHubGetReference;


GitHubGetReference[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	which:_String:"master"
	]:=
	GitHubGitDataAPI[
		repo,
		"refs",
		{"heads/"<>StringTrim[which, "heads/"]},
		<|
			|>
		]


(* ::Subsubsection::Closed:: *)
(*GetAllReferences*)



$GitHubActions["GetAllReferences"]=GitHubGetAllReferences;


GitHubGetAllReferences[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	which:_String|None:None
	]:=
	GitHubGitDataAPI[
		repo,
		"refs",
		{If[which===None, Nothing, which]},
		<|
			|>
		]


(* ::Subsubsection::Closed:: *)
(*CreateReference*)



$GitHubActions["CreateReference"]=GitHubCreateReference;


Options[GitHubCreateReference]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubCreateReference[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	ref:_String,
	sha:_String?(StringMatchQ[Repeated[WordCharacter, {30, Infinity}]]),
	ops:OptionsPattern[]
	]:=
	GitHubGitDataAPI[
		repo,
		"refs",
		{},
		<|
			"Method"->"POST",
			"Body"->
				ExportString[
					{
						"ref"->
							With[{s1=StringTrim[ref, "refs/"]},
								If[StringContainsQ[s1, "/"],
									"refs/"<>s1,
									"refs/heads/"<>s1
									]
								],
						"sha"->sha
						},
					"JSON"
					],
			"Headers"->
				{
					"Authorization"->
						OptionValue[{"Username", "Password"}]
					}
			|>
		]
			


(* ::Subsubsection::Closed:: *)
(*UpdateReference*)



$GitHubActions["UpdateReference"]=GitHubUpdateReference;


$GitHubParamMap[GitHubUpdateReference]=
	{
		"ForceUpdate"->"force"
		};
Options[GitHubUpdateReference]=
	Join[
		$GitHubParamMap[GitHubUpdateReference],
		{
			"Username"->Automatic,
			"Password"->Automatic
			}
		];
GitHubUpdateReference[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	ref:_String,
	sha:_String?(StringMatchQ[Repeated[WordCharacter, {30, Infinity}]]),
	ops:OptionsPattern[]
	]:=
	GitHubGitDataAPI[
		repo,
		"refs",
		{
			With[{s1=StringTrim[ref, "refs/"]},
				If[StringContainsQ[s1, "/"],
					s1,
					"heads/"<>s1
					]
				]
			},
		<|
			"Method"->"PATCH",
			"Body"->
				ExportString[
					{
						"sha"->sha,
						"force"->If[TrueQ@OptionValue["ForceUpdate"], "true", "false"]
						},
					"JSON"
					],
			"Headers"->
				{
					"Authorization"->
						OptionValue[{"Username", "Password"}]
					}
			|>
		]
			


(* ::Subsubsection::Closed:: *)
(*DeleteReference*)



$GitHubActions["DeleteReference"]=GitHubDeleteReference;


Options[GitHubDeleteReference]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubDeleteReference[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	ref:_String,
	ops:OptionsPattern[]
	]:=
	GitHubGitDataAPI[
		repo,
		"refs",
		{
			With[{s1=StringTrim[ref, "refs/"]},
				If[StringContainsQ[s1, "/"],
					s1,
					"heads/"<>s1
					]
				]
			},
		<|
			"Method"->"DELTE",
			"Headers"->
				{
					"Authorization"->
						OptionValue[{"Username", "Password"}]
					}
			|>
		]


(* ::Subsection:: *)
(*Tags*)



(* ::Subsubsection::Closed:: *)
(*GetTag*)



$GitHubActions["GetTag"]=GitHubGetTag;


GitHubGetTag[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	sha:_String?(StringMatchQ[Repeated[WordCharacter, {30, Infinity}]])
	]:=
	GitHubGitDataAPI[
		repo,
		"tags",
		{sha},
		<|
			|>
		]


(* ::Subsection:: *)
(*Trees*)



(* ::Subsubsection::Closed:: *)
(*GetTree*)



$GitHubActions["GetTree"]=GitHubGetTree;


Options[GitHubGetTree]=
	{
		"Recursive"->False
		};
GitHubGetTree[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	sha:_String?(StringMatchQ[Repeated[WordCharacter, {30, Infinity}]])
	]:=
	GitHubGitDataAPI[
		repo,
		"trees",
		{sha},
		{
			Replace[OptionValue["Recursive"], 
				{
					s:_String|_Integer:>("recursive"->ToString[s]),
					True->("recursive"->"1"),
					_->Nothing
					}
				]
			},
		<|
			|>
		]


(* ::Subsection:: *)
(*Merges*)



(* ::Subsubsection::Closed:: *)
(*Merge*)



(* ::Text:: *)
(*
	Need to fix this up so it can appropriately handle upstream merges
*)



$GitHubActions["Merge"]=GitHubMerge;


$GitHubParamMap[GitHubMerge]=
	{
		"TargetBranch"->"base",
		"Message"->"commit_message"
		};


Options[GitHubMerge]=
	Join[
		Thread[
			DeleteCases[
				Keys[$GitHubParamMap[GitHubMerge]], 
				"SourceBranch"
				]->Automatic
			],
		{
			"Username"->Automatic,
			"Password"->Automatic
			}
		];
GitHubMerge[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	source:(_GitHubPath?GitHubRepoQ|_String),
	ops:OptionsPattern[]
	]:=
	GitHubReposAPI[
		repo,
		{"merges"},
		{},
		<|
			"Method"->"POST",
			"Body"->
				ExportString[
					Prepend[
						GitHubQueryParamFilter[
							GitHubMerge,
							DeleteDuplicatesBy[First]@{
								ops,
								"TargetBranch"->
									"master",
								"Message"->
									TemplateApply[
										"Merge `` into ``",
										URLBuild@
											Append[
												URLParse[
													If[StringQ@repo, repo, URL@repo], 
													"Path"
													],
												Replace[source,
													_GitHubPath:>StringRiffle[Normal[source], "/"]
													]
												]
										]
								}
								],
							"head"->
								If[GitHubRepoQ@source,
									Replace[
										GitHub["GetReference", source, "master",
											"ImportedResult"
											]["Content"],
										{
											a_Association:>a["Object", "SHA"],
											e_:>Throw[$Failed]
											}
										],
									source
									]
							],
					"JSON"
					],
			"Headers"->
				{
					"Authorization"->
						OptionValue[{"Username", "Password"}]
					}
			|>
		]
			


(* ::Subsection:: *)
(*Pulls*)



(* ::Subsubsection::Closed:: *)
(*ListPullRequests*)



$GitHubActions["ListPullRequests"]=GitHubListPullRequests;


$GitHubParamMap[GitHubListPullRequests]=
	{
		"State"->"state",
		"UserBranch"->"head",
		"BranchName"->"base",
		"Sort"->"sort",
		"SortDirection"->"direction"
		};
Options[GitHubListPullRequests]=
	Thread[Keys[$GitHubParamMap[GitHubListPullRequests]]->Automatic];
GitHubListPullRequests[
	repo:(_String|_GitHubPath)?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	GitHubReposAPI[
		repo,
		{"pulls"},
		GitHubQueryParamFilter[
			GitHubListPullRequests,
			{
				ops
				}
			],
		<|
			|>
		]


(* ::Subsubsection::Closed:: *)
(*PullRequestInfo*)



$GitHubActions["PullRequestInfo"]=GitHubPullRequestInfo;


GitHubPullRequestInfo[
	repo:(_String|_GitHubPath)?GitHubRepoQ,
	pull:_Integer?Positive
	]:=
	GitHubReposAPI[
		repo,
		{"pulls", ToString[pull]}
		]


(* ::Subsubsection::Closed:: *)
(*CreatePullRequest*)



$GitHubActions["CreatePullRequest"]=GitHubCreatePullRequest;


$GitHubParamMap[GitHubCreatePullRequest]=
	{
		"Title"->"title",
		"SourceBranch"->"head",
		"TargetBranch"->"base",
		"Description"->"body",
		"Modifiable"->"maintainer_can_modify"
		};
Options[GitHubCreatePullRequest]=
	Join[
		Thread[Keys[$GitHubParamMap[GitHubCreatePullRequest]]->Automatic],
		{
			"Username"->Automatic,
			"Password"->Automatic
			}
		];
GitHubCreatePullRequest[
	repo:(_String|_GitHubPath)?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	GitHubReposAPI[
		repo,
		{"pulls"},
		<|
			Method->"POST",
			"Body"->
				ExportString[
					GitHubQueryParamFilter[
						GitHubCreatePullRequest,
						DeleteDuplicatesBy[First]@{
							ops,
							"Modifiable"->True,
							"SourceBranch"->
								Replace[
									OptionValue["Username"],
									Automatic:>$GitHubUsername
									]<>":master",
							"TargetBranch"->"master",
							"Title"->
								TemplateApply[
									"Pull request from ``",
									URLBuild@
										Append[
											URLParse[
												If[StringQ@repo, repo, URL@repo], 
												"Path"
												],
											Replace[OptionValue["SourceBranch"],
												Except[_String]:>"master"
												]
											]
									]
							}
						],
					"JSON"
					],
			"Headers"->
				{
					"Authorization"->
						OptionValue[{"Username", "Password"}]
					}
			|>
		]


(* ::Subsection:: *)
(*READMEs*)



(* ::Subsubsection::Closed:: *)
(*CreateReadme*)



GitHubCreateReadme[repo_?GitRepoQ,readmeText:_String:""]:=
	With[{o=
		OpenWrite@
			FileNameJoin@{
				repo,
				"README.md"
				}
		},
		WriteString[o,readmeText];
		Close@o
		];


(* ::Subsubsection::Closed:: *)
(*GetReadme*)



GitHubGetReadme[
	repo:(_String|_GitHubPath)?GitHubRepoQ
	]:=
	GitHubReposAPI[
		repo,
		{"readme"}
		];


(* ::Subsection:: *)
(*Files*)



(* ::Subsubsection::Closed:: *)
(*GetFile*)



$GitHubActions["GetFile"]=
	GitHubGetFile;
$GitHubActions["GetDirectory"]=
	GitHubGetFile;


GitHubGetFile[
	repo:(_String|_GitHubPath)?GitHubRepoQ,
	path_String
	]:=
	GitHubReposAPI[
		repo,
		{"contents", path}
		];


(* ::Subsubsection::Closed:: *)
(*GetFileSHA*)



$GitHubActions[GetFileSHA]=GitHubGetFileSHA;


GitHubGetFileSHA[
	repo:(_String|_GitHubPath)?GitHubRepoQ,
	path:_String
	]:=
	SelectFirst[
		GitHub["GetDirectory", repo, 
			StringRiffle[Most@StringSplit[path, "/"], "/"]
			]["Content"],
		#Path==path&,
		<|"SHA"->None|>
		]["SHA"]


(* ::Subsubsection::Closed:: *)
(*AddFile*)



$GitHubParamMap[GitHubAddFile]=
	{
		"Message"->"message",
		"Branch"->"branch",
		"Committer"->"committer",
		"Author"->"author"
		};


Options[GitHubAddFile]=
	Join[
		Thread[Keys[$GitHubParamMap[GitHubAddFile]]->Automatic],
		{
			"Username"->Automatic,
			"Password"->Automatic
			}
		];
GitHubAddFile[
	repo:(_String|_GitHubPath)?GitHubRepoQ,
	file_String?FileExistsQ,
	pathy:_String|Automatic:Automatic,
	ops:OptionsPattern[]
	]:=
	With[
		{
			path=
				Replace[pathy,
					{
						Except[_String]:>FileNameTake[file]
						}
					]
			},
		GitHubReposAPI[
			repo,
			{
				"contents", 
				Replace[path,
					{
						Except[_String]:>FileNameTake[file]
						}
					]
				},
			<|
				Method->"PUT",
				"Body"->
					Prepend[
						GitHubQueryParamFilter[
							GitHubAddFile,
							DeleteDuplicatesBy[First]@
								{
									"Message"->
											Replace[OptionValue["Message"], 
												Automatic:>TemplateApply["Added ``", path]
												],
									ops
									}
							],
						"content"->
							File[file]
						],
				"Headers"->
					{
						"Authorization"->
							OptionValue[{"Username", "Password"}]
							}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*EditFile*)



$GitHubActions["EditFile"]=GitHubEditFile;


$GitHubParamMap[GitHubEditFile]=
	{
		"Message"->"message",
		"Branch"->"branch",
		"Committer"->"committer",
		"Author"->"author",
		"CommitSHA"->"sha"
		};


Options[GitHubEditFile]=
	Join[
		Thread[Keys[$GitHubParamMap[GitHubEditFile]]->Automatic],
		{
			"Username"->Automatic,
			"Password"->Automatic
			}
		];
GitHubEditFile[
	repo:(_String|_GitHubPath)?GitHubRepoQ,
	file:_String?FileExistsQ,
	pathy:_String|Automatic:Automatic,
	ops:OptionsPattern[]
	]:=
	With[{path=
		Replace[pathy,
				{
					Except[_String]:>FileNameTake[file]
					}
				]
		},
		GitHubReposAPI[
			repo,
			{"contents", path},
			<|
				Method->"PUT",
				"Body"->
					Prepend[
						GitHubQueryParamFilter[
							GitHubEditFile,
							DeleteDuplicatesBy[First]@{
								"CommitSHA"->
									Replace[OptionValue["CommitSHA"],
										Except[_String]:>
											GitHubGetFileSHA[repo, path]
										],
								"Message"->
									Replace[OptionValue["Message"], 
										Automatic:>TemplateApply["Updated ``", path]
										],
								ops
								
								}
							],
						"content"->
							File[file]
						],
				"Headers"->
					{
						"Authorization"->
							OptionValue[{"Username", "Password"}]
							}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*DeleteFile*)



$GitHubParamMap[GitHubDeleteFile]=
	{
		"Message"->"message",
		"Branch"->"branch",
		"CommitSHA"->"sha"
		};


Options[GitHubDeleteFile]=
	Join[
		Thread[Keys[$GitHubParamMap[GitHubDeleteFile]]->Automatic],
		{
			"Username"->Automatic,
			"Password"->Automatic
			}
		];
GitHubDeleteFile[
	repo:(_String|_GitHubPath)?GitHubRepoQ,
	path_String,
	ops:OptionsPattern[]
	]:=
	GitHubReposAPI[
		repo,
		{"contents", path},
		<|
			Method->"DELETE",
			"Body"->
				GitHubQueryParamFilter[
					GitHubDeleteFile,
					{
						"CommitSHA"->
							Replace[OptionValue["CommitSHA"],
								Except[_String]:>
									GitHubGetFileSHA[repo, path]
								],
						ops,
						"Message"->TemplateApply["Removed ``", path]
						}
					],
			"Headers"->
				{
					"Authorization"->
						OptionValue[{"Username", "Password"}]
						}
			|>
		];


(* ::Subsection:: *)
(* Releases*)



(* ::Subsubsection::Closed:: *)
(*Releases*)



GitHubReleases[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	identifier:_String|_Integer|None:None]:=
	GitHubReposAPI[
		repo,
		Switch[identifier,
			None,
				"releases",
			_Integer|_?(StringMatchQ[ToLowerCase@#,"latest"]&),
				{"releases",ToLowerCase@ToString@identifier},
			_,
				{"releases","tags",ToLowerCase@ToString@identifier}
			]
		];
GitHubReleases[
	repo:(_GitHubPath|_String)?GitHubReleaseQ,
	identifier:_String|_Integer|None:None
	]:=
	Replace[Replace[repo,s_String:>GitHubPathParse[s]],{
		GitHubPath[s__,"releases","tag",tag_String,o__?OptionQ]:>
			GitHubReleases[GitHubPath[s,o],tag],
		GitHubPath[s__,"releases",o__?OptionQ]:>
			GitHubReleases[GitHubPath[s,o],identifier]
		}]


(* ::Subsubsection::Closed:: *)
(*CreateRelease*)



$GitHubParamMap[GitHubCreateRelease]=
	{
		"Name"->"name",
		"TagName"->"tag_name",
		"TargetCommitish"->"target_commitish",
		"Description"->"body",
		"Draft"->"draft",
		"PreRelease"->"prerelease"
		};


Options[GitHubCreateRelease]=
	{
		"Username"->Automatic,
		"Password"->Automatic,
		"Name"->Automatic,
		"TargetCommitish"->Automatic,
		"Description"->Automatic,
		"Draft"->Automatic,
		"PreRelease"->Automatic
		};
GitHubCreateRelease[
	repo_String,
	tagName_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases"
				},
			<|
				"Method"->"POST",
				"Body"->
				ExportString[
						GitHubQueryParamFilter[
							GitHubCreateRelease,
							{
								"TagName"->tagName,
								ops
								}
							],
						"JSON"
						],
				"Headers"->{
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*EditRelease*)



$GitHubParamMap[GitHubEditRelease]=
	{
		"Name"->"name",
		"TagName"->"tag_name",
		"TargetCommitish"->"target_commitish",
		"Description"->"body",
		"Draft"->"draft",
		"PreRelease"->"prerelease"
		};


Options[GitHubEditRelease]=
	{
		"Username"->Automatic,
		"Password"->Automatic,
		"TagName"->Automatic,
		"Name"->Automatic,
		"TargetCommitish"->Automatic,
		"Description"->Automatic,
		"Draft"->Automatic,
		"PreRelease"->Automatic
		};
GitHubEditRelease[
	repo_String,
	id_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				id
				},
			<|
				"Method"->"PATCH",
				"Body"->
					ExportString[
						GitHubQueryParamFilter[
							GitHubCreateRelease,
							{
								ops
								}
							],
						"JSON"
						],
				"Headers"->{
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*DeleteRelease*)



Options[GitHubDeleteRelease]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubDeleteRelease[
	repo_String,
	id_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				id
				},
			<|
				"Method"->"DELETE",
				"Headers"->{
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*ListReleaseAssets*)



Options[GitHubListReleaseAssets]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubListReleaseAssets[
	repo_String,
	id_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				id,
				"assets"
				},
			<|
				"Method"->"GET",
				"Headers"->{
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*UploadReleaseAsset*)



$GitHubParamMap[GitHubUploadReleaseAsset]=
	{
		"Name"->Automatic,
		"Label"->Automatic
		};


Options[GitHubUploadReleaseAsset]=
	{
		"Username"->Automatic,
		"Password"->Automatic,
		"ContentType"->Automatic,
		"Name"->Automatic,
		"Label"->Automatic
		};
GitHubUploadReleaseAsset[
	repo_String,
	id_String,
	asset:(_String|_File)?FileExistsQ,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				id,
				"assets"
				},
			{
				Replace[OptionValue["Name"],
					{
						s_String:>
							("name"->s),
						_:>
							("name"->FileNameTake[asset])
						}
					],
				Replace[OptionValue["Label"],
					{
						s_String:>
							("label"->s),
						_:>
							Nothing
						}
					]
				},
			<|
				"Method"->"GET",
				"Body"->
					ReadString[asset],
				"Headers"->{
					Replace[OptionValue["ContentType"],
						{
							s_String:>
								"ContentType"->s,
							_->Nothing
							}
						],
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*GetReleaseAsset*)



Options[GitHubGetReleaseAsset]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubGetReleaseAsset[
	repo_String,
	id_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				"assets",
				id
				},
			<|
				"Method"->"GET",
				"Headers"->{
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*EditReleaseAsset*)



$GitHubParamMap[GitHubEditReleaseAsset]=
	{
		"Name"->Automatic,
		"Label"->Automatic
		};


Options[GitHubEditReleaseAsset]=
	{
		"Username"->Automatic,
		"Password"->Automatic,
		"ContentType"->Automatic,
		"Name"->Automatic,
		"Label"->Automatic
		};
GitHubEditReleaseAsset[
	repo_String,
	id_String,
	asset:(_String|_File)?FileExistsQ|None:None,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				"assets",
				id
				},
			{
				Replace[OptionValue["Name"],
					{
						s_String:>
							("name"->s),
						_:>
							If[asset=!=None,
								"name"->FileNameTake[asset],
								Nothing
								]
						}
					],
				Replace[OptionValue["Label"],
					{
						s_String:>
							("label"->s),
						_:>
							Nothing
						}
					]
				},
			<|
				"Method"->"GET",
				If[asset=!=None,
					"Body"->
						ReadString[asset],
					Nothing
					],
				"Headers"->{
					Replace[OptionValue["ContentType"],
						{
							s_String:>
								"ContentType"->s,
							_->Nothing
							}
						],
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*DeleteReleaseAsset*)



$GitHubParamMap[GitHubEditReleaseAsset]=
	{
		"Name"->Automatic,
		"Label"->Automatic
		};


Options[GitHubDeleteReleaseAsset]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubEditReleaseAsset[
	repo_String,
	id_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				"assets",
				id
				},
			<|
				"Method"->"DELETE",
				"Headers"->
					{	
						"Authorization"->
							GitHubAuthHeader[
								u,
								OptionValue["Password"]
								]
							}
				|>
			]
		];


(* ::Subsection:: *)
(*Deployments*)



(* ::Subsubsection::Closed:: *)
(*Deployments*)



GitHubDeployments[repo:(_GitHubRepo|_String)?GitHubRepoQ,
	identifier:_String|_Integer|None
	]:=
	GitHubReposAPI[repo,
		If[identifier===None,
			"deployments",
			{"deployments",ToLowerCase@ToString@identifier}
			]
		];


(* ::Subsection:: *)
(*Helpers*)



(* ::Subsubsection::Closed:: *)
(*GitHubClone *)



GitHubClone//Clear


Options[GitHubClone]:=
	Join[
		Options[GitHubPath],
		{
			OverwriteTarget->False
			},
		Git["Clone", "Options"]
		];
GitHubClone[
	repo:(_String|_GitHubPath)?(Not@*GitHubReleaseQ),
	dir:(_String?(DirectoryQ@*DirectoryName))|Automatic:Automatic,
	ops:OptionsPattern[]
	]:=
	Module[
		{
			path=
				If[MatchQ[repo, _GitHubPath],
					repo,
					GitHubPath[repo, FilterRules[{ops}, Options@GitHubPath]]
					]
			},
		With[
			{
				o=Options[path],
				n=Normal[path]
				},
			Switch[Lookup[o, "Tree", "tree"],
				"tree",
					If[Length@n<3,
						GitClone[
							URL[path], 
							dir,
							TrueQ@OptionValue[OverwriteTarget],
							ops
							],
						SVNExport[
							URL[GitHubPath[repo, "Tree"->"trunk", "Branch"->Nothing]],
							dir,
							"TrustServer"->True,
							OverwriteTarget->OptionValue[OverwriteTarget]
							]
						],
				"trunk",
					SVNExport[
						URL[path],
						dir,
						"TrustServer"->True,
						OverwriteTarget->OptionValue[OverwriteTarget]
						],
				"raw",
					Replace[
						URLDownload[
							URL[path],
							FileNameJoin@{
								If[StringQ@dir, 
									If[!DirectoryQ@dir, CreateDirectory[dir]];
									dir,
									$TemporaryDirectory
									], 
								Last@n
								}
							],
						File[f_]:>f
						],
				_,
					GitHub::badtree=
						"Don't know what to do with tree type ``";
					Message[GitHub::badtree,
						Lookup[o, "Tree", "tree"]
						];
					$Failed
				]
			]/;path=!=$Failed
		];
GitHubClone[
	repo:(_String|_GitHubPath)?GitHubReleaseQ,
	dir:(_String?(DirectoryQ@*DirectoryName))|Automatic:Automatic
	]:=
	With[{release=
		GitHubImport["Releases",
			repo,
			"latest"
			]["Content"]
		},
		If[AssociationQ@release,
			If[Length@release["Assets"]>0,
				With[{url=
					release[["Assets",-1,"BrowserDownloadURL"]]
					},
					URLDownload[
						url,
						FileNameJoin@{
							Replace[dir, 
								{
									Automatic:>$TemporaryDirectory,
									_:>(If[!DirectoryQ@dir, CreateDirectory[dir]];dir)
									}
								],
							URLParse[url,"Path"][[-1]]
							}
						]
					],
				ExtractArchive[
					URLDownload[
						release["ZipballURL"],
						FileNameJoin@{
							$TemporaryDirectory,
							URLParse[release["ZipballURL"],"Path"][[-1]]
							}
						],
					Replace[dir, 
						{
							Automatic:>$TemporaryDirectory,
							_:>(If[!DirectoryQ@dir, CreateDirectory[dir]];dir)
							}
						]
					]
				],
			$Failed
			]
		]


(* ::Subsubsection::Closed:: *)
(*GitHubConfigure*)



GitHubConfigure[
	dirBase:_String?DirectoryQ|Automatic,
	repo:_String?GitHubRepoQ|_GitHubPath,
	ignorePats:{___String}|None:None,
	excludePats:{___String}|None:None
	]:=
	Module[{repoExistsQ, dir=Replace[dirBase, Automatic:>Directory[]]},
		If[!GitRepoQ@dir,
			GitInit[dir, ignorePats, excludePats];
			GitSetRemote[dir, repo];
			repoExistsQ=Between[URLRead[repo,"StatusCode"],{200,299}];
			If[repoExistsQ, GitRealignRemotes[dir]]
			];
		If[GitRepoQ@dir,
			If[!ValueQ[repoExistsQ],
				repoExistsQ=Between[URLRead[repo,"StatusCode"],{200,299}]
				];
			If[!repoExistsQ,
				GitHubImport["Create",
					URLParse[repo, "Path"][[-1]]
					];
				GitSetRemote[dir, repo]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*GitHubPush*)



GitHubPush[
	dir:_String?GitRepoQ,
	repo:_String|_GitHubPath|Automatic:Automatic
	]:=
	Replace[repo,{
		Automatic:>
			Replace[
				GitGetRemoteURL[dir, "PushURL"->True],
				{
					s_String:>
						Git["Push", dir, s],
					(r_->s_):>
						Quiet@
							Check[
								Git["Push", dir, r, "master"],
								Git["Push", s]
								]
					}
				],
		s_String?(URLParse[#, "Scheme"]===None&):>
			Quiet@
				Check[
					Git["Push", dir, s, "master"],
					Git["Push", dir, URL@GitHubPath[s]]
					],
		s_String:>
			Git["Push", dir, s]
		}]


(* ::Subsubsection::Closed:: *)
(*GitHubImport*)



GitHubImport[a_Association]:=
	Association@
		KeyValueMap[
			StringReplace[
				StringJoin[
					Replace[
						HoldPattern[Capitalize[s_String]]:>
							(ToUpperCase@StringTake[s,1]<>StringDrop[s,1])
						]@*Capitalize/@StringSplit[#,"_"]
					],{
				"Id"~~EndOfString->"ID",
				"Url"->"URL",
				"Html"->"HTML",
				"Sha"->"SHA"
				}]->
				Which[
					StringEndsQ[#,"_at"],
						DateObject@#2,
					StringEndsQ[#,"url"],
						URL[#2],
					True,
						GitHubImport@#2
					]&,
		a
		];
GitHubImport[h_HTTPResponse]:=
	<|
		"StatusCode"->
			h["StatusCode"],
		"Content"->
			If[MatchQ[h["StatusCode"],0|(_?(Between@{200,299}))],
				Quiet[
					Check[
						GitHubImport@Import[h, "RawJSON"],
						Null,
						Import::jsonnullinput
						],
					Import::jsonnullinput
					],
				$Failed
				],
		If[h["StatusCode"]>400,
			"Message"->Import[h, "RawJSON"]["message"],
			Nothing
			]
		|>;
GitHubImport[s_String]:=
	s;
GitHubImport[l_List]:=
	GitHubImport/@l;
GitHubImport[e_]:=
	e


GitHubImport[
	command_?(KeyMemberQ[$githubactions,ToLowerCase@#]&),
	args__
	]:=
	With[{gh=GitHub[command,args]},
		GitHubImport[gh]/;Head[gh]=!=GitHub
		]
GitHubImport[
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	With[{gh=GitHub[path,query,headers]},
		GitHubImport[gh]/;Head[gh]=!=GitHub
		]


(* ::Subsection:: *)
(*Actions*)



(* ::Subsubsection::Closed:: *)
(*Actions*)



$GitHubActions=
	KeySort@
		Join[
			$GitHubActions,
			<|
				"Push"->
					GitHubPush,
				"Configure"->
					GitHubConfigure,
				"Repositories"->
					GitHubRepositories,
				"ListMyRepositories"->
					GitHubListMyRepositories,
				"Clone"->
					GitHubClone,
				"Create"->
					GitHubCreate,
				"Delete"->
					GitHubDelete,
				"Edit"->
					GitHubEditRepository,
				"ListContributors"->
					GitHubRepositoryContributors,
				"ListBranches"->
					GitHubRepositoryBranches,
				"BranchInfo"->
					GitHubRepositoryBranchInfo,
				"Fork"->
					GitHubFork,
				"ListForks"->
					GitHubListForks,
				"CreateReadme"->
					GitHubCreateReadme,
				"GetReadme"->
					GitHubGetReadme,
				"GetFile"->
					GitHubGetFile,
				"AddFile"->
					GitHubAddFile,
				"DeleteFile"->
					GitHubDeleteFile,
				"Releases"->
					GitHubReleases,
				"CreateRelease"->
					GitHubCreateRelease,
				"EditRelease"->
					GitHubEditRelease,
				"DeleteRelease"->
					GitHubDeleteRelease,
				"UploadReleaseAsset"->
					GitHubUploadReleaseAsset,
				"GetReleaseAsset"->
					GitHubGetReleaseAsset,
				"EditReleaseAsset"->
					GitHubEditReleaseAsset,
				"DeleteReleaseAsset"->
					GitHubDeleteReleaseAsset,
				"Deployments"->
					GitHubDownloads,
				"Path"->
					Function[GitHubPath[##]],
				"URL"->
					Function[
						Replace[GitHubPath[##],
							g_GitHubPath:>URL[g]
							]
						],
				"RawPath"->
					Function[GitHubPath[##, "Tree"->"raw"]],
				"RawURL"->
					Function[
						Replace[GitHubPath[##, "Tree"->"raw"],
							g_GitHubPath:>URL[g]
							]
						],
				"SVNPath"->
					Function[GitHubPath[##, "Tree"->"trunk", "Branch"->Nothing]],
				"SVNURL"->
					Function[
						Replace[GitHubPath[##, "Tree"->"trunk", "Branch"->Nothing],
							g_GitHubPath:>URL[g]
							]
						],
				"PathQ"->
					GitHubPathQ,
				"RepoQ"->
					GitHubRepoQ
				|>
				];


End[];



