(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Section:: *)
(*Git Connections*)



(* ::Subsection:: *)
(*Git*)



PackageScopeBlock[
	GitRun::usage="processRunDupe wrapper for git";
	GitRegisterFunction::usage="Registers a Git function";
	$GitLogCommands::usage="";
	$GitCommandLog::usage="";
	]


(* ::Subsubsection::Closed:: *)
(*Create*)



PackageScopeBlock[
	GitCreate::usage="Creates a new repository";
	GitInit::usage="Initializes a git repository";
	GitClone::usage="Clones a repository";
	];


(* ::Subsubsection::Closed:: *)
(*Edit*)



PackageScopeBlock[
	GitIgnore::usage="Adds to the .gitignore file for a directory";
	GitAdd::usage="Adds a file to the staging area of a  git repository";
	GitCommit::usage="Runs the commit command, using -a by default";
	]


(* ::Subsubsection::Closed:: *)
(*Config/Status*)



PackageScopeBlock[
	GitStatus::usage="Gets the status of a repository";
	GitListTree::usage="Lists files on the tree";
	GitListTreeRecursive::usage="Lists files on the tree recursively";
	GitLog::usage="Gets the log of the git repo";
	GitConfig::usage="Sugar on the GitConfig tool";
	GitHelp::usage="Gets help from the git man pages";
	];


(* ::Subsubsection::Closed:: *)
(*Remotes and branching*)



PackageScopeBlock[
	GitListRemotes::usage=
		"git remote -v show command";
	GitAddRemote::usage=
		"git remote add origin command";
	GitRemoveRemote::usage=
		"Removes remote";
	GitFetch::usage="git fetch";
	GitPush::usage="git push";
	GitPushOrigin::usage="git push origin master";
	GitPull::usage="git pull";
	GitPullOrigin::usage="git pull origin master";
	GitBranch::usage="git branch";
	GitShowBranch::usage="git show branch";
	];


(* ::Subsubsection::Closed:: *)
(*Repo finding*)



PackageScopeBlock[
	GitRepositories::usage="Finds all the directories that support a git repo";
	$GitRepo::usage="The current git repo";
	GitRepo::usage=
		"Returns: 
the arg if it is a repo, 
a github URL if the arg is github:<repo>, 
else None";
	GitRepoQ::usage=
		"Returns true if the thing is a directory with a .git file";
	]


(* ::Subsubsection::Closed:: *)
(*Git*)



$GitActions::usage=
	"The known actions for Git";
Git::usage=
	"A general head for all Git actions";


(* ::Subsection:: *)
(*SVN*)



PackageScopeBlock[
	SVNRun::usage="Runs SVN";
	SVNFileNames::usage="svn ls";
	SVNCheckOut::usage="Uses SVN to clone from a server";
	SVNExport::usage="Uses SVN to pull a single file from a server";
	$SVNActions::usage=
		"Known actions for SVN";
	]


SVN::usage=
	"A general head for all SVN actions";


(* ::Subsection:: *)
(*GitHub*)



PackageScopeBlock[
	$GitHubUsername::usage=
		"The user's github username";
	$GitHubPassword::usage=
		"The user's github password";
	FormatGitHubPath::usage="";
	GitHubPath::usage=
		"Represents a github path";
	GitHubRepoQ::usage=
		"Returns if the path could be a github repo";
	GitHubPathQ::usage="";
	GitHubCreate::usage="";
	GitHubDelete::usage="";
	GitHubDeployments::usage="";
	GitHubCreateRelease::usage="";
	GitHubEditRelease::usage="";
	GitHubDeleteRelease::usage="";
	GitHubUploadReleaseAsset::usage="";
	GitHubGetReleaseAsset::usage="";
	GitHubEditReleaseAsset::usage="";
	GitHubDeleteReleaseAsset::usage="";
	GitHubReleases::usage="";
	GitHubRepositories::usage="";
	$GitHubActions::usage=
		"A collection of known calls for the GitHub function";
	GitHubImport::usage=
		"Imports and converts GitHub JSON";
	]


GitHub::usage=
	"A connection to the GitHub functinality";


Begin["`Private`"];


(* ::Subsection:: *)
(*Constants*)



(* ::Subsubsection::Closed:: *)
(*GitRepo*)



If[Not@MatchQ[$GitRepo,_String?DirectoryQ],
	$GitRepo=None
	];


(* ::Subsection:: *)
(*Git*)



(* ::Subsubsection::Closed:: *)
(*processRunCopy*)



(* ::Text:: *)
(*An exact duplicate of ProcessRun to make this stand-alone*)



processRunDupe::pnfd="Program `` not found. 
$PATH = ``
$PWD = ``";
processRunDupe::fail="Process failed to run: ``"; 
processRunDupe::err="\nError in command \"``\":\n``";
processRunDupe~SetAttributes~HoldRest;


Options[processRunDupe]=
	Join[Options[RunProcess],{
		"ErrorHandler"->Automatic,
		"ParseFunction"->Identity
		}];
processRunDupe[cmds:{__},
	errorMessage:Except[_?OptionQ|_FilterRules]:processRunDupe::err,
	ops:OptionsPattern[]
	]:=
	Block[{capturedMessages={}},
		With[{r=
			GeneralUtilities`WithMessageHandler[
				RunProcess[cmds,
					FilterRules[{ops},Options@RunProcess]
					],
				AppendTo[capturedMessages,#]&
				],
			parseFunction=
				OptionValue["ParseFunction"],
			errorHander=
				Replace[OptionValue["ErrorHandler"],
					Automatic->
						Function[Null,
							Message[#,
								StringJoin@Riffle[cmds," "],
								#2
								],
							HoldFirst
							]
					]
			},
			If[r=!=$Failed,
				If[r["StandardError"]!="",
					errorHander[errorMessage,r["StandardError"]]
					];
				parseFunction@Replace[
					StringTrim@r["StandardOutput"],
					""->Null
					],
				Message[processRunDupe::fail,
					StringJoin@Riffle[
						Replace[cmds,
							(k_->v_):>
								(ToString@k<>"=="<>ToString@v),
							1],
						" "]
					];
				Replace[capturedMessages,
					Failure[RunProcess,<|
						"MessageTemplate":>
							RunProcess::pnfd,
						"MessageParameters" -> pars_
						|>]:>(
							Message[processRunDupe::pnfd,
								Sequence@@Join[pars,
									StringTrim@
										RunProcess[{$SystemShell,"-c","echo $PATH"},"StandardOutput"],
									StringTrim@
										RunProcess[{$SystemShell,"-c","echo $PWD"},"StandardOutput"]
									]
								];
							),
					1];
				$Failed
				]
			]
		];
processRunDupe[s_String,
	errorMessage:_MessageName:processRunDupe::err,
	ops:OptionsPattern[]]:=
	processRunDupe[{s},errorMessage,ops];


(* ::Subsubsection::Closed:: *)
(*GitRun*)



If[!ValueQ@$GitLogCommands, $GitLogCommands=False];
If[!ListQ@$GitCommandLog, $GitCommandLog={}];


gitDoInDir[dir_String?DirectoryQ,cmd_]:=
	With[{d=ExpandFileName@dir},
			SetDirectory@d;
			With[{r=cmd},
				ResetDirectory[];
				r
				]
			];
gitDoInDir~SetAttributes~HoldRest;


processRunDupe;
Git::err=processRunDupe::err;


GitRun//Clear


GitRun[
	dir:_String?DirectoryQ|None|Automatic:None,
	cmd1_String?(Not@*DirectoryQ),
	cmd2___String
	]:=
	With[{d=Replace[dir,Automatic:>$GitRepo]},
		Replace[
			Git::err,
			_MessageName:>
				(Git::err=processRunDupe::err)
			];
		If[MatchQ[d,_String],
			With[{
				cmd=
					{
						"git",
						Sequence@@Replace[$GitBaseOptionArgs, Except[_?OptionQ]->{}],
						cmd1, 
						cmd2
						}//
						Map[If[FileExistsQ@#, ExpandFileName@#, #]&]
				},
				If[$GitLogCommands, AppendTo[$GitCommandLog, cmd]];
				processRunDupe[
					cmd,
					Git::err, 
					ProcessDirectory->ExpandFileName@d
					]
				],
			With[{cmd={"git", cmd1, cmd2}},
				If[$GitLogCommands, AppendTo[$GitCommandLog, cmd]];
				processRunDupe[
					cmd, 
					Git::err
					]
				]
			]
		];
GitRun[
	dir:_String?DirectoryQ|None|Automatic:None,
	cmd1:_String?(Not@*DirectoryQ)|{__String},
	cmd2:_String|{__String}...
	]:=
	With[{
		d=Replace[dir,Automatic:>$GitRepo],
		cmdBits=
			Flatten[
				Riffle[
					Join[
						{"git", Sequence@@Replace[$GitBaseOptionArgs, Except[_?OptionQ]->{}]},
						Flatten@{#}
						]&/@{cmd1, cmd2},"\n\n"],
				1
				]//
				Map[If[FileExistsQ@#, ExpandFileName@#, #]&]
		},
		Replace[
			Git::err,
			_MessageName:>
				(Git::err=processRunDupe::err)
			];
		If[$GitLogCommands, AppendTo[$GitCommandLog, cmdBits]];
		If[MatchQ[d,_String],
			processRunDupe[
				cmdBits,
				Git::err,
				ProcessDirectory->ExpandFileName@d
				],
			processRunDupe[
				cmdBits,
				Git::err
				]
			]
		];
Git::nodir="`` is not a valid directory";
Git::nrepo="`` not a git repository";


(* ::Subsubsection::Closed:: *)
(*GitPrepParams*)



$GitParamMap=<||>;


GitPrepType//Clear
GitPrepType[n_?NumericQ]:=
	ToString[n];
GitPrepType[n_?DateObjectQ]:=
	ToString@UnixTime[n];
GitPrepType[q_Quantity]:=
	ToString@
		QuantityMagnitude@
			If[CompatibleUnitQ[q, "Seconds"], 
				UnitConvert[q, "Seconds"],
				q
				];
GitPrepType[l_List]:=
	StringRiffle[GitPrepType/@l, ","];
GitPrepType[e_]:=e;


GitPrepParamVals[ops_]:=
	Replace[
		ops,
		{
			(h:Rule|RuleDelayed)[s_String, o_]:>
				s->GitPrepType[o]
			},
		1
		];
GitPrepParams[ops_, map_]:=
	Replace[
		GitPrepParamVals@Flatten@Normal@{ops},
		{
			(Rule|RuleDelayed)[s_String, True]:>
				Replace[
					Lookup[map, s, None],
					{
						p_String?(StringLength[#]==1&):>
							"-"<>p,
						p_String:>
							"--"<>p,
						{p_String, join_String}:>
							"--"<>p<>join<>"true",
						_->Nothing
						}
					],
			(Rule|RuleDelayed)[s_String, v_String]:>
				Replace[
					Lookup[map, s, None],
					{
						p_String?(StringLength[#]==1&):>
							Sequence@@{"-"<>p, v},
						p_String:>
							"--"<>p<>"="<>v,
						{p_String, join_String}:>
							"--"<>p<>join<>v,
						_->Nothing
						}
					],
			_->Nothing
			},
		1
		];
GitPrepParams[fn_, ops_, map_]:=
	With[{baseOps=Flatten@{ops}},
		GitPrepParams[
			Flatten[{baseOps, Select[Options@fn, FreeQ[baseOps, #[[1]]]&]}], 
			map
			]
		]


(* ::Subsubsection::Closed:: *)
(*GitRegisterFunction*)



GitRegisterFunction//Clear
GitRegisterFunction[
	sym_Symbol, 
	cmd:{__String},
	map_?OptionQ,
	joinOps:_List?OptionQ:{},
	fn:_Symbol:GitRun
	]:=
	With[
		{
			main=ToLowerCase[First@cmd],
			rest=Sequence@@Map[ToLowerCase, Rest@cmd],
			big=ToUpperCase[StringTake[#, 1]]<>StringDrop[#, 1]&/@Map[ToLowerCase, cmd]
			},
		$GitParamMap[big]=map;
		Options[sym]=
			DeleteDuplicatesBy[
				Join[
					joinOps,
					Thread[Keys@$GitParamMap[big]->Automatic]
					],
				First
				];
		sym[
			dir:_String?DirectoryQ|Automatic:Automatic,
			args___String,
			ops:OptionsPattern[]
			]:=
			fn[
				dir,
				main,
				rest,
				Sequence@@
					GitPrepParams[
						sym,
						{ops}, 
						$GitParamMap[big]
						],
				args
				]
		];
GitRegisterFunction[
	sym_Symbol, 
	cmd_String,
	map_?OptionQ,
	joinOps:_List?OptionQ:{},
	fn:_Symbol:GitRun
	]:=
	GitRegisterFunction[sym, {cmd}, map, joinOps]
GitRegisterFunction[
	sym_Symbol, 
	map_?OptionQ,
	joinOps:_List?OptionQ:{},
	fn:_Symbol:GitRun
	]:=
	GitRegisterFunction[
		sym,
		ToLowerCase@StringTrim[SymbolName[sym], "Git"],
		map,
		joinOps
		]


(* ::Subsubsection::Closed:: *)
(*GitRepoQ*)



GitRepoQ[d:(_String|_File)?DirectoryQ]:=
	DirectoryQ@FileNameJoin@{d,".git"};
GitRepoQ[_]:=False


(* ::Subsubsection::Closed:: *)
(*GitAddGitIgnore*)



GitAddGitIgnore[
	dirB:_String?DirectoryQ|Automatic:Automatic,
	patterns:_String|{__String}:
		{
			".DS_Store"
			}
	]:=
	With[
		{dir=Replace[dirB, Automatic:>Directory[]]},
		If[GitRepoQ@dir,
			With[{f=OpenWrite[FileNameJoin@{dir,".gitignore"}]},
				WriteLine[f,
					StringJoin@Riffle[Flatten@{patterns},"\n"]
					];
				Close@f
				],
			$Failed
			]
		];


(* ::Subsubsection::Closed:: *)
(*GitAddGitExclude*)



GitAddGitExclude[
	dirB:_String?DirectoryQ|Automatic:Automatic,
	patterns:_String|{__String}:{"*.DS_Store"}
	]:=
	With[
		{dir=Replace[dirB, Automatic:>Directory[]]},
		If[GitRepoQ@dir,
			If[Not@DirectoryQ@FileNameJoin@{dir,".git","info"},
				CreateDirectory[FileNameJoin@{dir,".git","info"}]
				];
			With[{f=OpenWrite[FileNameJoin@{dir,".git","info","exclude"}]},
				WriteLine[f,
					StringJoin@Riffle[Flatten@{patterns},"\n"]
					];
				Close@f
				],
			$Failed
			]
		]


(* ::Subsubsection::Closed:: *)
(*GitInit*)



GitCreate[dir_String?(DirectoryQ@*DirectoryName)]:=
	With[{d=ExpandFileName@dir},
		Quiet@CreateDirectory@d;
		GitInit[d]
		];


$GitParamMap["Init"]=
	{
		"Quiet"->"quiet",
		"Bare"->"bare",
		"Template"->"template",
		"SeparateGitDir"->"separate-git-dir",
		"Shared"->"shared"
		};
Options[GitInit]=
	Thread[Keys@$GitParamMap["Init"]->Automatic];
GitInit[
	dir:_String?DirectoryQ|Automatic:Automatic,
	ignorePats:{___String}|None:None,
	excludePats:{___String}|None:None,
	ops:OptionsPattern[]
	]:=
	With[
	{
		r=
			GitRun[dir, 
				Sequence@@
						GitPrepParams[
							GitInit,
							{ops}, 
							$GitParamMap["Init"]
							],
				"init"
				]
		},
		If[ignorePats=!=None, 
			GitAddGitIgnore[dir, ignorePats]
			];
		If[excludePats=!=None,
			GitAddGitExclude[dir, excludePats];
			];
		r
		]


(* ::Subsubsection::Closed:: *)
(*GitClone*)



GitClone//Clear


$GitParamMap["Clone"]=
	{
		"Local"->"local",
		"NoHardlinks"->"no-hardlinks",
		"Shared"->"shared",
		"Reference"->"reference",
		"Dissociate"->"dissociate",
		"Quiet"->"quiet",
		"Verbose"->"verbose",
		"Progress"->"progress",
		"NoCheckout"->"no-checkout",
		"Bare"->"bare",
		"Mirror"->"mirror",
		"Origin"->"origin",
		"Branch"->"branch",
		"UploadPack"->"upload-pack",
		"Template"->"template",
		"Config"->"config",
		"Depth"->"depth",
		"ShallowSince"->"shallow-since",
		"ShallowExclude"->"shallow-exclude",
		"SingleBranch"->"single-branch",
		"NoSingleBranch"->"no-single-branch",
		"NoTags"->"no-tags",
		"RecurseSubmodules"->"recurse-submodules",
		"ShallowSubmodules"->"shallow-submodules",
		"NoShallowSubmodules"->"no-shallow-submodules",
		"SeparateGitDir"->"separate-git-dir",
		"Jobs"->"jobs"
		};


Options[GitClone]=
	Thread[Keys[$GitParamMap["Clone"]]->Automatic];
GitClone[
	repo:_String|_File|_URL,
	dir:_String|_File|Automatic:Automatic,
	overrwriteTarget:True|False:False,
	o___?OptionQ
	]:=
	With[{
		r=
			Replace[repo,{
				File[d_]:>
					If[GitRepoQ@d,
						d,
						GitRepo
						],
				URL[d_]:>
					d
				}],
		d=
			Replace[dir,
				Automatic:>
					FileNameJoin@{
						$TemporaryDirectory,
						Switch[repo,
							_String|_File,
								FileBaseName@repo,
							_URL,
								URLParse[repo,"Path"][[-1]]
							]
						}
				]
			},
		If[overrwriteTarget,
			Quiet@DeleteDirectory[d,DeleteContents->True]
			];
		CreateDirectory[d, CreateIntermediateDirectories->True];
		GitRun[d, "clone", r, d,
			Sequence@@
				GitPrepParams[
					GitClone,
					{o}, 
					$GitParamMap["Clone"]
					]
			];
		d
		];


(* ::Subsubsection::Closed:: *)
(*GitIgnore*)



GitIgnore[dir:_String?DirectoryQ|Automatic:Automatic,filePatterns:{___}]:=
	With[{d=Replace[dir,Automatic:>$GitRepo]},
		If[MatchQ[d,_String?DirectoryQ],
			With[{file=OpenAppend@FileNameJoin@{d,".gitignore"}},
				Do[
					WriteLine[file,f],
					{f,filePatterns}
					];
				Close@file;
				GitRun[d,"add",".gitignore"]
				],
			Message[GitRun::nodir,d];$Failed
			]
		];


(* ::Subsubsection::Closed:: *)
(*GitAdd*)



GitRegisterFunction[GitAdd, "add",
	{
		"DryRun"->"dry-run",
		"Verbose"->"verbose",
		"Force"->"force",
		"Interactive"->"interactive",
		"Patch"->"patch",
		"Edit"->"edit",
		"Update"->"update",
		"NoIgnoreRemoval"->"no-ignore-removal",
		"IgnoreRemoval"->"ignore-removal",
		"IntentToAdd"->"intent-to-add",
		"Refresh"->"refresh",
		"IgnoreErrors"->"ignore-errors",
		"IgnoreMissing"->"ignore-missing",
		"NoWarnEmbeddedRepo"->"no-warn-embedded-repo",
		"ChangeModee"->"chmod"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitMove*)



GitRegisterFunction[GitMove, 
	"mv",
	{
		"Force"->"force",
		"IgnoreErrors"->"k",
		"DryRun"->"dry-run",
		"Verbose"->"verbose"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitRemove*)



GitRegisterFunction[GitRemove,
 "rm",
	{
		"Force"->"force",
		"DryRun"->"dry-run",
		"Recursive"->"r",
		"Cached"->"cached",
		"IgnoreUnmatch"->"ignore-unmatch",
		"Quiet"->"quiet"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitRemoveRecursive*)



Options[GitRemoveRecursive]=
	Options[GitRemove]
GitRemoveRecursive[
	dir:_String?DirectoryQ|Automatic:Automatic,
	args___String,
	ops:OptionsPattern[]
	]:=
	GitRemove[dir, args, "Recursive"->True, ops]


(* ::Subsubsection::Closed:: *)
(*GitRemoveCached*)



Options[GitRemoveCached]=
	Options[GitRemove]
GitRemoveCached[
	dir:_String?DirectoryQ|Automatic:Automatic,
	args___String,
	ops:OptionsPattern[]
	]:=
	GitRemove[dir, args, "Cached"->True, ops]


(* ::Subsubsection::Closed:: *)
(*GitRemoveCachedRecursive*)



Options[GitRemoveCachedRecursive]=
	Options[GitRemove]
GitRemoveCachedRecursive[
	dir:_String?DirectoryQ|Automatic:Automatic,
	args___String,
	ops:OptionsPattern[]
	]:=
	GitRemove[dir, args, "Recursive"->True, "Cached"->True, ops]


(* ::Subsubsection::Closed:: *)
(*GitCommit*)



GitRegisterFunction[
	GitCommit,
	"commit",
	{
		"All"->"all",
		"Patch"->"patch",
		"ReuseMessage"->"reuse-message",
		"ReeditMessage"->"reedit-message",
		"FixUp"->"fixup",
		"Squash"->"squash",
		"ResetAuthor"->"reset-author",
		"Short"->"short",
		"Branch"->"branch",
		"Porcelain"->"porcelain",
		"Long"->"long",
		"Null"->"null",
		"File"->"file",
		"Author"->"author",
		"Date"->"date",
		"Message"->"message",
		"Template"->"template",
		"Signoff"->"signoff",
		"NoVerify"->"no-verify",
		"AllowEmpty"->"allow-empty",
		"AllowEmptyMessage"->"allow-empty-message",
		"Cleanup"->"cleanup",
		"Edit"->"edit",
		"NoEdit"->"no-edit",
		"Amend"->"amend",
		"NoPostRewrite"->"no-post-rewrite",
		"Include"->"include",
		"Only"->"only",
		"UntrackedFiles"->"untracked-files",
		"Verbose"->"verbose",
		"Quiet"->"quiet",
		"DryRun"->"dry-run",
		"Status"->"status",
		"NoStatus"->"no-status",
		"GpgSign"->"gpg-sign",
		"NoGpgSign"->"no-gpg-sign"
		},
	{
		"Message"->"Commited via Mathematica"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitLog*)



GitLog//Clear


GitRegisterFunction[
	GitLog,
	"log",
	SortBy[First]@
	{
		"Follow"->"follow",
		"Decorate"->"decorate",
		"Source"->"source",
		"UseMailmap"->"use-mailmap",
		"FullDiff"->"full-diff",
		"LogSize"->"log-size",
		"TraceLines"->"L",
		"MaxCount"->"max-count",
		"Skip"->"skip",
		"Since"->"since",
		"Before"->"before",
		"Committer"->"committer",
		"GrepReflog"->"grep-reflog",
		"Grep"->"grep",
		"AllMatch"->"all-match",
		"InvertGrep"->"invert-grep",
		"RegexpIgnoreCase"->"regexp-ignore-case",
		"BasicRegexp"->"basic-regexp",
		"ExtendedRegexp"->"extended-regexp",
		"FixedStrings"->"fixed-strings",
		"PerlRegexp"->"perl-regexp",
		"RemoveEmpty"->"remove-empty",
		"Merges"->"merges",
		"NoMerges"->"no-merges",
		"MinParents"->"min-parents",
		"MaxParents"->"max-parents",
		"NoMinParents"->"no-max-parents",
		"NoMaxParents"->"no-max-parents",
		"FirstParent"->"first-parent",
		"Bisect"->"bisect",
		"Not"->"not",
		"All"->"all",
		"Branches"->"branches",
		"Tags"->"tags",
		"Remotes"->"remotes",
		"Glob"->"glob",
		"Exclude"->"exclude",
		"Reflog"->"reflog",
		"IgnoreMissing"->"ignore-missing",
		"Stdin"->"stdin",
		"CherryMark"->"cherry-mark",
		"CherryPick"->"cherry-pick",
		"RightOnly"->"right-only",
		"Cherry"->"cherry",
		"WalkReflogs"->"walk-reflogs",
		"Merge"->"merge",
		"Boundary"->"boundary",
		"SimplifyByDecoration"->"simplify-by-decoration",
		"FullHistory"->"full-history",
		"Dense"->"dense",
		"Sparse"->"sparse",
		"SimplifyMerges"->"simplify-merges",
		"AncestryPath"->"ancestry-path",
		"DateOrder"->"date-order",
		"AuthorDateOrder"->"author-date-order",
		"TopoOrder"->"topo-order",
		"Reverse"->"reverse",
		"NoWalk"->"no-walk",
		"DoWalk"->"do-walk",
		"Pretty"->"pretty",
		"AbbrevCommit"->"abbrev-commit",
		"NoAbbrevCommit"->"no-abbrev-commit",
		"Oneline"->"oneline",
		"Encoding"->"encoding",
		"ExpandTabs"->"expand-tabs",
		"Notes"->"notes",
		"NoNotes"->"no-notes",
		"ShowNotes"->"show-notes",
		"ShowSignature"->"show-signature",
		"RelativeDate"->"relative-date",
		"Date"->"date",
		"Parents"->"parents",
		"Children"->"children",
		"LeftRight"->"left-right",
		"Graph"->"graph",
		"ShowLinearBreak"->"show-linear-break",
		"Compress"->"c",
		"CompressComplete"->"cc",
		"ShowMergeDiffs"->"m",
		"Recursive"->"r",
		"ShowTree"->"t",
		"Stat"->"stat"
		}
	]


(* ::Subsubsection::Closed:: *)
(*GitLogDataset*)



(* ::Text:: *)
(*Assumes commit has already been stripped*)



GitLogPostProcess[ass_]:=
	With[
		{
			date=
				With[{dateBits=StringSplit[StringTrim@ass["Date"]]},
					DateObject[
						StringRiffle[Most[dateBits]],
						TimeZone->
							(ToExpression[Last@dateBits]/100)
						]
					]
			},
		ReplacePart[ass,
			"Date"->date
			]
		]


GitLogParsePiece[str_String]:=
	Module[
		{
			commit,
			body,
			head,
			headParams,
			message,
			messageBits,
			files=None
			},
		{commit, body}=
			StringSplit[str, "\n", 2];
		{head, message}=
			StringSplit[body, "\n\n", 2];
		If[StringContainsQ[message, StartOfLine~~" "~~WordCharacter],
			messageBits=StringSplit[message, "\n\n"];
			files=
				StringCases[
					Last@messageBits, 
					StartOfLine~~" "~~fil:Except[WhitespaceCharacter]..~~Whitespace~~"|":>
						fil
					];
			message=StringRiffle[Most@messageBits, "\n\n"]
			];
		headParams=
			StringCases[
					head,
					StartOfLine~~tag:WordCharacter..~~":"~~val:Except["\n"]..:>
						(tag->val)
					];
		GitLogPostProcess@Association@
			{
				"Commit"->commit,
				"Message"->StringTrim@message,
				headParams,
				"Files"->
					If[files===None, 
						Missing["NotAvailable"],
						files
						]
				}
		];


Options[GitLogDataset]=
	Options[GitLog];
GitLogDataset[args___]:=
	With[{str=Replace[GitLog[args], Null->""]},
		Dataset[
			GitLogParsePiece/@
				StringSplit[str, StartOfLine~~"commit "]
			]/;StringQ@str
		]


(* ::Subsubsection::Closed:: *)
(*GitFileHistory*)



GitFileHistory//Clear


Options[GitFileHistory]=
	Options[GitLogDataset]
GitFileHistory[
	args__,
	fpat:_?StringPattern`StringPatternQ:"*",
	ops:OptionsPattern[]
	]:=
	With[
		{
			ds=
				Normal@
					GitLogDataset[
						args,
						If[!StringQ@fpat, 
							First@StringPattern`PatternConvert[fpat], 
							fpat
							],
						ops,
						"Stat"->True
						]
			},
		Dataset@GroupBy[
			Flatten@
				Map[
					With[{files=#Files, rest=KeyDrop[#, "Files"]}, 
						Map[#->rest&, files]
						]&,
					ds
					],
			First->Last,
			GroupBy[#Commit&]
			]/;ListQ@ds
		]


(* ::Subsubsection::Closed:: *)
(*GitStatus*)



GitRegisterFunction[
	GitStatus,
	"status",
	{
		"Short"->"short",
		"Branch"->"branch",
		"ShowStash"->"show-stash",
		"Porcelain"->"porcelain",
		"Long"->"long",
		"Verbose"->"verbose",
		"UntrackedFiles"->"untracked-files",
		"IgnoreSubmodules"->"ignore-submodules",
		"Ignored"->"ignored",
		"NULTerminated"->"z",
		"Column"->"column"
		}
	]


(* ::Subsubsection::Closed:: *)
(*GitConfig*)



GitRegisterFunction[
	GitConfig,
	"config",
	{
		"ReplaceAll"->"replace-all",
		"Add"->"add",
		"Get"->"get",
		"GetAll"->"get-all",
		"GetRegexp"->"get-regexp",
		"GetUrlmatch"->"get-urlmatch",
		"Global"->"global",
		"System"->"system",
		"Local"->"local",
		"File"->"file",
		"Blob"->"blob",
		"RemoveSection"->"remove-section",
		"RenameSection"->"rename-section",
		"Unset"->"unset",
		"UnsetAll"->"unset-all",
		"List"->"list",
		"Bool"->"bool",
		"Int"->"int",
		"BoolOrInt"->"bool-or-int",
		"Path"->"path",
		"Null"->"null",
		"NameOnly"->"name-only",
		"ShowOrigin"->"show-origin",
		"GetColorbool"->"get-colorbool",
		"GetColor"->"get-color",
		"Edit"->"edit",
		"Includes"->"includes",
		"NoIncludes"->"no-includes"
		},
	{
		"Global"->True
		}
	]


GitConfig[setting:_String:"--global",opts___String]:=
	GitRun["config",setting,opts];
GitConfig[setting:_String:"--global","Username"->name_]:=
	GitConfig[setting,"user.name",name];
GitConfig[setting:_String:"--global","UserEmail"->email_]:=
	GitConfig[setting,"user.email",email];
GitConfig[setting:_String:"--global","TextEditor"->editor_]:=
	GitConfig[setting,"core.editor",editor]
GitConfig[setting:_String:"--global",opts__Rule]:=
	StringJoin@
		Riffle[
			Cases[
				Table[
					GitConfig[setting,opt],
					{opt,{opts}}
					],
				_String
				],
			"\n"
			];


(* ::Subsubsection::Closed:: *)
(*GitDiff*)



GitRegisterFunction[GitDiff, 
	"diff",
	{
		"Patch"->"patch",
		"NoPatch"->"no-patch",
		"Unified"->"unified",
		"Raw"->"raw",
		"PatchWithRaw"->"patch-with-raw",
		"NoIndentHeuristic"->"no-indent-heuristic",
		"Minimal"->"minimal",
		"Patience"->"patience",
		"Histogram"->"histogram",
		"DiffAlgorithm"->"diff-algorithm",
		"Stat"->"stat",
		"Numstat"->"numstat",
		"Shortstat"->"shortstat",
		"Dirstat"->"dirstat",
		"Summary"->"summary",
		"PatchWithStat"->"patch-with-stat",
		"NULTerminated"->"z",
		"NameOnly"->"name-only",
		"NameStatus"->"name-status",
		"Submodule"->"submodule",
		"Color"->"color",
		"NoColor"->"no-color",
		"WordDiff"->"word-diff",
		"WordDiffRegex"->"word-diff-regex",
		"ColorWords"->"color-words",
		"NoRenames"->"no-renames",
		"Check"->"check",
		"WsErrorHighlight"->"ws-error-highlight",
		"FullIndex"->"full-index",
		"Binary"->"binary",
		"Abbrev"->"abbrev",
		"BreakRewrites"->"break-rewrites",
		"FindRenames"->"find-renames",
		"FindCopies"->"find-copies",
		"FindCopiesHarder"->"find-copies-harder",
		"IrreversibleDelete"->"irreversible-delete",
		"DiffFilter"->"diff-filter",
		"PickaxeAll"->"pickaxe-all",
		"PickaxeRegex"->"pickaxe-regex",
		"Recursive"->"R",
		"Relative"->"relative",
		"Text"->"text",
		"IgnoreSpaceAtEol"->"ignore-space-at-eol",
		"IgnoreSpaceChange"->"ignore-space-change",
		"IgnoreAllSpace"->"ignore-all-space",
		"IgnoreBlankLines"->"ignore-blank-lines",
		"InterHunkContext"->"inter-hunk-context",
		"FunctionContext"->"function-context",
		"ExitCode"->"exit-code",
		"Quiet"->"quiet",
		"ExtDiff"->"ext-diff",
		"NoExtDiff"->"no-ext-diff",
		"NoTextconv"->"no-textconv",
		"IgnoreSubmodules"->"ignore-submodules",
		"SrcPrefix"->"src-prefix",
		"DstPrefix"->"dst-prefix",
		"NoPrefix"->"no-prefix",
		"LinePrefix"->"line-prefix",
		"ItaInvisibleInIndex"->"ita-invisible-in-index"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitMerge*)



GitRegisterFunction[
	GitMerge, 
	"merge",
	{
		"NoCommit"->"no-commit",
		"NoEdit"->"no-edit",
		"FastForward"->"ff",
		"NoFastForward"->"no-ff",
		"FastForwardOnly"->"ff-only",
		"Log"->"log",
		"NoStat"->"no-stat",
		"NoSquash"->"no-squash",
		"Strategy"->"strategy",
		"StrategyOption"->"strategy-option",
		"NoVerifySignatures"->"no-verify-signatures",
		"NoSummary"->"no-summary",
		"Quiet"->"quiet",
		"Verbose"->"verbose",
		"NoProgress"->"no-progress",
		"AllowUnrelatedHistories"->"allow-unrelated-histories",
		"GpgSign"->"gpg-sign",
		"Message"->"m",
		"RerereAutoupdate"->"rerere-autoupdate",
		"NoRerereAutoupdate"->"no-rerere-autoupdate",
		"Abort"->"abort",
		"Continue"->"continue"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitMergeTool*)



GitRegisterFunction[
	GitMergeTool, 
	"mergetool",
	{
		"Tool"->"tool",
		"ToolHelp"->"tool-help",
		"NoPrompt"->"no-prompt",
		"Prompt"->"prompt"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitTag*)



GitRegisterFunction[
	GitTag, 
	"tag",
	{
		"Annotate"->"annotate",
		"Sign"->"sign",
		"LocalUser"->"local-user",
		"Force"->"force",
		"Delete"->"delete",
		"Verify"->"verify",
		"List"->"list",
		"Sort"->"sort",
		"IgnoreCase"->"ignore-case",
		"Column"->"column",
		"Contains"->"contains",
		"NoContains"->"no-contains",
		"Merged"->"merged",
		"NoMerged"->"no-merged",
		"PointsAt"->"points-at",
		"Message"->"message",
		"File"->"file",
		"Cleanup"->"cleanup",
		"CreateReflog"->"create-reflog"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitWorkTree*)



GitRegisterFunction[
	GitWorkTree, 
	"worktree",
	{
		"Force"->"force",
		"Branch"->"b",
		"Detach"->"detach",
		"Checkout"->"checkout",
		"NoCheckout"->"no-checkout",
		"Lock"->"lock",
		"DryRun"->"dry-run",
		"Porcelain"->"porcelain",
		"Verbose"->"verbose",
		"Expire"->"expire",
		"Reason"->"reason"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitSubmodule*)



GitRegisterFunction[
	GitSubmodule, 
	"submodule",
	{
		"Quiet"->"quiet",
		"All"->"all",
		"Branch"->"branch",
		"Force"->"force",
		"Cached"->"cached",
		"Files"->"files",
		"SummaryLimit"->"summary-limit",
		"Remote"->"remote",
		"NoFetch"->"no-fetch",
		"Checkout"->"checkout",
		"Merge"->"merge",
		"Rebase"->"rebase",
		"Init"->"init",
		"Name"->"name",
		"Reference"->"reference",
		"Recursive"->"recursive",
		"Depth"->"depth",
		"RecommendShallow"->"recommend-shallow",
		"NoRecommendShallow"->"no-recommend-shallow",
		"Jobs"->"jobs"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitShow*)



GitRegisterFunction[
	GitShow, 
	"show",
	{
		"Pretty"->"pretty",
		"AbbrevCommit"->"abbrev-commit",
		"NoAbbrevCommit"->"no-abbrev-commit",
		"Oneline"->"oneline",
		"Encoding"->"encoding",
		"ExpandTabs"->"expand-tabs",
		"Notes"->"notes",
		"NoNotes"->"no-notes",
		"ShowNotes"->"show-notes",
		"ShowSignature"->"show-signature"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitShortLog*)



GitRegisterFunction[
	GitShortLog, 
	"shortlog",
	{
		"Numbered"->"numbered",
		"Summary"->"summary",
		"Email"->"email",
		"Format"->"format",
		"Committer"->"committer",
		"Width"->"w"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitDescribe*)



GitRegisterFunction[
	GitDescribe, 
	"Describe",
	{
		"Broken"->"broken",
		"All"->"all",
		"Tags"->"tags",
		"Contains"->"contains",
		"Abbrev"->"abbrev",
		"Candidates"->"candidates",
		"ExactMatch"->"exact-match",
		"Debug"->"debug",
		"Long"->"long",
		"Match"->"match",
		"Exclude"->"exclude",
		"Always"->"always",
		"FirstParent"->"first-parent"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitApply*)



GitRegisterFunction[
	GitApply,
	{
		"Stat"->"stat",
		"Numstat"->"numstat",
		"Summary"->"summary",
		"Check"->"check",
		"Index"->"index",
		"Cached"->"cached",
		"BuildFakeAncestor"->"build-fake-ancestor",
		"Reverse"->"reverse",
		"Reject"->"reject",
		"Z"->"z",
		"UnidiffZero"->"unidiff-zero",
		"Apply"->"apply",
		"NoAdd"->"no-add",
		"AllowBinaryReplacement"->"allow-binary-replacement",
		"Exclude"->"exclude",
		"Include"->"include",
		"IgnoreSpaceChange"->"ignore-space-change",
		"Whitespace"->"whitespace",
		"InaccurateEof"->"inaccurate-eof",
		"Verbose"->"verbose",
		"Recount"->"recount",
		"Directory"->"directory",
		"UnsafePaths"->"unsafe-paths"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitRebase*)



GitRegisterFunction[
	GitRebase,
	{
		"Onto"->"onto",
		"Continue"->"continue",
		"Abort"->"abort",
		"Quit"->"quit",
		"KeepEmpty"->"keep-empty",
		"Skip"->"skip",
		"EditTodo"->"edit-todo",
		"Merge"->"merge",
		"Strategy"->"strategy",
		"StrategyOption"->"strategy-option",
		"GpgSign"->"gpg-sign",
		"Quiet"->"quiet",
		"Verbose"->"verbose",
		"Stat"->"stat",
		"NoStat"->"no-stat",
		"NoVerify"->"no-verify",
		"Verify"->"verify",
		"ForceRebase"->"force-rebase",
		"NoForkPoint"->"no-fork-point",
		"Whitespace"->"whitespace",
		"CommitterDateIsAuthorDate"->"committer-date-is-author-date",
		"Interactive"->"interactive",
		"Signoff"->"signoff",
		"PreserveMerges"->"preserve-merges",
		"Exec"->"exec",
		"Root"->"root",
		"NoAutosquash"->"no-autosquash",
		"NoAutostash"->"no-autostash",
		"NoFf"->"no-ff"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitRevert*)



GitRegisterFunction[
	GitRevert,
	{
		"Edit"->"edit",
		"Mainline"->"mainline",
		"NoEdit"->"no-edit",
		"NoCommit"->"no-commit",
		"GpgSign"->"gpg-sign",
		"Signoff"->"signoff",
		"Strategy"->"strategy",
		"StrategyOption"->"strategy-option"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitBisect*)



GitRegisterFunction[
	GitBisect,
	{
		"NoCheckout"->"no-checkout"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitBlame*)



GitRegisterFunction[
	GitBlame,
	{
		"ShowBlank"->"b",
		"Root"->"root",
		"ShowStats"->"show-stats",
		"Lines"->"L",
		"Log"->"l",
		"ShowTimestamps"->"t",
		"RevisionsFile"->"S",
		"Reverse"->"reverse",
		"Porcelain"->"porcelain",
		"LinePorcelain"->"line-porcelain",
		"Incremental"->"incremental",
		"Encoding"->"encoding",
		"Contents"->"contents",
		"Date"->"date",
		"Progress"->"progress",
		"NoProgress"->"no-progress",
		"DetectMoves"->"M",
		"DetectExternalMoves"->"C",
		"Help"->"h",
		"AnnotateOutput"->"c",
		"ScoreDebug"->"score-debug",
		"ShowName"->"show-name",
		"ShowNumber"->"show-number",
		"SuppressTimestamp"->"s",
		"ShowEmail"->"show-email",
		"IgnoreWhitespace"->"w",
		"Abbrev"->"abbrev",
		"NoIndentHeuristic"->"no-indent-heuristic"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitGrep*)



GitRegisterFunction[
	GitGrep,
	{
		"Cached"->"cached",
		"NoIndex"->"no-index",
		"Untracked"->"untracked",
		"NoExcludeStandard"->"no-exclude-standard",
		"ExcludeStandard"->"exclude-standard",
		"RecurseSubmodules"->"recurse-submodules",
		"ParentBasename"->"parent-basename",
		"Text"->"text",
		"Textconv"->"textconv",
		"NoTextconv"->"no-textconv",
		"IgnoreCase"->"ignore-case",
		"IgnoreBinary"->"I",
		"MaxDepth"->"max-depth",
		"WordRegexp"->"word-regexp",
		"InvertMatch"->"invert-match",
		"HideFilename"->"h",
		"FullName"->"full-name",
		"BasicRegexp"->"basic-regexp",
		"ExtendedRegexp"->"extended-regexp",
		"PerlRegexp"->"perl-regexp",
		"FixedStrings"->"fixed-strings",
		"LineNumber"->"line-number",
		"FilesWithoutMatch"->"files-without-match",
		"OpenFilesInPager"->"open-files-in-pager",
		"Null"->"null",
		"Count"->"count",
		"Color"->"color",
		"NoColor"->"no-color",
		"Break"->"break",
		"Heading"->"heading",
		"ShowFunction"->"show-function",
		"Context"->"context",
		"AfterContext"->"after-context",
		"BeforeContext"->"before-context",
		"FunctionContext"->"function-context",
		"Threads"->"threads",
		"File"->"f",
		"Pattern"->"e",
		"And"->"and",
		"AllMatch"->"all-match",
		"Quiet"->"quiet"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitInstaWeb*)



GitRegisterFunction[
	GitInstaWeb,
	{
		"Local"->"local",
		"HTTPDaemon"->"httpd",
		"ModulePath"->"module-path",
		"Port"->"port",
		"Browser"->"browser"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitArchive*)



GitRegisterFunction[
	GitArchive,
	{
		"Format"->"format",
		"List"->"list",
		"Verbose"->"verbose",
		"Prefix"->"prefix",
		"Output"->"output",
		"WorktreeAttributes"->"worktree-attributes",
		"Remote"->"remote",
		"Exec"->"exec"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitSVN*)



GitRegisterFunction[
	GitSVN,
	{
		"Shared"->"shared",
		"Template"->"template",
		"Revision"->"revision",
		"StandardIn"->"stdin",
		"Pretty"->"pretty",
		"RemoveDirector"->"rmdir",
		"Edit"->"edit",
		"FindCopiesHarder"->"find-copies-harder",
		"AuthorsFile"->"authors-file",
		"AuthorsProg"->"authors-prog",
		"Quiet"->"quiet",
		"Strategy"->"strategy",
		"DryRun"->"dry-run",
		"UseLogAuthor"->"use-log-author",
		"AddAuthorFrom"->"add-author-from"
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitBundle*)



GitRegisterFunction[
	GitBundle,
	{
		}
	];


(* ::Subsubsection::Closed:: *)
(*GitDaemon*)



GitRegisterFunction[
	GitDaemon,
	{
		"StrictPaths"->"strict-paths",
		"BasePath"->"base-path",
		"BasePathRelaxed"->"base-path-relaxed",
		"InterpolatedPath"->"interpolated-path",
		"ExportAll"->"export-all",
		"Inetd"->"inetd",
		"Listen"->"listen",
		"Port"->"port",
		"InitTimeout"->"init-timeout",
		"Timeout"->"timeout",
		"MaxConnections"->"max-connections",
		"Syslog"->"syslog",
		"UserPath"->"user-path",
		"Verbose"->"verbose",
		"Reuseaddr"->"reuseaddr",
		"Detach"->"detach",
		"PidFile"->"pid-file",
		"Group"->"group",
		"Disable"->"disable",
		"ForbidOverride"->"forbid-override",
		"InformativeErrors"->"informative-errors",
		"NoInformativeErrors"->"no-informative-errors",
		"AccessHook"->"access-hook"
		}
	];


(* ::Subsubsection::Closed:: *)
(*Repository finding and stuff*)



GitRepositories[
	dirs:{(_String?DirectoryQ)..}|_String?DirectoryQ,
	depth:_Integer|\[Infinity]:2
	]:=
	ParentDirectory/@FileNames[".git",dirs,depth];


(* ::Subsubsection::Closed:: *)
(*GitRepo*)



(*Options declared later*)
GitRepo[repo_String?(StringMatchQ["github:*"]),ops:OptionsPattern[]]:=
	GitHubRepo[StringTrim[repo,"github:"],{"Username"->"",ops}];
GitRepo[repo:(_String|_File)?DirectoryQ]:=
	Replace[
		GitRepositories[repo,1],{
		{d_,___}:>d,
		_:>None
		}];
GitRepo[r:_String|_URL]:=
	With[{u=URLParse@r},
		If[u["Scheme"]===None,
			If[u["Domain"]===None,
				If[Length@u["Path"]<2||!StringMatchQ[u["Path"]//First,"*.*"],
					None,
					URLBuild@Append[u,"Scheme"->"https"]
					],
				URLBuild@Append[u,"Scheme"->"https"]
				],
			URLBuild@u
			]
		];
GitRepo[r_]:=None;
GitRepoQ[r:(_String|_File)?DirectoryQ]:=
	(GitRepo@r=!=None);


(* ::Subsubsection::Closed:: *)
(*GitListRemotes*)



GitRegisterFunction[
	iGitRemoteShow,
	{"remote", "-v", "show"},
	{
		"UseCached"->"n"
		}
	];


GitListRemotes//Clear


Options[GitListRemotes]=
	Options[iGitRemoteShow];
GitListRemotes[
	dir:_String?DirectoryQ|Automatic:Automatic,
	remoteName:_String?((StringLength[#]==0||Not@DirectoryQ[#]&)):"origin",
	args___String,
	ops:OptionsPattern[]
	]:=
	iGitRemoteShow[dir, remoteName, args, ops]


(* ::Subsubsection::Closed:: *)
(*AddRemote*)



GitAddRemote//Clear


GitRegisterFunction[
	iGitRemoteAdd,
	{"remote", "add"},
	{
		"AutoFetch"->"f",
		"ImportTags"->"tags",
		"NoImportTags"->"no-tags",
		"TrackBranch"->{"t", " "},
		"Mirror"->"m"
		}
	];


Options[GitAddRemote]=
	Options[iGitRemoteAdd];
GitAddRemote[
	dir:_String?DirectoryQ|Automatic:Automatic,
	remoteName:_String?((StringLength[#]==0||Not@DirectoryQ[#]&)):"origin",
	remote:_String|_URL,
	ops:OptionsPattern[]
	]:=
	iGitRemoteAdd[dir,
		remoteName,
		URLBuild@remote,
		ops
		];


(* ::Subsubsection::Closed:: *)
(*RemoveRemote*)



GitRegisterFunction[
	iGitRemoteRemove,
	{"remote", "remove"},
	{
		}
	];


GitRemoveRemote[
	dir:_String?DirectoryQ|Automatic:Automatic,
	remoteName:_String?((StringLength[#]==0||Not@DirectoryQ[#]&)):"origin"
	]:=
	iGitRemoteRemove[dir, remoteName]


(* ::Subsubsection::Closed:: *)
(*GetRemoteURL*)



GitRegisterFunction[
	iGitRemoteGetURL,
	{"remote", "get-url"},
	{
		"PushURL"->"push",
		"AllURLs"->"all"
		}
	];
GitGetRemoteURL[
	dir:_String?DirectoryQ|Automatic:Automatic,
	remoteName:_String?((StringLength[#]==0||Not@DirectoryQ[#]&)):"origin",
	args___String,
	ops:OptionsPattern[]
	]:=
	iGitRemoteGetURL[dir, remoteName, args, ops]


(* ::Subsubsection::Closed:: *)
(*SetRemoteURL*)



GitRegisterFunction[
	iGitRemoteSetURL,
	{"remote", "set-url"},
	{
		"PushURL"->"push",
		"AllURLs"->"all",
		"AddURL"->"add",
		"DeleteURL"->"delete"
		}
	];
Options[GitSetRemoteURL]=
	Options[iGitRemoteSetURL];
GitSetRemoteURL[
	dir:_String?DirectoryQ|Automatic:Automatic,
	remoteName:_String?((StringLength[#]==0||Not@DirectoryQ[#]&)):"origin",
	args___String,
	ops:OptionsPattern[]
	]:=
	iGitRemoteSetURL[dir, remoteName, args, ops]


(* ::Subsubsection::Closed:: *)
(*GitSetRemote*)



GitSetRemote[
	dir:_String?DirectoryQ|Automatic:Automatic,
	remoteName:_String?((StringLength[#]==0||Not@DirectoryQ[#]&)):"origin",
	origin:(_String|_GitHubPath)?GitHubRepoQ
	]:=
	Quiet@
		Check[
			GitAddRemote[dir, remoteName, origin],
			GitRemoveRemote[dir, remoteName];
			GitAddRemote[dir, remoteName, origin]
			];


(* ::Subsubsection::Closed:: *)
(*GitRealignRemotes*)



GitRealignRemotes[
	dir:_String?DirectoryQ|Automatic:Automatic,
	remoteName:_String?(Not@*DirectoryQ):"origin",
	branchName:_String?(Not@*DirectoryQ):"master"
	]:=
	(
		Git["Fetch", dir];
		Git["Reset", dir, URLBuild@{remoteName, branchName}];
		Git["Checkout", dir, URLBuild@{remoteName, branchName}];
		)


(* ::Subsubsection::Closed:: *)
(*ReattachHead*)



GitReattachHead[
	dir:_String?DirectoryQ|Automatic:Automatic
	]:=
	With[{uuid=CreateUUID[]},
		Git["Branch", dir, uuid];
		Git["Checkout", dir, uuid];
		Git["Branch", dir, "-f", "master", uuid];
		Git["Checkout", dir, "master"];
		Git["Branch", dir, "-d", uuid];
		]


(* ::Subsubsection::Closed:: *)
(*Push*)



GitRegisterFunction[
	iGitPush,
	"push",
	{
		"All"->"all",
		"Prune"->"prune",
		"Mirror"->"mirror",
		"DryRun"->"dry-run",
		"Porcelain"->"porcelain",
		"Delete"->"delete",
		"Tags"->"tags",
		"FollowTags"->"follow-tags",
		"Sign"->"sign",
		"Atomic"->"atomic",
		"NoAtomic"->"no-atomic",
		"PushOption"->"push-option",
		"ReceivePack"->"receive-pack",
		"ForceWithLease"->"force-with-lease",
		"Force"->"force",
		"Repo"->"repo",
		"SetUpstream"->"set-upstream",
		"Thin"->"thin",
		"NoThin"->"no-thin",
		"Quiet"->"quiet",
		"Verbose"->"verbose",
		"Progress"->"progress",
		"RecurseSubmodules"->"recurse-submodules",
		"Verify"->"verify",
		"NoVerify"->"no-verify"
		}
	]


GitPush//Clear


Options[GitPush]=
	Join[
		{
			"Username"->
				None,
			"Password"->
				None
			},
		Options[iGitPush]
		];
GitPush[
	dir:_String?DirectoryQ,
	locs__String,
	ops:OptionsPattern[]
	]:=
	iGitPush[
		dir,
		ops,
		locs
		];


(* ::Subsubsection::Closed:: *)
(*Fetch*)



GitRegisterFunction[
	GitFetch,
	"fetch",
	{
		"All"->"all",
		"Append"->"append",
		"Depth"->"depth",
		"Deepen"->"deepen",
		"ShallowSince"->"shallow-since",
		"ShallowExclude"->"shallow-exclude",
		"Unshallow"->"unshallow",
		"UpdateShallow"->"update-shallow",
		"DryRun"->"dry-run",
		"Force"->"force",
		"Keep"->"keep",
		"Multiple"->"multiple",
		"Prune"->"prune",
		"NoTags"->"no-tags",
		"Refmap"->"refmap",
		"Tags"->"tags",
		"RecurseSubmodules"->"recurse-submodules",
		"Jobs"->"jobs",
		"NoRecurseSubmodules"->"no-recurse-submodules",
		"SubmodulePrefix"->"submodule-prefix",
		"RecurseSubmodulesDefault"->"recurse-submodules-default",
		"UpdateHeadOk"->"update-head-ok",
		"UploadPack"->"upload-pack",
		"Quiet"->"quiet",
		"Verbose"->"verbose",
		"Progress"->"progress"
		}
	]


(* ::Subsubsection::Closed:: *)
(*Reset*)



GitRegisterFunction[
	GitReset,
	"fetch",
	{
		"Patch"->"patch",
		"Soft"->"soft",
		"Mixed"->"mixed",
		"Hard"->"hard",
		"Merge"->"merge",
		"Keep"->"keep",
		"Verbose"->"verbose"
		}
	]


(* ::Subsubsection::Closed:: *)
(*Checkout*)



GitRegisterFunction[
	GitCheckout,
	"checkout",
	{
		"Quiet"->"q",
		"MakeBranch"->"b",
		"Track"->"t",
		"Progress"->"progress",
		"Force"->"f",
		"Ours"->"ours",
		"Theirs"->"theirs",
		"NoTrack"->"notrack",
		"Log"->"l",
		"Detach"->"Detach",
		"Orphan"->"orphan",
		"IgnoreSkipWorktreeBits"->
			"ignore-skip-worktree-bits",
		"Conflict"->"conflict",
		"Patch"->"p",
		"IgnoreOtherWorktrees"->"ignore-other-worktrees",
		"RecurseSubmodules"->"recurse-submodules"
		}
	];


(* ::Subsubsection::Closed:: *)
(*Pull*)



GitRegisterFunction[
	GitPull,
	"pull",
	{
		"Quiet"->"quiet",
		"Verbose"->"verbose",
		"RecurseSubmodules"->"recurse-submodules",
		"NoRecurseSubmodules"->"no-recurse-submodules",
		"NoCommit"->"no-commit",
		"NoEdit"->"no-edit",
		"FastForward"->"ff",
		"NoFastForward"->"no-ff",
		"FastForwardOnly"->"ff-only",
		"Log"->"log",
		"NoStat"->"no-stat",
		"NoSquash"->"no-squash",
		"Strategy"->"strategy",
		"StrategyOption"->"strategy-option",
		"NoVerifySignatures"->"no-verify-signatures",
		"NoSummary"->"no-summary",
		"AllowUnrelatedHistories"->"allow-unrelated-histories",
		"Rebase"->"rebase",
		"NoRebase"->"no-rebase",
		"NoAutostash"->"no-autostash",
		"All"->"all",
		"Append"->"append",
		"Depth"->"depth",
		"Deepen"->"deepen",
		"ShallowSince"->"shallow-since",
		"ShallowExclude"->"shallow-exclude",
		"Unshallow"->"unshallow",
		"UpdateShallow"->"update-shallow",
		"Force"->"force",
		"Keep"->"keep",
		"NoTags"->"no-tags",
		"UpdateHeadOk"->"update-head-ok",
		"UploadPack"->"upload-pack",
		"Progress"->"progress"
		}
	];


(* ::Subsubsection::Closed:: *)
(*PullOrigin*)



Options[GitPullOrigin]=
	Options[GitPull];
GitPullOrigin[
	dir:_String?DirectoryQ|Automatic:Automatic,
	args___String,
	ops:OptionsPattern[]
	]:=
	GitPull[dir, "origin", "master", args, ops]


(* ::Subsubsection::Closed:: *)
(*PushOrigin*)



Options[GitPushOrigin]=
	Options[GitPush];
GitPushOrigin[
	dir:_String?DirectoryQ|Automatic:Automatic,
	args___String,
	ops:OptionsPattern[]
	]:=
	GitPush[dir,
		"origin",
		"master",
		args,
		ops
		];


(* ::Subsubsection::Closed:: *)
(*GetPushURL*)



GitGetPushURL[
	dir:_String?DirectoryQ|Automatic:Automatic,
	rem:_String?(Not@*DirectoryQ):"origin"
	]:=
	With[
		{
			rems=
				#[[1]]->#[[2]]&/@
					Cases[
						Partition[
							Append[""]@
							StringSplit[
								Replace[
									Git["ListRemotes", dir],
									Except[_String]->""
									]
								],
							3
							],
						{_, _, _?(StringContainsQ["push"])}
						]//Association
			},
		If[Length@rems>0,
			rem->rems[rem],
			URL@GitHubPath[FileBaseName@Replace[dir, Automatic:>rem]]
			]
		]


(* ::Subsubsection::Closed:: *)
(*GetFetchURL*)



GetFetchURL//Clear


GitGetFetchURL[
	dir:_String?DirectoryQ|Automatic:Automatic,
	rem:_String?(Not@*DirectoryQ):"origin"
	]:=
	With[
		{
			rems=
				#[[1]]->#[[2]]&/@
					Cases[
						Partition[
							Append[""]@
							StringSplit[
								Replace[Git["ListRemotes", dir],
									Except[_String]->""
									]
								],
							3
							],
						{_, _, _?(StringContainsQ["fetch"])}
						]//Association
			},
		If[Length@rems>0,
			rem->rems[rem],
			URL@GitHubPath[FileBaseName@Replace[dir, Automatic:>rem]]
			]
		]


(* ::Subsubsection::Closed:: *)
(*ListTree*)



GitRegisterFunction[
	GitListTree,
	"ls-tree",
	{
		"NoChildren"->"d",
		"Recursive"->"r",
		"ShowRecursiveTrees"->"t",
		"Long"->"long",
		"NULTerminated"->"z",
		"NameStatus"->"name-status",
		"Abbrev"->"abbrev",
		"FullName"->"full-name",
		"FullTree"->"full-tree"
		}
	];


(* ::Subsubsection::Closed:: *)
(*ListTreeRecursive*)



Options[GitListTreeRecursive]=
	Options@GitListTree;
GitListTreeRecursive[
	dir:_String?DirectoryQ|Automatic:Automatic,
	args___String,
	ops:OptionsPattern[]
	]:=
	GitListTree[dir, args, "Recursive"->True, ops]


(* ::Subsubsection::Closed:: *)
(*RefLog*)



GitRegisterFunction[
	GitReflog,
	"reflog",
	{
		"All"->"all",
		"Expire"->"expire",
		"ExpireUnreachable"->"expire-unreachable",
		"Updateref"->"updateref",
		"Rewrite"->"rewrite",
		"StaleFix"->"stale-fix",
		"DryRun"->"dry-run",
		"Verbose"->"verbose"
		}
	]


(* ::Subsubsection::Closed:: *)
(*RefLogShow*)



GitRegisterFunction[
	RefLogShow,
	{"reflog", "show"},
	{
		"Follow"->"follow",
		"Decorate"->"decorate",
		"Source"->"source",
		"UseMailmap"->"use-mailmap",
		"FullDiff"->"full-diff",
		"LogSize"->"log-size",
		"TraceLines"->"L",
		"MaxCount"->"max-count",
		"Skip"->"skip",
		"Since"->"since",
		"Before"->"before",
		"Committer"->"committer",
		"GrepReflog"->"grep-reflog",
		"Grep"->"grep",
		"AllMatch"->"all-match",
		"InvertGrep"->"invert-grep",
		"RegexpIgnoreCase"->"regexp-ignore-case",
		"BasicRegexp"->"basic-regexp",
		"ExtendedRegexp"->"extended-regexp",
		"FixedStrings"->"fixed-strings",
		"PerlRegexp"->"perl-regexp",
		"RemoveEmpty"->"remove-empty",
		"Merges"->"merges",
		"NoMerges"->"no-merges",
		"MinParents"->"min-parents",
		"NoMaxParents"->"no-max-parents",
		"FirstParent"->"first-parent",
		"Bisect"->"bisect",
		"Not"->"not",
		"All"->"all",
		"Branches"->"branches",
		"Tags"->"tags",
		"Remotes"->"remotes",
		"Glob"->"glob",
		"Exclude"->"exclude",
		"Reflog"->"reflog",
		"IgnoreMissing"->"ignore-missing",
		"Stdin"->"stdin",
		"CherryMark"->"cherry-mark",
		"CherryPick"->"cherry-pick",
		"RightOnly"->"right-only",
		"Cherry"->"cherry",
		"WalkReflogs"->"walk-reflogs",
		"Merge"->"merge",
		"Boundary"->"boundary",
		"SimplifyByDecoration"->"simplify-by-decoration",
		"FullHistory"->"full-history",
		"Dense"->"dense",
		"Sparse"->"sparse",
		"SimplifyMerges"->"simplify-merges",
		"AncestryPath"->"ancestry-path",
		"DateOrder"->"date-order",
		"AuthorDateOrder"->"author-date-order",
		"TopoOrder"->"topo-order",
		"Reverse"->"reverse",
		"NoWalk"->"no-walk",
		"DoWalk"->"do-walk",
		"Pretty"->"pretty",
		"AbbrevCommit"->"abbrev-commit",
		"NoAbbrevCommit"->"no-abbrev-commit",
		"Oneline"->"oneline",
		"Encoding"->"encoding",
		"ExpandTabs"->"expand-tabs",
		"Notes"->"notes",
		"NoNotes"->"no-notes",
		"ShowNotes"->"show-notes",
		"ShowSignature"->"show-signature",
		"RelativeDate"->"relative-date",
		"Date"->"date",
		"Parents"->"parents",
		"Children"->"children",
		"LeftRight"->"left-right",
		"Graph"->"graph",
		"ShowLinearBreak"->"show-linear-break",
		"Compress"->"c",
		"CompressComplete"->"cc",
		"ShowMergeDiffs"->"m",
		"Recursive"->"r",
		"ShowTree"->"t"
		}
	]


(* ::Subsubsection::Closed:: *)
(*RefLogExpire*)



GitRegisterFunction[
	RefLogExpire,
	{"reflog", "expire"},
	{
		"All"->"all",
		"Expire"->"expire",
		"ExpireUnreachable"->"expire-unreachable",
		"Updateref"->"updateref",
		"Rewrite"->"rewrite",
		"StaleFix"->"stale-fix",
		"DryRun"->"dry-run",
		"Verbose"->"verbose"
		}
	]


(* ::Subsubsection::Closed:: *)
(*Clean*)



Options[GitClean]=
	{
		"reflogExpire"->Automatic,
		"reflogExpireUnreachable"->Automatic,
		"rerereresolved"->Automatic,
		"rerereunresolved"->Automatic,
		"pruneExpire"->Automatic
		}
GitClean[
	dir:_String?DirectoryQ|Automatic:Automatic,
	args___String,
	ops:OptionsPattern[]
	]:=
	With[
		{
			conf=
				Map[
					StringJoin@
						Prepend[Insert[List@@ToString/@#," ",2],"--gc."]&, 
					Flatten@{ops}
					]
				},
			GitRun[dir,"gc",args,Sequence@@conf]
		]


(* ::Subsubsection::Closed:: *)
(*GitCleanEverything*)



(*(* Taken from here: https://stackoverflow.com/a/14729486 *)
GitCleanEverything[
	dir:_String?DirectoryQ|Automatic:Automatic,
	args___
	]:=
	GitClean[dir,"\"$@\"",args,
		{
			"reflogExpire"\[Rule]0,
			"reflogExpireUnreachable"\[Rule]0,
			"rerereresolved"\[Rule]0,
			"rerereunresolved"\[Rule]0,
			"pruneExpire"\[Rule]"now"
			}
		]*)


(* ::Subsubsection::Closed:: *)
(*GitFilterBranch*)



GitFilterBranch//Clear


GitFilterBranch[
	dir:_String?DirectoryQ|Automatic:Automatic,
	filterType_String?(StringStartsQ["--"]),
	filterCMD_String,
	args___
	]:=
	GitRun[dir,"filter-branch",
		If[StringQ@branch,branch,Sequence@@{}],
		filterType, 
		"''``''"~TemplateApply~filterCMD,
		args
		];


(* ::Subsubsection::Closed:: *)
(*GitFilterTree*)



GitFilterTree//Clear


GitFilterTree[
	dir:_String?DirectoryQ|Automatic:Automatic,
	filterCMD_String,
	args___
	]:=
	GitFilterBranch[dir, "--tree-filter",filterCMD, args];


(* ::Subsubsection::Closed:: *)
(*Prune*)



GitRegisterFunction[
	GitPrune,
	"Prune",
	{
		"DryRun"->"dry-run",
		"Verbose"->"verbose",
		"Expire"->{"expire", " "}
		}
	];


(* ::Subsubsection::Closed:: *)
(*Branch*)



GitRegisterFunction[
	GitBranch,
	"Branch",
	{
			"Delete"->"delete",
			"ForceDelete"->"D",
			"CreateReflog"->"create-reflog",
			"Force"->"force",
			"Move"->"move",
			"ForceMOve"->"M",
			"Color"->"color",
			"NoColor"->"no-color",
			"IgnoreCase"->"ignore-case",
			"NoColumn"->"no-column",
			"Remotes"->"remotes",
			"All"->"all",
			"List"->"list",
			"Verbose"->"verbose",
			"Quiet"->"quiet",
			"Abbrev"->"abbrev",
			"NoAbbrev"->"no-abbrev",
			"Track"->"track",
			"NoTrack"->"no-track",
			"SetUpstream"->"set-upstream",
			"SetUpstreamTo"->"set-upstream-to",
			"UnsetUpstream"->"unset-upstream",
			"EditDescription"->"edit-description",
			"Contains"->"contains",
			"NoContains"->"no-contains",
			"Merged"->"merged",
			"NoMerged"->"no-merged",
			"Sort"->"sort",
			"PointsAt"->"points-at",
			"Format"->"format"
			}
		]


(* ::Subsubsection::Closed:: *)
(*ShowBranch*)



GitRegisterFunction[
	GitShowBranch,
	"show-branch",
	{
		"Remotes"->"remotes",
		"All"->"all",
		"Current"->"current",
		"TopoOrder"->"topo-order",
		"DateOrder"->"date-order",
		"Sparse"->"sparse",
		"More"->"more",
		"List"->"list",
		"MergeBase"->"merge-base",
		"Independent"->"independent",
		"NoName"->"no-name",
		"Sha1Name"->"sha1-name",
		"Topics"->"topics",
		"Reflog"->"reflog",
		"Color"->"color",
		"NoColor"->"no-color"
		}
	];


(* ::Subsubsection::Closed:: *)
(*ListBranches*)



splitGitBranches[bstring_]:=
	StringCases[
		bstring,
		(" "|StartOfString)~~name:WordCharacter..:>name
		]


Options[GitListBranches]=
	Options[GitBranch];
GitListBranches[
	dir:_String?DirectoryQ|Automatic:Automatic,
	o___?OptionQ
	]:=
	splitGitBranches@GitBranch[dir]


(* ::Subsubsection::Closed:: *)
(*CurrentBranch*)



getGitCurrentBranch[bstring_]:=
	First@StringCases[
		bstring,
		"* "~~name:Except[WhitespaceCharacter]..:>name
		]


Options[GitCurrentBranch]=
	Options[GitBranch];
GitCurrentBranch[
	dir:_String?DirectoryQ|Automatic:Automatic,
	o___?OptionQ
	]:=
	getGitCurrentBranch@
		GitBranch[dir]


(* ::Subsubsection::Closed:: *)
(*ListWithCurrentBranch*)



Options[GitListWithCurrentBranch]=
	Options[GitBranch];
GitListWithCurrentBranch[
	dir:_String?DirectoryQ|Automatic:Automatic,
	o___?OptionQ
	]:=
	With[{brs=GitBranch[dir]},
		With[
			{curr=
				getGitCurrentBranch@brs
				},
			Prepend[curr]@
				DeleteCases[
					splitGitBranches@brs,
					curr
					]
			]
		]


(* ::Subsubsection::Closed:: *)
(*SwitchBranch*)



Options[GitSwitchBranch]=
	Options[GitCheckout];
GitSwitchBranch[
	dir:_String?DirectoryQ|Automatic:Automatic,
	newBranch_String,
	o___?OptionQ
	]:=
	With[{bb=GitListWithCurrentBranch[dir]},
		Which[
			newBranch===First@bb,
				bb,
			MemberQ[bb, newBranch],
				GitCheckout[dir, newBranch];
				newBranch,
			True,
				GitCheckout[dir, "MakeBranch"->newBranch];
				newBranch
			]
		]


(* ::Subsubsection::Closed:: *)
(*WipeTheSlate*)



GitWipeTheSlate//Clear


(* Take from here: https://stackoverflow.com/a/26000395 *)
GitWipeTheSlate[
	dir:_String?DirectoryQ|Automatic:Automatic
	]:=
	(
		GitCheckout[dir, "--orphan", "latest_branch"];
		GitAdd[dir, "-A"];
		GitCommit[dir, "-a",
			Message->"Wiped the slate clean"
			];
		GitBranch[dir, "-D", "master"];
		GitBranch[dir, "-m", "master"];
		)


(* ::Subsubsection::Closed:: *)
(*Help*)



GitHelp[cmd_String]:=
	With[{s=GitRun["help", cmd]},
		StringReplace[s, 
			{
				(* There are sneaky \\.08 chars in here! Beware! *)
				l:(a:WordCharacter~~"\.08"~~a_):>
					a,
				l:(Repeated["_\.08"~~Except[WhitespaceCharacter]]):>
					StringJoin@StringTake[l, List/@Range[3, StringLength[l], 3]]
				}
			]
		]


GitHelpPart[cmd_, delim1_, delim2_]:=
	With[{h=GitHelp[cmd]},
		Replace[
			StringCases[h, 
				Shortest[delim1~~t__~~delim2]:>
				With[{ws=
						MinimalBy[
							StringCases[t, (StartOfString|StartOfLine)~~Except["\n", Whitespace]], 
							StringLength
							]},
					StringDelete[t,
						(StartOfString|StartOfLine)~~Apply[Alternatives, ws]
						]
					]
				],
			{
				l:{s_, ___}:>
					StringTrim@s,
				_->None
				}
			]
		]


(* ::Subsubsection::Closed:: *)
(*Synopsis*)



GitHelpSynopsis[cmd_String]:=
	GitHelpPart[cmd, "SYNOPSIS", "DESCRIPTION"]


(* ::Subsubsection::Closed:: *)
(*Description*)



GitHelpDescription[cmd_String]:=
	GitHelpPart[cmd, "DESCRIPTION", "OPTIONS"]


(* ::Subsubsection::Closed:: *)
(*Options*)



GitHelpOptions[cmd_String]:=
	GitHelpPart[cmd, "OPTIONS", 
		("\n"~~Except[WhitespaceCharacter])|EndOfString
		]


(* ::Subsubsection::Closed:: *)
(*Flags*)



GitHelpFlags[cmd_String]:=
	StringTrim@
		StringCases[
			GitHelpOptions[cmd],
			Shortest[StartOfLine~~(Whitespace|"")~~"-"~~__~~EndOfLine]
			]


(* ::Subsubsection::Closed:: *)
(*FlagMap*)



GitHelpFlagMap[cmd_]:=
	StringTrim[
		StringSplit[
			Map[
				If[StringContainsQ[#, "--["],
					Sequence@@{
						StringReplace[#, Shortest["--["~~__~~"]"]:>"--"],
						StringReplace[#, Shortest["--["~~t__~~"]"]:>"--"<>t]
						},
					#
					]&,
				Flatten@
				Map[
					Take[
						MaximalBy[
							Select[
								StringTrim@#, 
								StringStartsQ[
									Repeated["-", {1, 2}]~~
										Except["-"]
									]
								], 
							StringLength
							],
						UpTo[1]
						]&,
					StringSplit[GitHelpFlags[cmd], ","]
					]
				],
			"["|" "|"="
			]//Map[First],
		"-"..|Whitespace
		]//DeleteDuplicates//
			Select[
				StringStartsQ[#, LetterCharacter]&&
				StringEndsQ[#, LetterCharacter]&
				]//Map[
					StringReplace[ToUpperCase[StringTake[#, 1]]<>StringDrop[#, 1],
						"-"~~s_:>ToUpperCase[s]
						]->#&
					]


(* ::Subsubsection::Closed:: *)
(*Git*)



$GitActions=
	KeySort@
	<|
		"Repo"->
			GitRepo,
		"RepoQ"->
			GitRepoQ,
		"Create"->
			GitCreate,
		"Init"->
			GitInit,
		"Clone"->
			GitClone,
		"AddGitIgnore"->
			GitAddGitIgnore,
		"AddGitExclude"->
			GitAddGitExclude,
		"Add"->
			GitAdd,
		"Move"->
			GitMove,
		"Remove"->
			GitRemove,
		"RemoveCached"->
			GitRemoveCached,
		"RemoveRecursive"->
			GitRemoveRecursive,
		"RemoveCachedRecursive"->
			GitRemoveCachedRecursive,
		"Commit"->
			GitCommit,
		"Branch"->
			GitBranch,
		"ShowBranch"->
			GitShowBranch,
		"ListBranches"->
			GitListBranches,
		"CurrentBranch"->
			GitCurrentBranch,
		"SwitchBranch"->
			GitSwitchBranch,
		"ListRemotes"->
			GitListRemotes,
		"AddRemote"->
			GitAddRemote,
		"RemoveRemote"->
			GitRemoveRemote,
		"GetRemoteURL"->
			GitGetRemoteURL,
		"SetRemoteURL"->
			GitSetRemoteURL,
		"RealignRemotes"->
			GitRealignRemotes,
		"ReattachHead"->
			GitReattachHead,
		"Fetch"->
			GitFetch,
		"Reset"->
			GitReset,
		"Checkout"->
			GitCheckout,
		"Prune"->
			GitPrune,
		"Pull"->
			GitPull,
		"PullOrigin"->
			GitPullOrigin,
		"Push"->
			GitPush,
		"PushOrigin"->
			GitPushOrigin,(*
		"GetPushURL"->
			GitGetPushURL,
		"GetFetchURL"->
			GitGetFetchURL,*)
		"Repositories"->
			GitRepositories,
		"Log"->
			GitLog,
		"LogDataset"->
			GitLogDataset,
		"FileHistory"->
			GitFileHistory,
		"Status"->
			GitStatus,
		"ListTree"->
			GitListTree,
		"ListTreeRecursive"->
			GitListTreeRecursive,
		"RefLog"->
			GitRefLog,
		"RefLogExpire"->
			GitRefLogExpire,
		"Clean"->
			GitClean,
		"WipeTheSlate"->
			GitWipeTheSlate,
		"FilterBranch"->
			GitFilterBranch,
		"FilterTree"->
			GitFilterTree,
		"Config"->
			GitConfig,
		"Diff"->
			GitDiff,
		"Merge"->
			GitMerge,
		"MergeTool"->
			GitMergeTool,
		"Tag"->
			GitTag,
		"WorkTree"->
			GitWorkTree,
		"Submodule"->
			GitSubmodule,
		"Show"->
			GitShow,
		"ShortLog"->
			GitShortLog,
		"Describe"->
			GitDescribe,
		"Apply"->
			GitApply,
		"Rebse"->
			GitRebase,
		"Revert"->
			GitRevert,
		"Bisect"->
			GitBisect,
		"Blame"->
			GitBlame,
		"Grep"->
			GitGrep,
		"InstaWeb"->
			GitInstaWeb,
		"Archive"->
			GitArchive,
		"SVN"->
			GitSVN,
		"Bundle"->
			GitBundle,
		"Daemon"->
			GitDaemon,
		"Help"->
			GitHelp,
		"HelpSynopsis"->
			GitHelpSynopsis,
		"HelpDescription"->
			GitHelpDescription,
		"HelpOptions"->
			GitHelpOptions,
		"HelpFlags"->
			GitHelpFlags,
		"HelpFlagMap"->
			GitHelpFlagMap
		|>;


$gitactions:=
	KeyMap[ToLowerCase]@$GitActions;


PackageAddAutocompletions[
	"Git",
	{
		Keys@$GitActions,
		{"Options", "Function"}
		}
	]


Git//Clear


$GitParamMap["Git"]=
	{
		"GitVersion"->"version",
		"GitHelp"->"help",
		"GitCallFrom"->"C",
		"GitConfig"->"c",
		"GitExecPath"->"exec-path",
		"GitHTMLPath"->"html-path",
		"GitManPath"->"man-path",
		"GitInfoPath"->"info-path",
		"GitPaginate"->"paginate",
		"GitNoPager"->"no-pager",
		"GitDir"->"git-dir",
		"GitWorkTree"->"work-tree",
		"GitNamespace"->"namespace",
		"GitSuperPrefix"->"super-prefix",
		"GitBare"->"bare",
		"GitNoReplaceObjects"->"no-replace-objects",
		"GitLiteralPathSpecs"->"literal-pathspecs",
		"GitGlobalPathSpecs"->"glob-pathspecs",
		"GitNoglobPathSpecs"->"noglob-pathspecs",
		"GitIcasePathSpecs"->"icase-pathspecs"
		};


Git[
	command_?(KeyMemberQ[$gitactions,ToLowerCase@#]&),
	"Options"
	]:=
	Options@$gitactions[ToLowerCase[command]];
Git[
	command_?(KeyMemberQ[$gitactions,ToLowerCase@#]&),
	"Function"
	]:=
	$gitactions[ToLowerCase[command]];
Options[Git]=
	Thread[Keys@$GitParamMap["Git"]->Automatic];
Git[
	command_?(KeyMemberQ[$gitactions,ToLowerCase@#]&),
	args___
	]:=
	Block[
		{
			$GitBaseOptionArgs=
				GitPrepParams[
					Git,
					FilterRules[Select[{args}, OptionQ], Options[Git]],
					$GitParamMap["Git"]
					],
			argNew=Sequence@@DeleteCases[{args}, Apply[Alternatives, Options[Git]]->_]
			},
		With[{cmd=$gitactions[ToLowerCase[command]]},
			With[{r=cmd[argNew]},
				r/;Head[r]=!=cmd
				]
			]
		];
Git::badcmd=
	"Couldn't execute command `` with parameters ``";
Git[
	cmd_String,
	args___
	]:=
	Block[
		{
			$GitBaseOptionArgs=
				GitPrepParams[
					Git,
					FilterRules[Select[{args}, OptionQ], Options[Git]],
					$GitParamMap["Git"]
					],
			argNew=Sequence@@DeleteCases[{args}, Apply[Alternatives, Options[Git]]->_]
			},
		With[{r=GitRun[cmd, argNew]},
			If[Head[r]===GitRun,
				Message[Git::badcmd, cmd, {args}]
				];
			r/;Head[r]=!=GitRun
			]
		];


(* ::Subsection:: *)
(*SVN*)



(* ::Subsubsection::Closed:: *)
(*Run*)



Options[SVNRun]=
	Normal@Merge[{
		Options@processRunDupe,
		"TrustServer"->False
		},
		First
		];
SVNRun[cmd_,
	kwargs:(_Rule|_RuleDelayed|_String)...,
	repo_String,
	others:(_Rule|_RuleDelayed|_String)...,
	ops:OptionsPattern[]]:=
	processRunDupe[
		{
			"svn",
			cmd,
			kwargs,
			If[OptionValue@"TrustServer","--trust-server-cert",Nothing],
			If[FileExistsQ@repo,ExpandFileName@repo,repo],
			others
			},
		Evaluate[
			Sequence@@
			FilterRules[{ops},
					Options@processRunDupe
					]
			]
		];


(* ::Subsubsection::Closed:: *)
(*FileNames*)



Options[SVNFileNames]=
	Options@SVNRun;
SVNFileNames[repo_,ops:OptionsPattern[]]:=
	Replace[SVNRun["ls",repo,ops],
		fn_String:>
			With[{lines=StringSplit[fn,"\n"]},
				If[FileExistsQ@repo,
					FileNameJoin@{repo,#}&/@lines,
					URLBuild@{repo,#}&/@lines
					] 
				]
		];


(* ::Subsubsection::Closed:: *)
(*CheckOut*)



Options[SVNCheckOut]=
	Options@SVNRun;
SVNCheckOut[
	repo_,
	dir:_String|Automatic:Automatic,
	ops:OptionsPattern[]]:=
	With[{pulldir=
		Replace[dir,{
			s_String?(Not@*FileExistsQ):>
				(If[FileExtension@s=="",
					CreateDirectory@s
					];
					s),
			Automatic:>
				With[{d=FileNameJoin@{$TemporaryDirectory,FileNameTake@repo}},
					If[FileExtension@d=="",
						Quiet@DeleteDirectory[d,DeleteContents->True];
						CreateDirectory@d
						];
					d
					]
			}]},
	SVNRun["checkout",
		repo,
		ExpandFileName@pulldir,
		ops
		];
	pulldir
	]


(* ::Subsubsection::Closed:: *)
(*Export*)



Options[SVNExport]=
	Normal@Merge[{
		Options@SVNRun,
		OverwriteTarget->False
		},
		Last];
SVNExport[repo_,file:_String|Automatic:Automatic,ops:OptionsPattern[]]:=
	With[{f=
		Replace[file,{
				Automatic:>
					FileNameJoin@{$TemporaryDirectory,FileNameTake@repo}
				}]},
		If[OptionValue@OverwriteTarget,Quiet@DeleteFile@f];
		SVNRun["export",
			repo,
			ExpandFileName@f,
			FilterRules[{ops},Options@SVNRun]
			];
		f
		]


(* ::Subsubsection::Closed:: *)
(*SVN*)



$SVNActions=
	<|
		"FileNames"->
			SVNFileNames,
		"CheckOut"->
			SVNCheckOut,
		"Export"->
			SVNExport
		|>;


$svnactions:=
	KeyMap[ToLowerCase]@$SVNActions


PackageAddAutocompletions[
	"SVN",
	{
		Keys[$SVNActions]
		}
	]


SVN[
	command_?(KeyMemberQ[$svnactions,ToLowerCase@#]&),
	args___
	]:=
	With[{cmd=$svnactions[ToLowerCase[command]]},
		With[{r=cmd[args]},
			r/;Head[r]=!=cmd
			]
		];
SVN[
	cmd_String,
	args___
	]:=
	SVNRun[cmd,args];


(* ::Subsection:: *)
(*GitHub*)



If[Length@OwnValues[$GitHubUseKeychain]==0,
	$GitHubUseKeychain:=
		TrueQ@Lookup[$GitHubConfig, "UseKeychain", False]
	];


(* ::Subsubsection::Closed:: *)
(*$GitHubConfig*)



If[Not@ValueQ@$GitHubConfig,
	$GitHubConfig:=
		Replace[
			Do[
				With[{f=PackageFilePath["Private", "Config", d]},
					If[FileExistsQ@f,
						Return[
							$GitHubConfig=
								Replace[Quiet@Import@f,
									{ 
										o_?OptionQ:>Association@o,
										_-><||>
										}
									]
								];
						Break[]
						]
					],
				{d,
					{
						"GitHubConfig.m",
						"GitHubConfig.wl"
						}
					}
				],
			Null-><||>
			]
	]


(* ::Subsubsection::Closed:: *)
(*$GitHubUsername*)



If[Length[OwnValues@$GitHubUsername]===0,
	$GitHubUsername:=
		Replace[
			If[$GitHubUseKeychain, $Keychain["$GitHubUsername"], None],
			Except[_String]:>
				$GitHubConfig["Username"]
			]
	];


(* ::Subsubsection::Closed:: *)
(*$GitHubEncodePassword*)



$GitHubEncodePassword:=
	TrueQ@$GitHubConfig["EncodePassword"];


(* ::Subsubsection::Closed:: *)
(*$GitHubPassword*)



$GitHubStorePassword:=
	Lookup[$GitHubConfig, "StorePassword", False]


GitHubPassword[s_String]:=
	With[
		{
			base=
				Replace[gitHubPasswordCache[s],
					Except[_String]:>KeychainGet[{"github.com",	s}, False]
					]
			},
		If[StringQ@base,
			base,
			If[$GitHubStorePassword,
				KeychainGet[{"github.com",	s}, True],
				AuthDialog[
					Dynamic@$ghauth,
					"",
					None,
					{{"github.com",Automatic},s}
					];
				If[AssociationQ[$ghauth]&&StringQ@$ghauth["github.com"][[2]],
					gitHubPasswordCache[s]=
						$ghauth["github.com"][[2]],
					gitHubPasswordCache[s]=None
					];
				Clear@$ghauth;
				gitHubPasswordCache[s]
				]
			]
		];
GitHubPassword[Optional[Automatic,Automatic]]:=
	GitHubPassword[$GitHubUsername];
Clear@$GitHubPassword;
$GitHubPassword:=
	GitHubPassword[Automatic];


(*If[ValueQ@$GitHubUsername&&!KeyMemberQ[$gitHubPassCache,$GitHubUsername],
	$gitHubPassCache[$GitHubUsername]:=
		Do[
			With[{f=
				FileNameJoin@{
					$PackageDirectory,
					"Private",
					d}
				},
				If[FileExistsQ@f,
					Replace[Import@f,
						s_String:>
							($gitHubPassCache[$GitHubUsername]=s);
						];
					Return[True]
					]
				],
			{d,
				{
					"GitHubPassword.m",
					"GitHubPassword.wl"
					}
				}
			]
	];*)


(* ::Subsubsection::Closed:: *)
(*$GitHubSSHConnected*)



$GitHubSSHConnected:=
	($GitHubSSHConnected=
		Quiet[processRunDupe[{"ssh","-T","git@github.com"}];
			Length@$MessageList===0
			]
		);


(* ::Subsubsection::Closed:: *)
(*GitHubPath*)



ClearAll[GitHubPath, FormatGitHubPath]


Options[GitHubPath]=
	{
		"Username"->Automatic,
		"Password"->None,
		"Branch"->"master",
		"Tree"->"tree"
		};
Options[FormatGitHubPath]=
	Options[GitHubPath];
FormatGitHubPath[path___String,ops:OptionsPattern[]]:=
	URLBuild@<|
		"Scheme"->
			"https",
		"Domain"->
			"github.com",
		If[$GitHubEncodePassword||
			MatchQ[OptionValue@"Password",_String|Automatic],
			"Username"->
				Replace[OptionValue["Username"],
					{
						Automatic:>
							Replace[OptionValue@"Password",
								Automatic|_String:>$GitHubUsername
								],
						Except[_String]->None
						}
					],
			Nothing
			],
		If[$GitHubEncodePassword||
			MatchQ[OptionValue@"Password",_String|Automatic],
			"Password"->
				Replace[
					Replace[OptionValue["Username"],{
						Automatic:>$GitHubUsername,
						Except[_String]->None
						}],
					s_String:>
						Replace[OptionValue["Password"],
							Automatic:>GitHubPassword[s]
							]
					],
			Nothing
			],
		"Path"->
			{
				Replace[OptionValue@"Username",
					Automatic:>$GitHubUsername
					],
				If[Length@{path}>1,
					Sequence@@Flatten@
						Insert[{path}, 
							{OptionValue["Tree"], OptionValue["Branch"]}, 
							2
							],
					Sequence@@{path}
					]
				}
		|>;
GitHubPath[repo_String, 
	t:"tree"|"raw"|"trunk", 
	branch_String, 
	p___String, 
	ops:OptionsPattern[]
	]:=
	GitHubPath[repo,
		If[t==="trunk", branch, Sequence@@{}],
		p, 
		"Branch"->If[t==="trunk", Nothing, branch],
		"Tree"->t,
		ops
		];
GitHubPath[path___String,ops:OptionsPattern[]]/;(TrueQ@$GitHubPathFormat):=
	FormatGitHubPath[path,ops];
GitHubPath[
	s_String?(
		(
			URLParse[#, "Scheme"]===None&&
				URLParse[#, "Domain"]===None&&
				Length@URLParse[#, "Path"]>1
			)||
		URLParse[#, "Scheme"]==="github"&
		),
	o:OptionsPattern[]
	]:=
	GitHubPathParse[
		If[URLParse[s, "Scheme"]===None&&URLParse[s, "Domain"]===None,
			"github:"<>s,
			s
			],
		o
		];
GitHubPath[URL[s_String], ops:OptionsPattern[]]:=GitHubPath[s, ops];
GitHubPath[GitHubPath[p___String, o___?OptionQ], op:OptionsPattern[]]:=
	GitHubPath[p, Sequence@@DeleteDuplicatesBy[Flatten@{op, o}, First]]


GitHubPath/:
	Normal[GitHubPath[repos___,ops___?OptionQ]]:=
		{
			FirstCase[{ops},
				("Username"->u_):>u,
				$GitHubUsername
				],
			repos
			};
GitHubPath/:
	URL[GitHubPath[path___String,ops:OptionsPattern[]]]:=
		FormatGitHubPath[path,ops]


Format[g:GitHubPath[path___String,ops:OptionsPattern[]]]:=
	RawBoxes@
		BoxForm`ArrangeSummaryBox[
			"GitHubPath",
			g,
			None,
			{
				BoxForm`MakeSummaryItem[{"Path: ", URLBuild[{path}]}, StandardForm],
				BoxForm`MakeSummaryItem[
					{"URL: ", 
						Hyperlink[FormatGitHubPath@@g]
						}, StandardForm]
				},
			Map[
				BoxForm`MakeSummaryItem[
					{
						Row@{#[[1]], ": "}, #[[2]]
						},
					StandardForm
					]&,
				Flatten[Normal/@{ops}]
				],
			StandardForm
			]


(* ::Subsubsection::Closed:: *)
(*GitHubPathQ*)



GitHubPathQ[path:_String|_URL]:=
	With[{p=URLParse[path]},
		(
			(MatchQ[p["Scheme"],"http"|"https"|None]&&p["Domain"]==="github.com")||
			p["Scheme"]==="github"&&p["Domain"]===None
			)
			&&
		Length@p["Path"]>0
		];
GitHubPathQ[_GitHubPath]:=
	True;


(* ::Subsubsection::Closed:: *)
(*GitHubPathParse*)



Options[GitHubPathParse]=
	Options[GitHubPath];
GitHubPathParse[path:_String|_URL, o:OptionsPattern[]]:=
	If[GitHubPathQ[path],
		Replace[
			DeleteCases[""]@
				URLParse[path,"Path"],
			{
				{user_,parts___}:>
					GitHubPath[parts,"Username"->user, o]
				}
			],
		$Failed
		];


(* ::Subsubsection::Closed:: *)
(*GitHubRepoParse*)



GitHubRepoParse[path:_String|_URL]:=
	If[GitHubPathQ[path],
		Replace[
			DeleteCases[""]@
				URLParse[path,"Path"],{
			{"repos",user_,parts__}|
			{user_,parts__,"releases"|"deployments"}|
			{user_,parts__,"releases"|"deployments","tag",___}:>
				GitHubPath[parts,"Username"->user]
			}],
		$Failed
		];


(* ::Subsubsection::Closed:: *)
(*GitHubRepoQ*)



iGitHubRepoQ[path:_String|_URL]:=
	GitHubPathQ[path]&&
	With[{p=URLParse[path]},
		!MatchQ[p["Path"],
			{"repos",__}|
			{__,"releases"|"deployments"}|
			{__,"releases"|"deployments","tag",___}
			]
		];
GitHubRepoQ[p:GitHubPath[___String,___?OptionQ]]:=
	iGitHubRepoQ[URL@p]
GitHubRepoQ[path:_String|_URL]:=
	GitHubRepoQ[GitHubPath@path];
GitHubRepoQ[_]:=False


(* ::Subsubsection::Closed:: *)
(*GitHubReleaseQ*)



GitHubReleaseQ[GitHubPath[p__String,___?OptionQ]]:=
	MatchQ[{p},
		{__,"releases"}|
		{__,"releases","tag",_}
		];
GitHubReleaseQ[path:_String|_URL]:=
	If[GitHubPathQ@path,
		Replace[GitHubPathParse[path],{
			g_GitHubPath:>
				GitHubReleaseQ@g,
			_->False
			}],
		False
		];


(* ::Subsubsection::Closed:: *)
(*GitHubQuery*)



GitHubQuery[
	path:_?(MatchQ[Flatten@{#},{___String}]&):{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>]:=
	Block[
		{
			$GitHubUsername=$GitHubUsername,
			$GitHubPassword=$GitHubPassword
			},
		Catch@
			HTTPRequest[
				URLBuild@<|
					"Scheme"->"https",
					"Domain"->"api.github.com",
					"Path"->Flatten@{path},
					"Query"->{query}
					|>,
				Association@Normal@
					ReplacePart[headers,
						{
							"Headers":>
								ReplaceAll[headers["Headers"],
									{
										("Authorization"->Automatic):>
											("Authorization"->GitHubAuthHeader[] ),
										("Authorization"->{u__}):>
											("Authorization"->GitHubAuthHeader[u])
										}
									],
							"Username":>
								Replace[
									headers["Username"],
									Automatic:>
										Replace[$GitHubUsername,
											Except[_String?(StringLength[#]>0&)]:>
												GitHubSetUsernameAndPassword[
													Automatic, 
													Lookup[headers, "Password", $GitHubPassword]
													]
											]
									],
							"Password":>
								Replace[
									headers["Password"],
									Automatic:>
										Replace[$GitHubPassword,
											Except[_String?(StringLength[#]>0&)]:>
												GitHubSetUsernameAndPassword[
													Lookup[headers, "Username", $GitHubPassword], 
													Automatic
													]
											]
									]
							}
						]
				]
			];


(* ::Subsubsection::Closed:: *)
(*GitHubQueryParamFilter*)



$GitHubParamMap=<||>;


GitHubQueryParamFilter[s_Symbol, ops_?OptionQ]:=
	With[{kd=Dispatch[$GitHubParamMap[s]]},
		Replace[
			FilterRules[
				Flatten@{
					ops,
					Options[s]
					},
				Keys[$GitHubParamMap[s]]
				],
			{
				(k_->v:_String|_?NumberQ|True|False):>
					Replace[k, kd]->v,
				_->Nothing
				},
			1
			]
		]


(* ::Subsubsection::Closed:: *)
(*Auth*)



(*GitHubAuth[
	user:_String|Automatic:Automatic,
	scopes:_String|{__String}:{"public_repo"}]:=
	GitHubQuery[
		Replace[user,Automatic:>$GitHubUsername],
		<|
			"Headers"\[Rule]{
				"Authorization"\[Rule]"token OAUTH-TOKEN",
				"
				}
			|>
		];*)


(* ::Subsubsection::Closed:: *)
(*AuthHeader*)



GitHubGetUsernameAndPassword[u_, p_]:=
	Block[
		{
			username=Replace[u, Automatic:>$GitHubUsername], 
			password=Replace[u, Automatic:>$GitHubPassword]
			},
		If[
			Not[
				StringQ@username&&StringQ@password&&
				StringLength[username]>0&&StringLength[password]>0
				],
			If[StringQ@username&&$GitHubUseKeychain,
				password=
					KeychainGet[{"github.com", username}]
				]
			];
		If[
			Not[
				StringQ@username&&StringQ@password&&
				StringLength[username]>0&&StringLength[password]>0
				],
				Replace[
					AuthDialog[
						{
							"GitHub", 
							If[StringQ[username], username, ""], 
							If[StringQ[password], password, ""]
							}],
					a_Association?AssociationQ:>
						(
							Set[username, a[["GitHub", 1]]];
							Set[password, a[["GitHub", 2]]];
							)
					]
				];
		{username, password}
		];


GitHubSetUsernameAndPassword[u_, p_]:=
	{$GitHubUsername, $GitHubPassword}=
		GitHubGetUsernameAndPassword[u, p];


GitHubAuthHeader[
	user:_String|Automatic:Automatic,
	password:_String|Automatic:Automatic
	]:=
	With[{up=GitHubGetUsernameAndPassword[user, password]},
		If[Not[AllTrue[up, StringQ[#]&&StringLength[#]>0&]],
			Message[GitHub::noauth];
			Throw@$Failed,
			StringJoin@{
				"Basic ",
				Developer`EncodeBase64@
					StringJoin@{up[[1]],":",up[[2]]}
				}
			]
		];


(* ::Subsubsection::Closed:: *)
(*UserAPI*)



GitHubUserAPI[
	type:"users"|"org":"users",
	user:_String|Automatic:Automatic,
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubQuery[{
		type,
		Replace[user,Automatic:>$GitHubUsername],
		Flatten@path
		},
		query,
		headers
		];


(* ::Subsubsection::Closed:: *)
(*ReposAPI*)



GitHubReposAPI[
	repo_GitHubPath?GitHubRepoQ,
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubQuery[
		Flatten@{
			"repos",
			Sequence@@Normal@repo,
			path
			},
		query,
		headers
		];
GitHubReposAPI[
	s_String?GitHubRepoQ,
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubReposAPI[
		GitHubPathParse[s],
		path,
		query,
		headers
		];


(* ::Subsubsection::Closed:: *)
(*Repositories*)



GitHubRepositories//Clear


GitHubRepositories[
	type:"users"|"org":"users",
	user:_String|Automatic:Automatic,
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubUserAPI[type, user, {"repos"}, query,headers];


(* ::Subsubsection::Closed:: *)
(*Create*)



$GitHubParamMap[GitHubCreate]=
	{
		"Name"->"name",
		"Description"->"description",
		"Private"->"private",
		"HomePage"->"homepage",
		"AutoInit"->"auto_init",
		"HasWiki"->"has_issues",
		"HasProjects"->"has_projects",
		"HasIssues"->"has_wiki",
		"Private"->"team_id",
		"GitIgnore"->"gitignore_template",
		"LicenseTemplate"->"license_template",
		"AllowSquashMerge"->"allow_squash_merge",
		"AllowMergeCommit"->"allow_merge_commit",
		"AllowRebaseMerge"->"allow_rebase_merge"
		};


Options[GitHubCreate]=
	{
		"Username"->Automatic,
		"Password"->Automatic,
		"Description"->Automatic,
		"HomePage"->Automatic,
		"AutoInit"->True,
		"HasWiki"->Automatic,
		"HasProjects"->Automatic,
		"HasIssues"->Automatic,
		"Private"->Automatic,
		"GitIgnore"->Automatic,
		"LicenseTemplate"->Automatic,
		"AllowSquashMerge"->Automatic,
		"AllowMergeCommit"->Automatic,
		"AllowRebaseMerge"->Automatic
		};
GitHubCreate[
	repo_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"],Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"user",
				"repos"
				},
			<|
				"Method"->"POST",
				"Body"->
					ExportString[
						GitHubQueryParamFilter[
							GitHubCreate,
							{
								"Name"->repo,
								ops
								}
							],
						"JSON"
						],
				"Headers"->{
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*Delete*)



GitHubDelete//ClearAll


Options[GitHubDelete]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubDelete[
	repo_GitHubPath?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	With[{uu=URLParse[URL@repo]},
		GitHubReposAPI[
			repo,
			<|
				"Method"->"DELETE",
				"Headers"->
					{
						"Authorization"->
							GitHubAuthHeader[
								DeleteCases[uu["Path"], ""][[1]],
								OptionValue["Password"]
								]
							}
				|>
			]
		];
GitHubDelete[
	s_String?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	Block[{$GitHubPathFormat=False},
		GitHubDelete[
			GitHubPath[s, FilterRules[{ops}, Options@GitHubPath]],
			ops
			]
		];
(*GitHubDelete[
	s_String?(
		URLParse[#,"Scheme"]===None&&
		Length@URLParse[#,"Path"]===1&
		),
	ops:OptionsPattern[]
	]:=
	GitHubDelete[
		GitHubPath[s,
			FilterRules[{ops},Options@GitHubPath]
			],
		ops]*)


(* ::Subsubsection::Closed:: *)
(*ListForks *)



Options[GitHubListForks]=
	{
		"Sort"->None
		};
GitHubListForks[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	GitHubReposAPI[
		repo,
		{"forks"},
		Replace[OptionValue["Sort"],
			{
				Except[_String]:>Sequence@@{},
				s_String:>("sort"->s)
				}
			]
		]


(* ::Subsubsection::Closed:: *)
(*Fork *)



GitHubFork//Clear


Options[GitHubFork]=
	{
		"Organization"->None,
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubFork[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	GitHubReposAPI[
		repo,
		{"forks"},
		Replace[OptionValue["Organization"],
			{
				Except[_String]:>Sequence@@{},
				s_String:>("organization"->s)
				}
			],
		<|
			"Method"->"POST",
			"Headers"->
				{
					"Authorization"->
						OptionValue[{"Username", "Password"}]
					}
			|>
		]
			


(* ::Subsubsection::Closed:: *)
(*CreateReadme*)



GitHubCreateReadme[repo_?GitRepoQ,readmeText:_String:""]:=
	With[{o=
		OpenWrite@
			FileNameJoin@{
				repo,
				"README.md"
				}
		},
		WriteString[o,readmeText];
		Close@o
		];


(* ::Subsubsection::Closed:: *)
(*Releases*)



GitHubReleases[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	identifier:_String|_Integer|None:None]:=
	GitHubReposAPI[
		repo,
		Switch[identifier,
			None,
				"releases",
			_Integer|_?(StringMatchQ[ToLowerCase@#,"latest"]&),
				{"releases",ToLowerCase@ToString@identifier},
			_,
				{"releases","tags",ToLowerCase@ToString@identifier}
			]
		];
GitHubReleases[
	repo:(_GitHubPath|_String)?GitHubReleaseQ,
	identifier:_String|_Integer|None:None
	]:=
	Replace[Replace[repo,s_String:>GitHubPathParse[s]],{
		GitHubPath[s__,"releases","tag",tag_String,o__?OptionQ]:>
			GitHubReleases[GitHubPath[s,o],tag],
		GitHubPath[s__,"releases",o__?OptionQ]:>
			GitHubReleases[GitHubPath[s,o],identifier]
		}]


(* ::Subsubsection::Closed:: *)
(*CreateRelease*)



$GitHubParamMap[GitHubCreateRelease]=
	{
		"Name"->"name",
		"TagName"->"tag_name",
		"TargetCommitish"->"target_commitish",
		"Description"->"body",
		"Draft"->"draft",
		"PreRelease"->"prerelease"
		};


Options[GitHubCreateRelease]=
	{
		"Username"->Automatic,
		"Password"->Automatic,
		"Name"->Automatic,
		"TargetCommitish"->Automatic,
		"Description"->Automatic,
		"Draft"->Automatic,
		"PreRelease"->Automatic
		};
GitHubCreateRelease[
	repo_String,
	tagName_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases"
				},
			<|
				"Method"->"POST",
				"Body"->
				ExportString[
						GitHubQueryParamFilter[
							GitHubCreateRelease,
							{
								"TagName"->tagName,
								ops
								}
							],
						"JSON"
						],
				"Headers"->{
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*EditRelease*)



$GitHubParamMap[GitHubEditRelease]=
	{
		"Name"->"name",
		"TagName"->"tag_name",
		"TargetCommitish"->"target_commitish",
		"Description"->"body",
		"Draft"->"draft",
		"PreRelease"->"prerelease"
		};


Options[GitHubEditRelease]=
	{
		"Username"->Automatic,
		"Password"->Automatic,
		"TagName"->Automatic,
		"Name"->Automatic,
		"TargetCommitish"->Automatic,
		"Description"->Automatic,
		"Draft"->Automatic,
		"PreRelease"->Automatic
		};
GitHubEditRelease[
	repo_String,
	id_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				id
				},
			<|
				"Method"->"PATCH",
				"Body"->
					ExportString[
						GitHubQueryParamFilter[
							GitHubCreateRelease,
							{
								ops
								}
							],
						"JSON"
						],
				"Headers"->{
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*DeleteRelease*)



Options[GitHubDeleteRelease]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubDeleteRelease[
	repo_String,
	id_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				id
				},
			<|
				"Method"->"DELETE",
				"Headers"->{
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*ListReleaseAssets*)



Options[GitHubListReleaseAssets]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubListReleaseAssets[
	repo_String,
	id_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				id,
				"assets"
				},
			<|
				"Method"->"GET",
				"Headers"->{
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*UploadReleaseAsset*)



$GitHubParamMap[GitHubUploadReleaseAsset]=
	{
		"Name"->Automatic,
		"Label"->Automatic
		};


Options[GitHubUploadReleaseAsset]=
	{
		"Username"->Automatic,
		"Password"->Automatic,
		"ContentType"->Automatic,
		"Name"->Automatic,
		"Label"->Automatic
		};
GitHubUploadReleaseAsset[
	repo_String,
	id_String,
	asset:(_String|_File)?FileExistsQ,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				id,
				"assets"
				},
			{
				Replace[OptionValue["Name"],
					{
						s_String:>
							("name"->s),
						_:>
							("name"->FileNameTake[asset])
						}
					],
				Replace[OptionValue["Label"],
					{
						s_String:>
							("label"->s),
						_:>
							Nothing
						}
					]
				},
			<|
				"Method"->"GET",
				"Body"->
					ReadString[asset],
				"Headers"->{
					Replace[OptionValue["ContentType"],
						{
							s_String:>
								"ContentType"->s,
							_->Nothing
							}
						],
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*GetReleaseAsset*)



Options[GitHubGetReleaseAsset]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubGetReleaseAsset[
	repo_String,
	id_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				"assets",
				id
				},
			<|
				"Method"->"GET",
				"Headers"->{
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*EditReleaseAsset*)



$GitHubParamMap[GitHubEditReleaseAsset]=
	{
		"Name"->Automatic,
		"Label"->Automatic
		};


Options[GitHubEditReleaseAsset]=
	{
		"Username"->Automatic,
		"Password"->Automatic,
		"ContentType"->Automatic,
		"Name"->Automatic,
		"Label"->Automatic
		};
GitHubEditReleaseAsset[
	repo_String,
	id_String,
	asset:(_String|_File)?FileExistsQ|None:None,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				"assets",
				id
				},
			{
				Replace[OptionValue["Name"],
					{
						s_String:>
							("name"->s),
						_:>
							If[asset=!=None,
								"name"->FileNameTake[asset],
								Nothing
								]
						}
					],
				Replace[OptionValue["Label"],
					{
						s_String:>
							("label"->s),
						_:>
							Nothing
						}
					]
				},
			<|
				"Method"->"GET",
				If[asset=!=None,
					"Body"->
						ReadString[asset],
					Nothing
					],
				"Headers"->{
					Replace[OptionValue["ContentType"],
						{
							s_String:>
								"ContentType"->s,
							_->Nothing
							}
						],
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*DeleteReleaseAsset*)



$GitHubParamMap[GitHubEditReleaseAsset]=
	{
		"Name"->Automatic,
		"Label"->Automatic
		};


Options[GitHubDeleteReleaseAsset]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubEditReleaseAsset[
	repo_String,
	id_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"], Automatic:>$GitHubUsername]},
		GitHubQuery[
			{
				"repos",
				u,
				repo,
				"releases",
				"assets",
				id
				},
			<|
				"Method"->"DELETE",
				"Headers"->
					{	
						"Authorization"->
							GitHubAuthHeader[
								u,
								OptionValue["Password"]
								]
							}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*Deployments*)



GitHubDeployments[repo:(_GitHubRepo|_String)?GitHubRepoQ,
	identifier:_String|_Integer|None
	]:=
	GitHubReposAPI[repo,
		If[identifier===None,
			"deployments",
			{"deployments",ToLowerCase@ToString@identifier}
			]
		];


(* ::Subsubsection::Closed:: *)
(*GitHubClone *)



GitHubClone//Clear


Options[GitHubClone]=
	Join[
		Options[GitHubPath],
		{
			OverwriteTarget->False
			}
		];
GitHubClone[
	repo:(_String|_GitHubPath)?(Not@*GitHubReleaseQ),
	dir:(_String?(DirectoryQ@*DirectoryName))|Automatic:Automatic,
	ops:OptionsPattern[]
	]:=
	Module[
		{
			path=
				If[MatchQ[repo, _GitHubPath],
					repo,
					GitHubPath[repo, FilterRules[{ops}, Options@GitHubPath]]
					]
			},
		With[
			{
				o=Options[path],
				n=Normal[path]
				},
			Switch[Lookup[o, "Tree", "tree"],
				"tree",
					If[Length@n<3,
						GitClone[URL[path], dir,
							TrueQ@OptionValue[OverwriteTarget]
							],
						SVNExport[
							URL[GitHubPath[repo, "Tree"->"trunk", "Branch"->Nothing]],
							dir,
							"TrustServer"->True,
							OverwriteTarget->OptionValue[OverwriteTarget]
							]
						],
				"trunk",
					SVNExport[
						URL[path],
						dir,
						"TrustServer"->True,
						OverwriteTarget->OptionValue[OverwriteTarget]
						],
				"raw",
					Replace[
						URLDownload[
							URL[path],
							FileNameJoin@{
								If[StringQ@dir, 
									If[!DirectoryQ@dir, CreateDirectory[dir]];
									dir,
									$TemporaryDirectory
									], 
								Last@n
								}
							],
						File[f_]:>f
						],
				_,
					$Failed
				]
			]/;path=!=$Failed
		];
GitHubClone[
	repo:(_String|_GitHubPath)?GitHubReleaseQ,
	dir:(_String?(DirectoryQ@*DirectoryName))|Automatic:Automatic
	]:=
	With[{release=
		GitHubImport["Releases",
			repo,
			"latest"
			]["Content"]
		},
		If[AssociationQ@release,
			If[Length@release["Assets"]>0,
				With[{url=
					release[["Assets",-1,"BrowserDownloadURL"]]
					},
					URLDownload[
						url,
						FileNameJoin@{
							Replace[dir, 
								{
									Automatic:>$TemporaryDirectory,
									_:>(If[!DirectoryQ@dir, CreateDirectory[dir]];dir)
									}
								],
							URLParse[url,"Path"][[-1]]
							}
						]
					],
				ExtractArchive[
					URLDownload[
						release["ZipballURL"],
						FileNameJoin@{
							$TemporaryDirectory,
							URLParse[release["ZipballURL"],"Path"][[-1]]
							}
						],
					Replace[dir, 
						{
							Automatic:>$TemporaryDirectory,
							_:>(If[!DirectoryQ@dir, CreateDirectory[dir]];dir)
							}
						]
					]
				],
			$Failed
			]
		]


(* ::Subsubsection::Closed:: *)
(*GitHubConfigure*)



GitHubConfigure[
	dirBase:_String?DirectoryQ|Automatic,
	repo:_String?GitHubRepoQ|_GitHubPath,
	ignorePats:{___String}|None:None,
	excludePats:{___String}|None:None
	]:=
	Module[{repoExistsQ, dir=Replace[dirBase, Automatic:>Directory[]]},
		If[!GitRepoQ@dir,
			GitInit[dir, ignorePats, excludePats];
			GitSetRemote[dir, repo];
			repoExistsQ=Between[URLRead[repo,"StatusCode"],{200,299}];
			If[repoExistsQ, GitRealignRemotes[dir]]
			];
		If[GitRepoQ@dir,
			If[!ValueQ[repoExistsQ],
				repoExistsQ=Between[URLRead[repo,"StatusCode"],{200,299}]
				];
			If[!repoExistsQ,
				GitHubImport["Create",
					URLParse[repo, "Path"][[-1]]
					];
				GitSetRemote[dir, repo]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*GitHubPush*)



GitHubPush[
	dir:_String?GitRepoQ,
	repo:_String|_GitHubPath|Automatic:Automatic
	]:=
	Replace[repo,{
		Automatic:>
			Replace[
				GitGetRemoteURL[dir, "PushURL"->True],
				{
					s_String:>
						Git["Push", dir, s],
					(r_->s_):>
						Quiet@
							Check[
								Git["Push", dir, r, "master"],
								Git["Push", s]
								]
					}
				],
		s_String?(URLParse[#, "Scheme"]===None&):>
			Quiet@
				Check[
					Git["Push", dir, s, "master"],
					Git["Push", dir, URL@GitHubPath[s]]
					],
		s_String:>
			Git["Push", dir, s]
		}]


(* ::Subsubsection::Closed:: *)
(*GitHub*)



$GitHubActions=
	<|
		"Push"->
			GitHubPush,
		"Configure"->
			GitHubConfigure,
		"Repositories"->
			GitHubRepositories,
		"Clone"->
			GitHubClone,
		"Create"->
			GitHubCreate,
		"Delete"->
			GitHubDelete,
		"Fork"->
			GitHubFork,
		"ListForks"->
			GitHubListForks,
		"CreateReadme"->
			GitHubCreateReadme,
		"Releases"->
			GitHubReleases,
		"CreateRelease"->
			GitHubCreateRelease,
		"EditRelease"->
			GitHubEditRelease,
		"DeleteRelease"->
			GitHubDeleteRelease,
		"UploadReleaseAsset"->
			GitHubUploadReleaseAsset,
		"GetReleaseAsset"->
			GitHubGetReleaseAsset,
		"EditReleaseAsset"->
			GitHubEditReleaseAsset,
		"DeleteReleaseAsset"->
			GitHubDeleteReleaseAsset,
		"Deployments"->
			GitHubDownloads,
		"Path"->
			Function[GitHubPath[##]],
		"URL"->
			Function[
				Replace[GitHubPath[##],
					g_GitHubPath:>URL[g]
					]
				],
		"RawPath"->
			Function[GitHubPath[##, "Tree"->"raw"]],
		"RawURL"->
			Function[
				Replace[GitHubPath[##, "Tree"->"raw"],
					g_GitHubPath:>URL[g]
					]
				],
		"SVNPath"->
			Function[GitHubPath[##, "Tree"->"trunk", "Branch"->Nothing]],
		"SVNURL"->
			Function[
				Replace[GitHubPath[##, "Tree"->"trunk", "Branch"->Nothing],
					g_GitHubPath:>URL[g]
					]
				],
		"PathQ"->
			GitHubPathQ,
		"RepoQ"->
			GitHubRepoQ
		|>;


$githubactions:=
	KeyMap[ToLowerCase]@$GitHubActions


PackageAddAutocompletions[
	"GitHub",
	{
		Keys[$GitHubActions]
		}
	]


GitHub//Clear


GitHub[
	command_?(KeyMemberQ[$githubactions,ToLowerCase@#]&),
	args:Except[_?OptionQ]...,
	opp___?OptionQ
	]:=
	Block[{$GitHubRepoFormat=True},
		With[
			{
				cmd=$githubactions[ToLowerCase@command],
				ropp=Sequence@@FilterRules[{opp}, Except["GitHubImport"]]
				},
			With[
				{
					r=
						If[Options[cmd]=!={},
							cmd[args, Sequence@@FilterRules[{opp}, Options@cmd]],
							With[{c=cmd[args, ropp]},
								If[Head@c===cmd,
									cmd[args],
									c
									]
								]
							]
					},
				Replace[r,
					h_HTTPRequest:>
						If[Lookup[{opp}, "GitHubImport", $GitHubImport]=!=False, 
							GitHubImport, 
							Identity
							]@
							URLRead[h]
					]/;Head[r]=!=cmd
				]
			]
		];


GitHub[
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>,
	opp___?OptionQ
	]:=
	Block[{$GitHubRepoFormat=True},
		If[
			Lookup[{opp}, "GitHubImport", $GitHubImport]=!=False, 
			GitHubImport, 
			Identity
			]@
			URLRead[
				GitHubQuery[
					path,
					query,
					headers
					]
				]
		];


(* ::Subsubsection::Closed:: *)
(*GitHubImport*)



GitHubImport[a_Association]:=
	Association@
		KeyValueMap[
			StringReplace[
				StringJoin[
					Replace[
						HoldPattern[Capitalize[s_String]]:>
							(ToUpperCase@StringTake[s,1]<>StringDrop[s,1])
						]@*Capitalize/@StringSplit[#,"_"]
					],{
				"Id"~~EndOfString->"ID",
				"Url"->"URL",
				"Html"->"HTML"
				}]->
				Which[
					StringEndsQ[#,"_at"],
						DateObject@#2,
					StringEndsQ[#,"url"],
						URL[#2],
					True,
						GitHubImport@#2
					]&,
		a
		];
GitHubImport[h_HTTPResponse]:=
	<|
		"StatusCode"->
			h["StatusCode"],
		"Content"->
			If[MatchQ[h["StatusCode"],0|(_?(Between@{200,299}))],
				Quiet[
					Check[
						GitHubImport@Import[h, "RawJSON"],
						Null,
						Import::jsonnullinput
						],
					Import::jsonnullinput
					],
				$Failed
				]
		|>;
GitHubImport[s_String]:=
	s;
GitHubImport[l_List]:=
	GitHubImport/@l;
GitHubImport[e_]:=
	e


GitHubImport[
	command_?(KeyMemberQ[$githubactions,ToLowerCase@#]&),
	args__
	]:=
	With[{gh=GitHub[command,args]},
		GitHubImport[gh]/;Head[gh]=!=GitHub
		]
GitHubImport[
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	With[{gh=GitHub[path,query,headers]},
		GitHubImport[gh]/;Head[gh]=!=GitHub
		]


End[];



