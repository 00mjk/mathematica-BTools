(* ::Package:: *)

(* Autogenerated Package *)

MarkdownElement::usage=
  "Symbolic Markdown representation";
MarkdownParse::usage=
  "Symbolic Markdown representation";


Begin["`Private`"];


(* ::Subsection:: *)
(*MarkdownParse*)



markdownPostProcess//ClearAll


(* ::Subsubsection::Closed:: *)
(*Meta*)



markdownPostProcess[postProcessor_]["Meta", text_]:=
  With[{bits=StringSplit[#, ":", 2]},
    If[Length@bits<2,
      Nothing,
      postProcessor["Meta", StringTrim@bits]
      ]
    ]&/@StringSplit[text,"\n"];


(* ::Subsubsection::Closed:: *)
(*FenceBlock*)



markdownPostProcess[postProcessor_][
  "FenceBlock",
  text_
  ]:=
  With[{
    striptext=
      StringSplit[
        StringTrim[
          text,
          StringRepeat["`",
            StringLength@text-
              StringLength@StringTrim[text,StartOfString~~("`"..)]
            ]
          ],
        "\n",
        2
        ]
    },
    postProcessor[
      "FenceBlock",
      striptext
      ]
   ]


(* ::Subsubsection::Closed:: *)
(*CodeBlock*)



markdownPostProcess[postProcessor_][
  "CodeBlock",
  text_
  ]:=
  With[{
    stripableWhitespace=
      First@
        MinimalBy[
          StringCases[text,
            StartOfLine~~w:Whitespace?(StringFreeQ["\n"])~~
              Except[WhitespaceCharacter]:>w
            ],
          StringLength
          ]
    },
    postProcessor["CodeBlock", 
      StringTrim@
        StringReplace[
          text,
          StartOfLine~~stripableWhitespace->""
          ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*QuoteBlock*)



markdownPostProcess[postProcessor_][
  "QuoteBlock",
  text_
  ]:=
  With[{
    quoteStripped=
      StringTrim@
        StringReplace[
          text,
          StartOfLine~~">"->""
          ]
    },
    postProcessor[
      "QuoteBlock",
      markdownParse[postProcessor][
        quoteStripped, 
         Join[
            $markdownParseElementRules,
            $markdownParseOneTimeElementRules
            ]
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*Header*)



markdownPostProcess[postProcessor_][
  "Header",
  text_
  ]:=
  With[{t=StringTrim[text]},
    postProcessor[
      {"Header", StringLength[t]-StringLength[StringTrim[t,StartOfString~~"#"..]]},
      markdownParse[postProcessor][
        StringTrim[t, StartOfString~~"#"..], 
        Join[
          $markdownParseElementRules,
          $markdownParseOneTimeElementRules
          ]
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*Item*)



markdownParseItemRecursiveFormat[postProcessor_][l_]:=
  With[
    {
      number=l[[1,1,2]]
      },
    postProcessor[
     Switch[l[[1,1,1]],
        DigitCharacter,
          "OrderedList",
        _,
          "UnorderedList"
        ],
      Flatten@Replace[
        SplitBy[l,
          #[[1,2]]==number&
          ],
        {
          mainlist:
            {
                {_, number}->_,
                ___
                }:>
              Last/@mainlist,
          sublist_:>
            markdownParseItemRecursiveFormat[postProcessor][sublist]
          },
        1
        ]
      ]
    ]


markdownPostProcess[postProcessor_]["Item", text_String]:=
  With[{
    lines=
      StringJoin/@
        Partition[
          StringSplit[text,
            StartOfLine~~
              ws:(Whitespace|"")~~
                thing:("* "|"- "|((DigitCharacter..~~"."))):>
              ws<>thing
            ],
          2
          ]
    },
    markdownParseItemRecursiveFormat[postProcessor]/@
      SplitBy[
        With[
        {
          subtype=
            Floor[
              (StringLength[#]
                -StringLength@StringTrim[#, StartOfString~~Whitespace])/2
              ],
          thingtype=
            Replace[
              StringTake[
                StringTrim[#,StartOfString~~Whitespace],
                2],{
              t:("* "|"- "):>t,
              _->DigitCharacter
              }]
          },
          {thingtype,subtype}->
            postProcessor["Item",
              markdownParse[postProcessor][
                StringTrim[
                  StringTrim[#,
                    (Whitespace|"")~~
                      ("* "|"- "|((DigitCharacter..~~". ")))
                    ]
                  ],
                Join[
                  $markdownParseElementRules,
                  $markdownParseOneTimeElementRules
                  ]
                ]
              ]
          ]&/@lines,
      #[[1,1]]&
      ]
  ]


(* ::Subsubsection::Closed:: *)
(*ItalBold*)



markdownPostProcess[postProcessor_]["ItalBold", t_]:=
  With[
    {
      new=
        StringTrim[t, Repeated["*"|"_"]]
      },
    postProcessor[
      Which[
        StringLength[t]-StringLength[new]<4,
          "Italic",
        StringLength[t]-StringLength[new]<6,
          "Bold",
        True,
          "ItalicBold"
        ],
      markdownParse[postProcessor][
        new,
        Join[
          $markdownParseElementRules,
          $markdownParseOneTimeElementRules
          ]
        ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*Delimiter*)



markdownPostProcess[postProcessor_]["Delimiter", t_]:=
  postProcessor["Delimiter", t]


(* ::Subsubsection::Closed:: *)
(*CodeLine*)



markdownPostProcess[postProcessor_][
  "CodeLine",
  text_
  ]:=
  With[{
    striptext=
      StringTrim[
        text,
        StringRepeat["`",
          StringLength@text-
            StringLength@StringTrim[text, StartOfString~~("`"..)]
          ]
        ]
    },
    postProcessor["Code", striptext]
    ]


(* ::Subsubsection::Closed:: *)
(*XML*)



importXMLSlow[text_]:=
  FirstCase[
    ImportString[text, {"HTML", "XMLObject"}],
    XMLElement["body"|"head", _, b_]|b:XMLElement["script", __]:>b,
    "",
    \[Infinity]
    ]


markdownPostProcess[postProcessor_][
  "XMLBlock"|"XMLLine",
  text_
  ]:=
  Module[{h=ToString@Hash[text]},
    $tmpMap[h]=text;
    Sow[h->text, "XMLExportKeys"];
    "XMLToExport"[h]
    ]


(* ::Subsubsection::Closed:: *)
(*Hyperlink*)



markdownPostProcess[postProcessor_][
  "Link",
  text_
  ]:=
  With[{
    bits=
      {StringRiffle[#[[;;-2]], "]("], #[[-1]]}&@StringSplit[
        text,
        "]("
        ]
    },
    postProcessor[
      "Link",
      {
        StringTrim[Last[bits],")"],
        markdownParse[postProcessor][
          StringTrim[First[bits],"["],
          Join[
            $markdownParseElementRules,
            $markdownParseOneTimeElementRules
            ]
          ]
        }
      ]
    ]


markdownPostProcess[postProcessor_][
  "LinkRef",
  text_
  ]:=
  With[{bits=StringSplit[text, "][", 2]},
    postProcessor["Link",
      {
        "RefLink"@StringTrim[Last[bits],"]"],
        markdownParse[postProcessor][
          StringTrim[First[bits],"["],
          Join[
            $markdownParseElementRules,
            $markdownParseOneTimeElementRules
            ]
          ]
        }
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*Img*)



markdownPostProcess[postProcessor_][
  "Image",
  text_
  ]:=
  With[{
    bits=
      {StringJoin@#[[;;-2]], #[[-1]]}&@StringSplit[
        text,
        "]("
        ]
    },
    postProcessor["Image", {StringTrim[Last[bits],")"], StringTrim[First[bits],"!["]}]
    ]


markdownPostProcess[postProcessor_][
  "ImageRef",
  text_
  ]:=
  With[{
    bits=
      StringSplit[
        text,
        "][",
        2
        ]
    },
    postProcessor["Image",
      {
        "ImageRefLink"@StringTrim[Last[bits],"]"],
        StringTrim[First[bits],"!["]
        }
      ]
    ]


markdownPostProcess[postProcessor_][
  "ImageRefLink",
  text_
  ]:=
  With[{
    bits=
      StringSplit[
        text,
        "]:",
        2
        ]
    },
    Sow[
      {"ImageRefLink", StringTrim[First@bits, (Whitespace|"")~~"["]}->Last@bits,
      "RefLinks"
      ];
    Nothing
    ];
markdownPostProcess[postProcessor_][
  "ImageRefLinkBlock",
  text_
  ]:=
  markdownPostProcess[postProcessor]["ImageRefLink", #]&/@
    Select[StringSplit[text, "\n"],
      Not@*StringMatchQ[Whitespace]
      ]


(* ::Subsubsection::Closed:: *)
(*Fallback*)



markdownPostProcess[postProcessor_][t_, text_String]:=
  postProcessor[t, text]


(* ::Subsubsection::Closed:: *)
(*makeTempHashKey*)



$hashKeyLH=
  FromCharacterCode[RandomInteger[{1000, 5000}, 8]];
$hashKeyRH=
  FromCharacterCode[RandomInteger[{1000, 5000}, 8]];


makeTempHashKey[h_]:=
  $hashKeyLH<>h<>$hashKeyRH;
matchTempHashKey=
  $hashKeyLH~~hashInt:NumberString~~$hashKeyRH:>$tmpMap[hashInt];


makeHashRef[orphans_, tag_, main_]:=
  With[{h=ToString@Hash[main]},
    $tmpMap[h]=tag->main;
    "Reinsert"->{orphans, makeTempHashKey@h}
    ];
makeHashRef[a_->b_]:=
  makeHashRef["", a, b];
makeHashRef[a_, b_]:=
  makeHashRef["", a, b];


(* ::Subsubsection::Closed:: *)
(*markdownParseValidateXMLBlock*)



markdownParseValidateXMLBlock[block_, start_, end_]:=
  start==end&&
    With[
      {
        splits=
          Developer`ToPackedArray@
            StringCases[block,
              {
                ("<"~~(Whitespace|"")~~(Whitespace|"")~~start)->
                  {1, 0},
                ("<"~~(Whitespace|"")~~"/"~~(Whitespace|"")~~end)->
                  {0, 1}
                }
              ]
        },
      (#[[1]]==#[[2]]&[Total[splits]])&&
      AllTrue[
        Accumulate@Most@splits,
        #[[1]]>#[[2]]&
        ]
      ]


(* ::Subsubsection::Closed:: *)
(*$markdownParseRules*)



(* ::Subsubsubsection::Closed:: *)
(*$markdownParseMeta*)



(* ::Text:: *)
(*
	For stripping meta info as used by pelican and things
*)



$markdownParseMeta=
  meta:(
    StartOfString~~
      (
        (
          StartOfLine~~(Whitespace|"")~~
          Except[WhitespaceCharacter, WordCharacter]..~~
          (Whitespace|"")~~":"~~Except["\n"]...~~"\n")..
          )
    ):>
      {
        "Meta"->meta
        }


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseFenceBlock*)



$markdownParseFenceBlock=
    fence:(
      StartOfLine~~
        (
          r:Repeated["`", {3, \[Infinity]}]
        )~~
          t:Repeated[Except["`"|"\n"], {2, \[Infinity]}]~~"\n"
          ~~s___~~
      StartOfLine~~(b:Repeated["`", {3, \[Infinity]}])
      )/;(
          StringLength[r]==StringLength[b]&&
          Length[StringSplit[fence, "\n"]]>2&&
          StringCount[fence, b]==2
        ):>
    {
      "FenceBlock"->fence
      };


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseCodeBlock*)



$markdownParseCodeBlock=
  code:(
    Longest[
      (
        (StartOfString|"\n")~~
          ("\t"|"    ")~~
          Except["\n"]..~~
          "\n"
          )~~
        (
          (
            (StartOfLine|(StartOfLine~~("\t"|"    ")~~
              Except["\n"]..))~~
              ("\n"|EndOfString)
              )...
          )
      ]
    ):>
    "CodeBlock"->code;


$markdownParseEndOfStringCodeBlock=
  code:(
    (StartOfString|"\n")~~
      ("\t"|"    ")~~
      Except["\n"]..~~EndOfString
    ):>
    "CodeBlock"->code;


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseDelimiter*)



$markdownParseDelimiter=
  t:(
    (StartOfString|StartOfLine)~~
      (Whitespace|"")~~
      Repeated["-"|"_", {3,\[Infinity]}]~~
      (Whitespace|"")~~(EndOfLine|EndOfString)
      ):>
    "Delimiter"->t


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseHeader*)



$markdownParseHeader=
  t:(StartOfLine~~(Whitespace|"")~~Longest["#"..]~~Except["\n"]..):>
    "Header"->t


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseQuoteBlock*)



$markdownParseQuoteBlock=
  q:(
      (StartOfLine~~">"~~
        Except["\n"]..~~("\n"|EndOfString)
        )..
      ):>
    "QuoteBlock"->q


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseItemBlock*)



$markdownParseLineIdentifier=
  ("* "|"- "|((DigitCharacter..)~~". "))


$markdownParseBlankSpaces=  
  Repeated[
    ("\n"~~(Except["\n"]..)~~EndOfLine),
    {0, 1}
    ]~~("\n\n"|"")


$markdownParseItemLine=
  (
    (StartOfLine|StartOfString)~~
      (Whitespace?(StringFreeQ["\n"])|"")~~
      $markdownParseLineIdentifier~~
        Except["\n"]...~~(EndOfLine|EndOfString)
    );


$markdownParseItemSingle=
  $markdownParseItemLine~~
    $markdownParseBlankSpaces;
$markdownParseItemBlock=
  t:
    Repeated[
      $markdownParseItemSingle
      ]:>
    "Item"->t


$markdownParseTwoWhitespaceItemLine=
  $markdownParseItemSingle/.
    Verbatim[(Whitespace?(StringFreeQ["\n"])|"")]:>
      Repeated[Except["\n", WhitespaceCharacter], {0,2}];


$markdownParseMultiItemBlock=
  t:(
    $markdownParseTwoWhitespaceItemLine~~
      Repeated[
        $markdownParseItemSingle~~
          ("\n\n"|"")
        ]
      ):>
    "Item"->t


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseLink*)



markdownParseLinkPairedBrackets[o_]:=
  StringCount[o, "["]>0&&
    StringCount[o, "["]==StringCount[o, "]"]
markdownParseValidateLink[o_]:=
  markdownParseLinkPairedBrackets[o]&&
    !markdownParseLinkPairedBrackets[StringSplit[o, "]", 2][[2]]];
markdownParseValidateLink2[o_]:=
  StringCount[o, "]["]==1&&
    markdownParseLinkPairedBrackets[o]&&
      !markdownParseLinkPairedBrackets[StringSplit[o, "][", 2][[2]]]


badLinkChars="!"(*|"*"|"_"*);


$markdownParseLink=
  l:Shortest[
    (o:Except[badLinkChars]|StartOfLine|StartOfString)~~
      link:("["~~Except["\n"]..~~"]("~~Except[WhitespaceCharacter]..~~")")
      ]/;markdownParseValidateLink[link]:>
        makeHashRef[o, "Link", link]


$markdownParseLinkRef=
  l:Shortest[
    (o:Except[badLinkChars]|StartOfLine|StartOfString)~~
      link:("["~~Except["\n"]..~~"]["~~Except[WhitespaceCharacter]..~~"]")
    ]/;markdownParseValidateLink2[link]:>
        makeHashRef[o, "LinkRef", link]


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseImage*)



$markdownParseImage=
  img:Shortest[("!["~~Except["\n"]..~~"]("~~Except[WhitespaceCharacter]..~~")")]/;
    markdownParseValidateLink[img]:>
    makeHashRef["Image"->img]


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseImageRef*)



$markdownParseImageRef=
  img:Shortest[("!["~~Except["]"]..~~"]["~~Except["]"]..~~"]")]:>
    makeHashRef["ImageRef"->img]


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseImageRefLinkBlock*)



$markdownParseImageRefLinkBlock=
  img:Repeated[(
    (Whitespace|"")~~"["~~Except["]"]..~~"]:"~~(Whitespace|"")~~
      WordCharacter~~Except[WhitespaceCharacter]..)]:>
    "ImageRefLinkBlock"->img


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseImageRefLink*)



$markdownParseImageRefLink=
  img:((Whitespace|"")~~"["~~Except["]"]..~~"]:"~~(Whitespace|"")~~
    Except[WhitespaceCharacter]..~~(Whitespace|"")):>
    makeHashRef["ImageRefLink"->img]


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseCodeLine*)



validCodeBlockQ[r_, b_, mid_]:=
  StringLength[r]==StringLength[b]&&StringCount[mid, "`"]<StringLength[r]


$markdownParseCodeLine=
    o:(Except["`"]|StartOfLine|StartOfString)~~
      code:(
        (r:"`"..)~~Except["`"]~~mid___~~(Except["`"]|"")~~(b:"`"..)
        )/;validCodeBlockQ[r, b, mid]:>
    makeHashRef[o, "CodeLine", code]


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseMathLine*)



$markdownParseMathLine=
  math:Shortest[("$$"~~__~~"$$")]:>
    makeHashRef[("MathLine"->math)];
$markdownParseMathLine=
  math:Shortest[("$"~~__~~"$")]:>
    makeHashRef[("MathLine"->math)]


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseXMLLine*)



$markdownParseXMLLine=
  xml:
    ("<"~~tag:WordCharacter..~~Except["<"]..~~"/>")|
    ("<link"~~Except["<"]..~~">"):>
    ("XMLLine"->xml)


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseXMLBlock*)



$markdownParseXMLBlock=
  cont:(
    "<"~~t:WordCharacter..~~__~~
      "</"~~(Whitespace|"")~~t__(*t2:WordCharacter..*)~~(Whitespace|"")~~">"
    )/;markdownParseValidateXMLBlock[cont, t, t]:>
    ("XMLBlock"->cont);


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseSimpleXMLBlock*)



$markdownParseSimpleXMLBlock=
  cont:(
    "<"~~t:WordCharacter..~~Except[">"]...~~">"~~Except["<"]...~~
      "</"~~(Whitespace|"")~~t__~~(Whitespace|"")~~">"
    ):>
    ("XMLBlock"->cont);


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseRawXMLBlock*)



(*$markdownParseCommonXMLBlock=
	cont:(
		(StartOfLine|StartOfString)~~
			"<"~~(Whitespace|"")~~t:WordCharacter..~~..~~"\n\n"~~
				"</"~~(Whitespace|"")~~t__~~(Whitespace|"")~~">"
		)/;markdownParseValidateXMLBlock[cont, t, t]\[RuleDelayed]
		("XMLBlock"\[Rule]cont);*)


$markdownParseShortXMLBlock=
  cont:Shortest[(
    (StartOfLine|StartOfString)~~
      "<"~~(Whitespace|"")~~t:WordCharacter..~~__~~
        "</"~~(Whitespace|"")~~t__~~(Whitespace|"")~~">"
    )]/;markdownParseValidateXMLBlock[cont, t, t]:>
    ("XMLBlock"->cont);


$markdownParseCompleXMLBlock=
  cont:(
    (StartOfLine|StartOfString)~~
      "<"~~(Whitespace|"")~~t:WordCharacter..~~__~~
        "</"~~(Whitespace|"")~~t__~~(Whitespace|"")~~">"
    )/;markdownParseValidateXMLBlock[cont, t, t]:>
    ("XMLBlock"->cont);


$markdownParseRawXMLBlock=
  {
    (*$markdownParseCommonXMLBlock,*)
    $markdownParseShortXMLBlock,
    $markdownParseCompleXMLBlock
    };


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseItalBold*)



$markdownParseItalBold=
  o:(a:(("*"|"_")..)~~Shortest[t:Except["\n"]..]~~a_):>
    makeHashRef["", "ItalBold", o]


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseBlockRules*)



$markdownParseBlockRules={
  $markdownParseRawXMLBlock,
  $markdownParseFenceBlock,
  $markdownParseImageRefLinkBlock,
  $markdownParseMultiItemBlock,
  $markdownParseCodeBlock,
  $markdownParseEndOfStringCodeBlock,
  $markdownParseDelimiter,
  $markdownParseHeader,
  $markdownParseItemBlock,
  $markdownParseQuoteBlock
  };


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseElementRules*)



$markdownParseElementRules=
  {
    $markdownParseXMLBlock,
    $markdownParseXMLLine,
    $markdownParseCodeLine,
    $markdownParseLink,
    $markdownParseLinkRef,
    $markdownParseImageRef,
    $markdownParseImageRefLink,
    $markdownParseImage,
    $markdownParseItalBold,
    $markdownParseMathLine
    };


(* ::Subsubsubsection::Closed:: *)
(*$markdownParseNewLineElements*)



$markdownParseNewLineElements=
  {
    "img"
    };


(* ::Subsubsection::Closed:: *)
(*markdownParsePrep*)



markdownParsePrep//Clear


markdownParsePrep[text_String, rules:_List|Automatic:Automatic, depth_:1]:=
  With[
    {
      baseData=
        Fold[
          Flatten@
            Replace[
              Replace[#,
                {
                  baseText_String:>{baseText},
                  StringExpression[l__]:>
                    List[l]
                  }
                ],
              {
                baseString_String:>
                  Replace[
                    StringReplace[baseString, #2],
                    StringExpression[l__]:>
                      List[l]
                    ]
                },
              1]&,
          text,
          Replace[rules,
            Automatic:>
              If[depth>1,
                DeleteCases[
                  $markdownParseBlockRules,
                  Apply[
                    Alternatives,
                    Verbatim/@
                      Flatten@List@
                        Replace[$markdownParseOneTimeBlockRules, Except[_List]->{}]
                 ]
                  ],
                $markdownParseBlockRules
                ]
            ]
          ]
        },
      Which[
        StringQ@baseData,
          {baseData},
        AllTrue[baseData, StringQ],
          baseData,
        True,
          Flatten@markdownPrepRecursive[baseData, rules, depth+1]
        ]
      ]


markdownPrepRecursive//Clear


markdownPrepRecursive[baseData_, rules_, depth_:1]:=
  If[StringQ@#, markdownParsePrep[#, rules, depth], #]&/@
    Flatten@
      Replace[
        Flatten@
        ReplaceRepeated[
          Flatten[List@@baseData],
          {
            {a___, t_String, "Reinsert"->o_, b_String, c___}:>
              {a, markdownParsePrep[t<>o<>b, Automatic, depth], c},
            {a___, t_String, "Orphan"->o_, b___}:>
              {a, markdownParsePrep[t<>o, Automatic, depth], b}
            }
          ],
        {
          ("Orphan"->s_):>s(*Sequence@@{}*),
          ("Reinsert"->s_):>s
          },
        1
        ]


(* ::Subsubsection::Closed:: *)
(*markdownParseReinsertRefs*)



markdownParseReinsertRefs[eeex_]:=
  Module[{reap, oppp, expr, ops},
    reap=Reap[eeex, "RefLinks"];
    {expr, ops}=reap;
    oppp=Association@Cases[Flatten@ops, _Rule|_RuleDelayed];
    expr//.
      {
        "ImageRefLink"[x_]:>
          Lookup[oppp, Key@{"ImageRefLink", x}, x],
        "RefLink"[x_]:>
          Lookup[oppp, Key@{"ImageRefLink", x}, x]
        }
    ];
markdownParseReinsertRefs~SetAttributes~HoldFirst;


(* ::Subsubsection::Closed:: *)
(*markdownParseReinsertXML*)



makeXMLBlock//Clear;
makeXMLBlock[{x_XMLElement}]:=x;
makeXMLBlock[{x__XMLElement}]:=x;
makeXMLBlock[e_]:=e;


markdownParseReinsertXML[postProcess_]:=
  Function[Null, imarkdownParseReinsertXML[#, postProcess], HoldAllComplete];
imarkdownParseReinsertXML[expr_, postProcess_]:=
  Module[{reap, ex, keys, exported, expass, expass2},
    reap=Reap[expr, "XMLExportKeys"];
    keys=Flatten@reap[[2]];
    ex=reap[[1]];
    Length@keys;
    If[Length@keys>0,
      exported=
        ImportString[
          StringJoin@{
            "<div>",
            "<div id=\""<>#[[1]]<>"\" class=\"hash-cell\">"<>
              #[[2]]<>"</div>"&/@
              keys,
            "</div>"
            },
          {"HTML", "XMLObject"}
          ];
      expass=
        Association@
          Cases[exported, 
            XMLElement["div", 
              {___, "class"->"hash-cell", "id"->id_, ___}|
                {___, "id"->id_, "class"->"hash-cell", ___},
              b_
              ]:>(id->b),
            \[Infinity]
            ];
      expass2=
        AssociationMap[
          ReplaceRepeated[
            #,
            {
              XMLElement["div", 
                {___, "class"->"hash-cell", "id"->id_, ___}|
                  {___, "id"->id_, "class"->"hash-cell", ___},
                _
                ]:>Sequence@@Lookup[expass, id, "UnprocessedXML"[id](*Nothing*)]
              }
            ]&, 
          expass
          ]; 
      ex//."XMLToExport"[h_]:>
        postProcess["XML", 
          makeXMLBlock@Lookup[expass2, h, 
            XMLElement["unprocessedXML", {"hash"->ToString[h]}, {}]
            (*Nothing*)
            ]
          ],
      ex//."XMLToExport"[h_]:>
        postProcess[
          "XML",
          XMLElement["unprocessedXML", {"hash"->ToString[h]}, {}]
          ]
      ]
    ];
imarkdownParseReinsertXML~SetAttributes~HoldFirst;


(* ::Subsubsection::Closed:: *)
(*markdownFixedPointReplace*)



(* ::Text:: *)
(*
	Done with FixedPoint to handle all of the hash-prep stuff. 
	Hopefully done in such a way as to not fuck up everything.
*)



markdownFixedPointReplace[text_, rules_, n_:1]:=
  Module[{iterate=n},
    FixedPoint[
      If[StringQ@#,
        Replace[
          markdownParsePrep[#, rules, iterate++], 
          {
            s:{_String, __String}:>
              markdownParsePrep[StringJoin[s], rules, iterate],
            e_List:>
              Flatten[
                Replace[SplitBy[e, StringQ],
                  j:{__String}:>StringJoin[j],
                  1
                  ],
                1
                ]
            }
          ],
        #
        ]&,
      text,
      10 (* could forsee recursion infinitely, but unlikely *)
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*markdownParse*)



markdownParse//Clear


markdownParse[postProcessor_][
  text_String,
  rules:_List|Automatic:Automatic,
  extraBlockRules:_List:{},
  extraElementRules:_List:{},
  oneTimeBlockRules:_List:{},
  oneTimeElementRules:_List:{}
  ]:=
  Block[
    {
     $iteration = Replace[$iteration, Except[_Integer]->0] + 1,
      $markdownParseBlockRules=
        DeleteCases[
          DeleteDuplicates@Flatten@{
            Join[extraBlockRules,  $markdownParseBlockRules],
            oneTimeBlockRules
            },
        Apply[
           Alternatives,
           Verbatim/@
             Flatten@List@
               Replace[$markdownParseOneTimeElementRules, Except[_List]->{}]
           ]
         ],
      $markdownParseOneTimeBlockRules=
        oneTimeBlockRules,
      $markdownParseElementRules=
        DeleteCases[
          DeleteDuplicates@Flatten@{
              Join[extraElementRules, $markdownParseElementRules],
              oneTimeElementRules
              },
         Apply[
           Alternatives,
           Verbatim/@
             Flatten@List@
               Replace[$markdownParseOneTimeElementRules, Except[_List]->{}]
           ]
         ],
      $markdownParseOneTimeElementRules=
        oneTimeElementRules
      },
    Flatten@
      Replace[
        markdownFixedPointReplace[text, rules, $iteration], 
        {
          s_String:>
            If[rules===Automatic,
              Flatten@List@markdownParsePostProcess1[postProcessor][s],
              {s}
              ],
          l_List:>
            Replace[l,
              {
                s_String:>
                  If[rules===Automatic,
                    markdownParsePostProcess1[postProcessor][s],
                    Module[
                      {withHashes},
                      withHashes=
                        StringReplace[s, matchTempHashKey];
                      If[StringQ@withHashes,
                        withHashes,
                        Sequence@@Flatten@List@
                          Map[
                            If[StringQ@#,
                              #,
                              markdownPostProcess[postProcessor]@@#
                              ]&,
                            List@@withHashes
                            ]
                        ]
                      ]
                    ],
                (r_->s_):>
                    markdownPostProcess[postProcessor][r, s]
                },
              1
              ]
        }]
    ]


(* ::Subsubsection::Closed:: *)
(*markdownParsePostProcess1*)



recursiveParseMarkdown[postProcessor_][string_]:=
  postProcessor[
    "Text",
    DeleteCases[_String?(StringMatchQ[Whitespace])]@
      Flatten@List@
        markdownParse[postProcessor][string, $markdownParseElementRules]
    ]


splitWhiteSpaceBlocks[s_]:=
  Select[Not@*StringMatchQ[Whitespace]]@
    StringSplit[s,"\n\n"]


markdownParsePostProcess1[postProcessor_][s_]:=
  Module[{withHashes},
    withHashes=StringReplace[s, matchTempHashKey];
    If[StringQ@withHashes,
      SplitBy[
        recursiveParseMarkdown[postProcessor]/@
          splitWhiteSpaceBlocks[withHashes]//Flatten,
        Replace[
          {
            XMLElement[Alternatives@@$markdownParseNewLineElements, __]:>
              RandomReal[],
            _->True
            }
          ]
        ],
      Sequence@@
        Map[
          If[StringQ@#,
            markdownParsePostProcess1[postProcessor]@#,
            markdownPostProcess[postProcessor]@@#
            ]&,
          List@@withHashes
          ]
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*markdownParsePreProcess*)



markdownParsePreProcess[t_String]:=
  StringReplace[t,{
    ("\n"~~Whitespace?(StringFreeQ["\n"])~~EndOfLine)->"\n",
    "\[IndentingNewLine]"->"\n\t",
    "\t"->"    ",
    "\[SpanFromLeft]"->"\[Ellipsis]"
    }]


(* ::Subsubsection::Closed:: *)
(*MarkdownParse*)



MarkdownParse//Clear


Options[MarkdownParse]=
  {
    "StripMetaInformation"->True,
    "BlockRules"->{},
    "ElementRules"->{},
    "PostProcessor"->MarkdownElement
    };
MarkdownParse[
  _String?(StringLength[StringTrim[#]]==0&),
  ops:OptionsPattern[]
  ]:={};
MarkdownParse[
  s_String?(StringLength[StringTrim[#]]>0&&Not@FileExistsQ[#]&),
  ops:OptionsPattern[]
  ]:=
  Block[
    {
      $tmpMap=<||>,
      $timings
      },
    With[
      {
        sm=TrueQ@OptionValue["StripMetaInformation"],
        er=Replace[OptionValue["ElementRules"],Except[_?OptionQ]:>{}],
        br=Replace[OptionValue["BlockRules"],Except[_?OptionQ]:>{}],
        postProcessor=OptionValue["PostProcessor"]
        },
      markdownParseReinsertRefs@
        markdownParseReinsertXML[postProcessor]@
          markdownParse[postProcessor][
            markdownParsePreProcess[s],
            Automatic,
            br,
            er,
            If[sm, {$markdownParseMeta}, {}],
            {}
            ]
      ]
    ];
MarkdownParse[f:(_File|_String?FileExistsQ), ops:OptionsPattern[]]:=
  MarkdownParse[Import[f, "Text"], ops]


End[];



