(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Section:: *)
(*Git Connections*)



(* ::Subsection:: *)
(*Git*)



PackageScopeBlock[
	GitRun::usage="ProcessRun wrapper for git";
	]


PackageScopeBlock[
	GitCreate::usage="Creates a new repository";
	GitInit::usage="Initializes a git repository";
	GitClone::usage="Clones a repository";
	];


PackageScopeBlock[
	GitIgnore::usage="Adds to the .gitignore file for a directory";
	GitAdd::usage="Adds a file to the staging area of a  git repository";
	GitCommit::usage="Runs the commit command, using -a by default";
	]


PackageScopeBlock[
	GitStatus::usage="Gets the status of a repository";
	GitListTree::usage="Lists files on the tree";
	GitListTreeRecursive::usage="Lists files on the tree recursively";
	GitLog::usage="Gets the log of the git repo";
	GitConfig::usage="Sugar on the GitConfig tool";
	GitHelp::usage="Gets help from the git man pages";
	];


PackageScopeBlock[
	GitListRemotes::usage=
		"git remote -v show command";
	GitAddRemote::usage=
		"git remote add origin command";
	GitRemoveRemote::usage=
		"Removes remote";
	GitFetch::usage="git fetch";
	GitPush::usage="git push";
	GitPushOrigin::usage="git push origin master";
	GitPull::usage="git pull";
	GitPullOrigin::usage="git pull origin master";
	GitBranch::usage="git branch";
	];


PackageScopeBlock[
	GitRepositories::usage="Finds all the directories that support a git repo";
	]


$GitRepo::usage="The current git repo";
GitRepo::usage=
	"Returns: 
the arg if it is a repo, 
a github URL if the arg is github:<repo>, 
else None";
GitRepoQ::usage=
	"Returns true if the thing is a directory with a .git file";


$GitActions::usage=
	"The known actions for Git";
Git::usage=
	"A general head for all Git actions";


(* ::Subsection:: *)
(*SVN*)



PackageScopeBlock[
	SVNRun::usage="Runs SVN";
	SVNFileNames::usage="svn ls";
	SVNCheckOut::usage="Uses SVN to clone from a server";
	SVNExport::usage="Uses SVN to pull a single file from a server";
	]


$SVNActions::usage=
	"Known actions for SVN";
SVN::usage=
	"A general head for all SVN actions";


(* ::Subsection:: *)
(*GitHub*)



PackageScopeBlock[
	$GitHubUserName::usage=
		"The user's github username";
	$GitHubPassword::usage=
		"The user's github password";
	FormatGitHubPath::usage=""
	];


GitHubPath::usage=
	"Represents a github path";
GitHubRepoQ::usage=
	"Returns if the path could be a github repo";


PackageScopeBlock[
	GitHubCreate::usage="";
	GitHubDelete::usage="";
	GitHubDeployments::usage="";
	GitHubReleases::usage="";
	GitHubRepositories::usage="";
	]


GitHubSVN::usage="Formats a repo for SVN";
$GitHubActions::usage=
	"A collection of known calls for the GitHub function";
GitHub::usage=
	"A connection to the GitHub functinality";
GitHubImport::usage=
	"Imports and converts GitHub JSON";


Begin["`Private`"];


(* ::Subsection:: *)
(*Constants*)



If[Not@MatchQ[$GitRepo,_String?DirectoryQ],
	$GitRepo=None
	];


(* ::Subsection:: *)
(*Git*)



(* ::Subsubsection::Closed:: *)
(*GitRun*)



gitDoInDir[dir_String?DirectoryQ,cmd_]:=
	With[{d=ExpandFileName@dir},
			SetDirectory@d;
			With[{r=cmd},
				ResetDirectory[];
				r
				]
			];
gitDoInDir~SetAttributes~HoldRest;


ProcessRun;
Git::err=ProcessRun::err;


GitRun//Clear


GitRun[
	dir:_String?DirectoryQ|None|Automatic:None,
	cmd1_String?(Not@*DirectoryQ),
	cmd2___String
	]:=
	With[{d=Replace[dir,Automatic:>$GitRepo]},
		Replace[
			Git::err,
			_MessageName:>
				(Git::err=ProcessRun::err)
			];
		If[MatchQ[d,_String],
			ProcessRun[
				{"git",cmd1, cmd2}//
					Map[If[FileExistsQ@#, AbsoluteFileName@#, #]&],
				Git::err, 
				ProcessDirectory->AbsoluteFileName@d
				],
			ProcessRun[{"git",cmd1, cmd2}, 
				Git::err
				]
			]
		];
GitRun[
	dir:_String?DirectoryQ|None|Automatic:None,
	cmd1:_String?(Not@*DirectoryQ)|{__String},
	cmd2:_String|{__String}...
	]:=
	With[{
		d=Replace[dir,Automatic:>$GitRepo],
		cmdBits=
			Flatten[
				Riffle[Prepend["git"]@*Flatten@*List/@{cmd1, cmd2},"\n\n"],
				1
				]//
				Map[If[FileExistsQ@#, AbsoluteFileName@#, #]&]
		},
		Replace[
			Git::err,
			_MessageName:>
				(Git::err=ProcessRun::err)
			];
		If[MatchQ[d,_String],
			ProcessRun[
				cmdBits,
				Git::err,
				ProcessDirectory->AbsoluteFileName@d
				],
			ProcessRun[
				cmdBits,
				Git::err
				]
			]
		];
Git::nodir="`` is not a valid directory";
Git::nrepo="`` not a git repository";


(* ::Subsubsection::Closed:: *)
(*GitRepoQ*)



GitRepoQ[d:(_String|_File)?DirectoryQ]:=
	DirectoryQ@FileNameJoin@{d,".git"};
GitRepoQ[_]:=False


(* ::Subsubsection::Closed:: *)
(*GitAddGitIgnore*)



GitAddGitIgnore[
	dirB:_String?DirectoryQ|Automatic:Automatic,
	patterns:_String|{__String}:
		{
			".DS_Store"
			}
	]:=
	With[
		{dir=Replace[dirB, Automatic:>Directory[]]},
		If[GitRepoQ@dir,
			With[{f=OpenWrite[FileNameJoin@{dir,".gitignore"}]},
				WriteLine[f,
					StringJoin@Riffle[Flatten@{patterns},"\n"]
					];
				Close@f
				],
			$Failed
			]
		];


(* ::Subsubsection::Closed:: *)
(*GitAddGitExclude*)



GitAddGitExclude[
	dirB:_String?DirectoryQ|Automatic:Automatic,
	patterns:_String|{__String}:{"*.DS_Store"}
	]:=
	With[
		{dir=Replace[dirB, Automatic:>Directory[]]},
		If[GitRepoQ@dir,
			If[Not@DirectoryQ@FileNameJoin@{dir,".git","info"},
				CreateDirectory[FileNameJoin@{dir,".git","info"}]
				];
			With[{f=OpenWrite[FileNameJoin@{dir,".git","info","exclude"}]},
				WriteLine[f,
					StringJoin@Riffle[Flatten@{patterns},"\n"]
					];
				Close@f
				],
			$Failed
			]
		]


(* ::Subsubsection::Closed:: *)
(*GitInit*)



GitCreate[dir_String]:=
	With[{d=ExpandFileName@dir},
		Quiet@CreateDirectory@d;
		GitInit[d]
		];


GitInit[
	dir:_String?DirectoryQ|Automatic:Automatic,
	ignorePats:{___String}|None:None,
	excludePats:{___String}|None:None
	]:=
	With[{r=GitRun[dir,"init"]},
		If[ignorePats=!=None, 
			GitAddGitIgnore[dir, ignorePats]
			];
		If[excludePats=!=None,
			GitAddGitExclude[dir, excludePats];
			];
		r
		]


(* ::Subsubsection::Closed:: *)
(*GitClone*)



GitClone//Clear


GitClone[
	repo:_String|_File|_URL,
	dir:_String|_File|Automatic:Automatic,
	overrwriteTarget:True|False:False
	]:=
	With[{
		r=
			Replace[repo,{
				File[d_]:>
					If[GitRepoQ@d,
						d,
						GitRepo
						],
				URL[d_]:>
					d
				}],
		d=
			Replace[dir,
				Automatic:>
					FileNameJoin@{
						$TemporaryDirectory,
						Switch[repo,
							_String|_File,
								FileBaseName@repo,
							_URL,
								URLParse[repo,"Path"][[-1]]
							]
						}
				]
			},
		If[overrwriteTarget,
			Quiet@
				DeleteDirectory[d,DeleteContents->True]
			];
		CreateDirectory@d;
		GitRun[d, "clone", r, d];
		d
		];


(* ::Subsubsection::Closed:: *)
(*GitIgnore*)



GitIgnore[dir:_String?DirectoryQ|Automatic:Automatic,filePatterns:{___}]:=
	With[{d=Replace[dir,Automatic:>$GitRepo]},
		If[MatchQ[d,_String?DirectoryQ],
			With[{file=OpenAppend@FileNameJoin@{d,".gitignore"}},
				Do[
					WriteLine[file,f],
					{f,filePatterns}
					];
				Close@file;
				GitRun[d,"add",".gitignore"]
				],
			Message[GitRun::nodir,d];$Failed
			]
		];


(* ::Subsubsection::Closed:: *)
(*GitAdd*)



GitAdd[dir:_String?DirectoryQ|Automatic:Automatic,files___]:=
	GitRun[dir,"add",files];


(* ::Subsubsection::Closed:: *)
(*GitRemove*)



GitRemove[dir:_String?DirectoryQ|Automatic:Automatic,files___]:=
	GitRun[dir,"rm",files];


(* ::Subsubsection::Closed:: *)
(*GitRemoveRecursive*)



GitRemoveRecursive[dir:_String?DirectoryQ|Automatic:Automatic,files___]:=
	GitRun[dir,"rm","-r",files];


(* ::Subsubsection::Closed:: *)
(*GitRemoveCached*)



GitRemoveCached[dir:_String?DirectoryQ|Automatic:Automatic,files___]:=
	GitRun[dir,"rm",
		"--cached",
		files];


(* ::Subsubsection::Closed:: *)
(*GitRemoveCachedRecursive*)



GitRemoveCachedRecursive[dir:_String?DirectoryQ|Automatic:Automatic,files___]:=
	GitRun[dir,"rm",
		"-r",
		"--cached",
		files
		];


(* ::Subsubsection::Closed:: *)
(*GitCommit*)



Options[GitCommit]={Message->"Commited via Mathematica"};
GitCommit[dir:_String?DirectoryQ|Automatic:Automatic,
	opts___String,
	OptionsPattern[]]:=
	With[{squargs=
		If[
			Not@MemberQ[{opts},"-m"],
			Join[{opts},{"-m",OptionValue@Message}],
			{opts}]},
		GitRun[dir,"commit",Sequence@@squargs]
		];


(* ::Subsubsection::Closed:: *)
(*Git status*)



GitLog[dir:_String?DirectoryQ|Automatic:Automatic,
		pFlag_:"-p",entries_:"-2",opts___]:=
	GitRun[dir,"log",opts];


GitStatus[dir:_String?DirectoryQ|Automatic:Automatic]:=
	GitRun[dir,"status"];


(* ::Subsubsection::Closed:: *)
(*Git config and help*)



GitConfig[setting:_String:"--global",opts___String]:=
	GitRun["config",setting,opts];
GitConfig[setting:_String:"--global","Username"->name_]:=
	GitConfig[setting,"user.name",name];
GitConfig[setting:_String:"--global","UserEmail"->email_]:=
	GitConfig[setting,"user.email",email];
GitConfig[setting:_String:"--global","TextEditor"->editor_]:=
	GitConfig[setting,"core.editor",editor]
GitConfig[setting:_String:"--global",opts__Rule]:=
	StringJoin@
		Riffle[
			Cases[
				Table[
					GitConfig[setting,opt],
					{opt,{opts}}
					],
				_String
				],
			"\n"
			];


GitHelp[thing_String]:=
	GitRun["help",thing];


(* ::Subsubsection::Closed:: *)
(*Repository finding and stuff*)



GitRepositories[dirs:{(_String?DirectoryQ)..}|_String?DirectoryQ,depth:_Integer|\[Infinity]:2]:=
	ParentDirectory/@FileNames[".git",dirs,depth];


(* ::Subsubsection::Closed:: *)
(*GitRepo*)



(*Options declared later*)
GitRepo[repo_String?(StringMatchQ["github:*"]),ops:OptionsPattern[]]:=
	GitHubRepo[StringTrim[repo,"github:"],{"Username"->"",ops}];
GitRepo[repo:(_String|_File)?DirectoryQ]:=
	Replace[
		GitRepositories[repo,1],{
		{d_,___}:>d,
		_:>None
		}];
GitRepo[r:_String|_URL]:=
	With[{u=URLParse@r},
		If[u["Scheme"]===None,
			If[u["Domain"]===None,
				If[Length@u["Path"]<2||!StringMatchQ[u["Path"]//First,"*.*"],
					None,
					URLBuild@Append[u,"Scheme"->"https"]
					],
				URLBuild@Append[u,"Scheme"->"https"]
				],
			URLBuild@u
			]
		];
GitRepo[r_]:=None;
GitRepoQ[r:(_String|_File)?DirectoryQ]:=
	(GitRepo@r=!=None);


(* ::Subsubsection::Closed:: *)
(*ListRemotes*)



GitListRemotes[dir:_String?DirectoryQ|Automatic:Automatic]:=
	GitRun[dir,"remote","-v","show"]


(* ::Subsubsection::Closed:: *)
(*AddRemote*)



GitAddRemote//Clear


GitAddRemote[
	dir:_String?DirectoryQ|Automatic:Automatic,
	remoteName:_String?(Not@*DirectoryQ):"origin",
	remote:_String|_URL
	]:=
	GitRun[dir,
		"remote","add",remoteName,
		URLBuild@remote
		];


(* ::Subsubsection::Closed:: *)
(*RemoveRemote*)



GitRemoveRemote[
	dir:_String?DirectoryQ|Automatic:Automatic,
	remote:_String|_URL]:=
	GitRun[dir,
		"remote","rm","origin"
		];


(* ::Subsubsection::Closed:: *)
(*GitSetRemote*)



GitSetRemote[
	dir:_String?DirectoryQ|Automatic:Automatic,
	remoteName:_String?(Not@*DirectoryQ):"origin",
	origin:(_String|_GitHubPath)?GitHubRepoQ
	]:=
	Quiet@
		Check[
			GitAddRemote[dir, origin],
			GitRemoveRemote[dir, origin];
			GitAddRemote[dir, origin]
			];


(* ::Subsubsection::Closed:: *)
(*GirRealignRemotes*)



GitRealignRemotes[
	dir:_String?DirectoryQ|Automatic:Automatic,
	remoteName:_String?(Not@*DirectoryQ):"origin",
	branchName:_String?(Not@*DirectoryQ):"master"
	]:=
	(
		Git["Fetch", dir];
		Git["Reset",dir,URLBuild@{remoteName, branchName}];
		Git["Checkout",dir,URLBuild@{remoteName, branchName}];
		)


(* ::Subsubsection::Closed:: *)
(*Push*)



Options[GitPush]={
	"Username"->
		None,
	"Password"->
		None,
	"Force"->False
	};
GitPush[
	dir:_String?DirectoryQ,
	loc_String,
	branch:_String:"master",
	ops:OptionsPattern[]]:=
	GitRun[dir,
		"push",
		If[TrueQ@OptionValue["Force"],
			"-f",
			Sequence@@{}
			],
		loc,
		branch];


(* ::Subsubsection::Closed:: *)
(*Fetch*)



GitFetch[
	dir:_String?DirectoryQ
	]:=
	GitRun[
		dir,
		"fetch"
		];


(* ::Subsubsection::Closed:: *)
(*Reset*)



GitReset[
	dir:_String?DirectoryQ,
	src___
	]:=
	GitRun[
		dir,
		"reset",
		src
		];


(* ::Subsubsection::Closed:: *)
(*Checkout*)



GitCheckout//Clear


GitCheckout[
	dir:_String?DirectoryQ,
	args__
	]:=
	GitRun[dir,
		"checkout",
		args
		]


(* ::Subsubsection::Closed:: *)
(*GitCheckoutTracked*)



GitCheckoutTracked[
	dir:_String?DirectoryQ,
	args__
	]:=
	GitRun[
		dir,
		"checkout",
		"-t",
		args
		];


(* ::Subsubsection::Closed:: *)
(*Pull*)



Options[GitPull]={
	"Username"->
		None,
	"Password"->
		None
	};
GitPull[
	dir:_String?DirectoryQ,
	loc_String,
	branch:_String:"master",
	ops:OptionsPattern[]]:=
	GitRun[dir,
		"pull",
		loc,
		branch];


(* ::Subsubsection::Closed:: *)
(*PullOrigin*)



GitPullOrigin[dir:_String?DirectoryQ|Automatic:Automatic]:=
	GitPull[dir,"origin","master"]


(* ::Subsubsection::Closed:: *)
(*PushOrigin*)



GitPushOrigin[dir:_String?DirectoryQ|Automatic:Automatic,
	force:True|False:False
	]:=
	GitPush[dir,
		If[force,"-f",Sequence@@{}],
		"origin",
		"master"
		];


(* ::Subsubsection::Closed:: *)
(*GetPushURL*)



GitGetPushURL[
	dir:_String?DirectoryQ|Automatic:Automatic,
	rem:_String?(Not@*DirectoryQ):"origin"
	]:=
	With[
		{
			rems=
				#[[1]]->#[[2]]&/@
					Cases[
						Partition[
							Append[""]@
							StringSplit[
								Replace[
									Git["ListRemotes", dir],
									Except[_String]->""
									]
								],
							3
							],
						{_, _, _?(StringContainsQ["push"])}
						]//Association
			},
		If[Length@rems>0,
			rem->rems[rem],
			URL@GitHubPath[FileBaseName@Replace[dir, Automatic:>rem]]
			]
		]


(* ::Subsubsection::Closed:: *)
(*GetFetchURL*)



GetFetchURL//Clear


GitGetFetchURL[
	dir:_String?DirectoryQ|Automatic:Automatic,
	rem:_String?(Not@*DirectoryQ):"origin"
	]:=
	With[
		{
			rems=
				#[[1]]->#[[2]]&/@
					Cases[
						Partition[
							Append[""]@
							StringSplit[
								Replace[Git["ListRemotes", dir],
									Except[_String]->""
									]
								],
							3
							],
						{_, _, _?(StringContainsQ["fetch"])}
						]//Association
			},
		If[Length@rems>0,
			rem->rems[rem],
			URL@GitHubPath[FileBaseName@Replace[dir, Automatic:>rem]]
			]
		]


(* ::Subsubsection::Closed:: *)
(*ListTree*)



Options[GitListTree]=
	{
		"NameOnly"->True
		};
GitListTree[
	dir:_String?DirectoryQ|Automatic:Automatic,
	branch:_String:"master",
	ops:OptionsPattern[]
	]:=
	StringSplit[
		GitRun[dir,"ls-tree",branch,
			If[OptionValue["NameOnly"]//TrueQ,
				"--name-only",
				Sequence@@{}
				]
			],
		"\n"
		];


(* ::Subsubsection::Closed:: *)
(*ListTreeRecursive*)



Options[GitListTreeRecursive]=
	Options@GitListTree;
GitListTreeRecursive[
	dir:_String?DirectoryQ|Automatic:Automatic,
	branch:_String:"master",
	ops:OptionsPattern[]
	]:=
	StringSplit[
		GitRun[dir,"ls-tree","-r",branch,
			If[OptionValue["NameOnly"]//TrueQ,
				"--name-only",
				Sequence@@{}
				]
			],
		"\n"
		]


(* ::Subsubsection::Closed:: *)
(*RefLog*)



GitRefLog[
	dir:_String?DirectoryQ|Automatic:Automatic,
	args___
	]:=
	GitRun[dir,"reflog"]


(* ::Subsubsection::Closed:: *)
(*RefLogExpire*)



GitRefLogExpire[
	dir:_String?DirectoryQ|Automatic:Automatic,
	expireTime_:"--all"
	]:=
	GitRun[dir,"reflog","expire",expireTime]


(* ::Subsubsection::Closed:: *)
(*Clean*)



Options[GitClean]=
	{
		"reflogExpire"->Automatic,
		"reflogExpireUnreachable"->Automatic,
		"rerereresolved"->Automatic,
		"rerereunresolved"->Automatic,
		"pruneExpire"->Automatic
		}
GitClean[
	dir:_String?DirectoryQ|Automatic:Automatic,
	args___String,
	ops:OptionsPattern[]
	]:=
	With[
		{
			conf=
				Map[
					StringJoin@
						Prepend[Insert[List@@ToString/@#," ",2],"--gc."]&, 
					Flatten@{ops}
					]
				},
			GitRun[dir,"gc",args,Sequence@@conf]
		]


(* ::Subsubsection::Closed:: *)
(*GitCleanEverything*)



(*(* Taken from here: https://stackoverflow.com/a/14729486 *)
GitCleanEverything[
	dir:_String?DirectoryQ|Automatic:Automatic,
	args___
	]:=
	GitClean[dir,"\"$@\"",args,
		{
			"reflogExpire"\[Rule]0,
			"reflogExpireUnreachable"\[Rule]0,
			"rerereresolved"\[Rule]0,
			"rerereunresolved"\[Rule]0,
			"pruneExpire"\[Rule]"now"
			}
		]*)


(* ::Subsubsection::Closed:: *)
(*GitFilterBranch*)



GitFilterBranch//Clear


GitFilterBranch[
	dir:_String?DirectoryQ|Automatic:Automatic,
	filterType_String?(StringStartsQ["--"]),
	filterCMD_String,
	args___
	]:=
	GitRun[dir,"filter-branch",
		If[StringQ@branch,branch,Sequence@@{}],
		filterType, 
		"''``''"~TemplateApply~filterCMD,
		args
		];


(* ::Subsubsection::Closed:: *)
(*GitFilterTree*)



GitFilterTree//Clear


GitFilterTree[
	dir:_String?DirectoryQ|Automatic:Automatic,
	filterCMD_String,
	args___
	]:=
	GitFilterBranch[dir, "--tree-filter",filterCMD, args];


(* ::Subsubsection::Closed:: *)
(*Prune*)



GitPrune[
	dir:_String?DirectoryQ|Automatic:Automatic,
	args___String,
	ops:OptionsPattern[]
	]:=
	GitRun[dir,"prune",args,
		Sequence@@
			Map[
				StringJoin[Flatten@{"--",Insert[List@@ToString/@#," ",2]}]&,
				Flatten@{ops}
				]
		]


(* ::Subsubsection::Closed:: *)
(*Branch*)



GitBranch[dir:_String?DirectoryQ|Automatic:Automatic,
	args___
	]:=
	GitRun[dir,"branch",args]


(* ::Subsubsection::Closed:: *)
(*WipeTheSlate*)



GitWipeTheSlate//Clear


(* Take from here: https://stackoverflow.com/a/26000395 *)
GitWipeTheSlate[
	dir:_String?DirectoryQ|Automatic:Automatic
	]:=
	(
		GitCheckout[dir, "--orphan", "latest_branch"];
		GitAdd[dir, "-A"];
		GitCommit[dir, "-a",
			Message->"Wiped the slate clean"
			];
		GitBranch[dir, "-D", "master"];
		GitBranch[dir, "-m", "master"];
		)


(* ::Subsubsection::Closed:: *)
(*Git*)



$GitActions=
	<|
		"Init"->
			GitInit,
		"Clone"->
			GitClone,
		"Ignore"->
			GitIgnore,
		"AddGitIgnore"->
			GitAddGitIgnore,
		"AddGitExclude"->
			GitAddGitExclude,
		"Add"->
			GitAdd,
		"Remove"->
			GitRemove,
		"RemoveCached"->
			GitRemoveCached,
		"RemoveRecursive"->
			GitRemoveRecursive,
		"RemoveCachedRecursive"->
			GitRemoveCachedRecursive,
		"Commit"->
			GitCommit,
		"ListRemotes"->
			GitListRemotes,
		"AddRemote"->
			GitAddRemote,
		"RemoveRemote"->
			GitRemoveRemote,
		"Fetch"->
			GitFetch,
		"Reset"->
			GitReset,
		"Checkout"->
			GitCheckout,
		"CheckoutTracked"->
			GitCheckoutTracked,
		"Pull"->
			GitPull,
		"PullOrigin"->
			GitPullOrigin,
		"Push"->
			GitPush,
		"PushOrigin"->
			GitPushOrigin,
		"GetPushURL"->
			GitGetPushURL,
		"GetFetchURL"->
			GitGetFetchURL,
		"Repositories"->
			GitRepositories,
		"Log"->
			GitLog,
		"Status"->
			GitStatus,
		"ListTree"->
			GitListTree,
		"ListTreeRecursive"->
			GitListTreeRecursive,
		"RefLog"->
			GitRefLog,
		"RefLogExpire"->
			GitRefLogExpire,
		"Clean"->
			GitClean,
		"WipeTheSlate"->
			GitWipeTheSlate,
		"FilterBranch"->
			GitFilterBranch,
		"FilterTree"->
			GitFilterTree,
		"Config"->
			GitConfig,
		"Help"->
			GitHelp
		|>;


$gitactions:=
	KeyMap[ToLowerCase]@$GitActions;


PackageAddAutocompletions[
	"Git",
	{
		Keys@$GitActions
		}
	]


Git[
	command_?(KeyMemberQ[$gitactions,ToLowerCase@#]&),
	args___
	]:=
	With[{cmd=$gitactions[ToLowerCase[command]]},
		With[{r=cmd[args]},
			r/;Head[r]=!=cmd
			]
		];
Git[
	cmd_String,
	args___
	]:=
	GitRun[cmd,args];


(* ::Subsection:: *)
(*SVN*)



(* ::Subsubsection::Closed:: *)
(*Run*)



Options[SVNRun]=
	Normal@Merge[{
		Options@ProcessRun,
		"TrustServer"->False
		},
		First
		];
SVNRun[cmd_,
	kwargs:(_Rule|_RuleDelayed|_String)...,
	repo_String,
	others:(_Rule|_RuleDelayed|_String)...,
	ops:OptionsPattern[]]:=
	ProcessRun[
		{
			"svn",
			cmd,
			kwargs,
			If[OptionValue@"TrustServer","--trust-server-cert",Nothing],
			If[FileExistsQ@repo,ExpandFileName@repo,repo],
			others
			},
		Evaluate[
			Sequence@@
			FilterRules[{ops},
					Options@ProcessRun
					]
			]
		];


(* ::Subsubsection::Closed:: *)
(*FileNames*)



Options[SVNFileNames]=
	Options@SVNRun;
SVNFileNames[repo_,ops:OptionsPattern[]]:=
	Replace[SVNRun["ls",repo,ops],
		fn_String:>
			With[{lines=StringSplit[fn,"\n"]},
				If[FileExistsQ@repo,
					FileNameJoin@{repo,#}&/@lines,
					URLBuild@{repo,#}&/@lines
					] 
				]
		];


(* ::Subsubsection::Closed:: *)
(*CheckOut*)



Options[SVNCheckOut]=
	Options@SVNRun;
SVNCheckOut[
	repo_,
	dir:_String|Automatic:Automatic,
	ops:OptionsPattern[]]:=
	With[{pulldir=
		Replace[dir,{
			s_String?(Not@*FileExistsQ):>
				(If[FileExtension@s=="",
					CreateDirectory@s
					];
					s),
			Automatic:>
				With[{d=FileNameJoin@{$TemporaryDirectory,FileNameTake@repo}},
					If[FileExtension@d=="",
						Quiet@DeleteDirectory[d,DeleteContents->True];
						CreateDirectory@d
						];
					d
					]
			}]},
	SVNRun["checkout",
		repo,
		ExpandFileName@pulldir,
		ops
		];
	pulldir
	]


(* ::Subsubsection::Closed:: *)
(*Export*)



Options[SVNExport]=
	Normal@Merge[{
		Options@SVNRun,
		OverwriteTarget->False
		},
		Last];
SVNExport[repo_,file:_String|Automatic:Automatic,ops:OptionsPattern[]]:=
	With[{f=
		Replace[file,{
				Automatic:>
					FileNameJoin@{$TemporaryDirectory,FileNameTake@repo}
				}]},
		If[OptionValue@OverwriteTarget,Quiet@DeleteFile@f];
		SVNRun["export",
			repo,
			ExpandFileName@f,
			FilterRules[{ops},Options@SVNRun]
			];
		f
		]


(* ::Subsubsection::Closed:: *)
(*SVN*)



$SVNActions=
	<|
		"FileNames"->
			SVNFileNames,
		"CheckOut"->
			SVNCheckOut,
		"Export"->
			SVNExport
		|>;


$svnactions:=
	KeyMap[ToLowerCase]@$SVNActions


PackageAddAutocompletions[
	"SVN",
	{
		Keys[$SVNActions]
		}
	]


SVN[
	command_?(KeyMemberQ[$svnactions,ToLowerCase@#]&),
	args___
	]:=
	With[{cmd=$svnactions[ToLowerCase[command]]},
		With[{r=cmd[args]},
			r/;Head[r]=!=cmd
			]
		];
SVN[
	cmd_String,
	args___
	]:=
	SVNRun[cmd,args];


(* ::Subsection:: *)
(*GitHub*)



(* ::Subsubsection::Closed:: *)
(*$GitHubConfig*)



If[Not@ValueQ@$GitHubConfig,
	$GitHubConfig:=
		Replace[
			Do[
				With[{f=PackageFilePath["Private", d]},
					If[FileExistsQ@f,
						$GitHubConfig=
							Replace[Import@f,
								{ 
									o_?OptionQ:>Association@o,
									_-><||>
									}
								];
						Break[]
						]
					],
				{d,
					{
						"GitHubConfig.m",
						"GitHubConfig.wl"
						}
					}
				],
			Null-><||>
			]
	]


(* ::Subsubsection::Closed:: *)
(*$GitHubUserName*)



If[Not@ValueQ@$GitHubUserName,
	$GitHubUserName:=
		Replace[
			$KeyChain["$GitHubUserName"],
			_Missing:>
				$GitHubConfig["Username"]
			]
	];


(* ::Subsubsection::Closed:: *)
(*$GitHubPassword*)



$GitHubStorePassword:=
	Lookup[$GitHubConfig, "StorePassword", False]


GitHubPassword[s_String]:=
	With[
		{
			base=
				Replace[gitHubPasswordCache[s],
					Except[_String]:>KeyChainGet[{"github.com",	s}, False]
					]
			},
		If[StringQ@base,
			base,
			If[$GitHubStorePassword,
				KeyChainGet[{"github.com",	s}, True],
				AuthenticationDialog[
					Dynamic@$ghauth,
					"",
					None,
					{{"github.com",Automatic},s}
					];
				If[AssociationQ[$ghauth]&&StringQ@$ghauth["github.com"][[2]],
					gitHubPasswordCache[s]=
						$ghauth["github.com"][[2]],
					gitHubPasswordCache[s]=None
					];
				Clear@$ghauth;
				gitHubPasswordCache[s]
				]
			]
		];
GitHubPassword[Optional[Automatic,Automatic]]:=
	GitHubPassword[$GitHubUserName];
Clear@$GitHubPassword;
$GitHubPassword:=
	GitHubPassword[Automatic];


(*If[ValueQ@$GitHubUserName&&!KeyMemberQ[$gitHubPassCache,$GitHubUserName],
	$gitHubPassCache[$GitHubUserName]:=
		Do[
			With[{f=
				FileNameJoin@{
					$PackageDirectory,
					"Private",
					d}
				},
				If[FileExistsQ@f,
					Replace[Import@f,
						s_String:>
							($gitHubPassCache[$GitHubUserName]=s);
						];
					Return[True]
					]
				],
			{d,
				{
					"GitHubPassword.m",
					"GitHubPassword.wl"
					}
				}
			]
	];*)


(* ::Subsubsection::Closed:: *)
(*$GitHubSSHConnected*)



$GitHubSSHConnected:=
	($GitHubSSHConnected=
		Quiet[ProcessRun[{"ssh","-T","git@github.com"}];
			Length@$MessageList===0
			]
		);


(* ::Subsubsection::Closed:: *)
(*GitHubPath*)



$GitHubEncodePassword:=
	TrueQ@$GitHubConfig["EncodePassword"];


Options[GitHubPath]={
	"Username"->Automatic,
	"Password"->None
	};
Options[FormatGitHubPath]=
	Options[GitHubPath];
FormatGitHubPath[path__String,ops:OptionsPattern[]]:=
	URLBuild@<|
		"Scheme"->
			"https",
		"Domain"->
			"github.com",
		If[$GitHubEncodePassword||
			MatchQ[OptionValue@"Password",_String|Automatic],
			"Username"->
				Replace[OptionValue["Username"],
					{
						Automatic:>
							Replace[OptionValue@"Password",
								Automatic|_String:>$GitHubUserName
								],
						Except[_String]->None
						}
					],
			Nothing
			],
		If[$GitHubEncodePassword||
			MatchQ[OptionValue@"Password",_String|Automatic],
			"Password"->
				Replace[
					Replace[OptionValue["Username"],{
						Automatic:>$GitHubUserName,
						Except[_String]->None
						}],
					s_String:>
						Replace[OptionValue["Password"],
							Automatic:>GitHubPassword[s]
							]
					],
			Nothing
			],
		"Path"->{
			Replace[OptionValue@"Username",
				Automatic:>$GitHubUserName
				],
			path
			}
		|>;
GitHubPath[path__String,ops:OptionsPattern[]]/;(TrueQ@$GitHubPathFormat):=
	FormatGitHubPath[path,ops];


GitHubPath/:
	Normal[GitHubPath[repos___,ops__?OptionQ]]:=
		{
			FirstCase[{ops},
				("Username"->u_):>u,
				$GitHubUserName
				],
			repos
			};
GitHubPath/:
	URL[GitHubPath[path__String,ops:OptionsPattern[]]]:=
		FormatGitHubPath[path,ops]


(* ::Subsubsection::Closed:: *)
(*GitHubSVN*)



Options[GitHubSVN]=
	Options[GitHubPath];
Options[formatGitHubSVN]=Options[GitHubSVN];
formatGitHubSVN[
	root_String?(Not@*GitHubRepoQ),
	subparts___String,
	ops:OptionsPattern[]
	]:=
	URLBuild@{
		FormatGitHubPath[root,ops],
		"trunk",
		subparts
		};
GitHubSVN[path__String,ops:OptionsPattern[]]/;(TrueQ@$GitHubRepoFormat):=
	formatGitHubSVN[path,ops]


(* ::Subsubsection::Closed:: *)
(*GitHubPathParse*)



GitHubPathParse[path:_String|_URL]:=
	If[GitHubPathQ[path],
		Replace[
			DeleteCases[""]@
				URLParse[path,"Path"],{
			{user_,parts__}|
			{user_,parts__}:>
				GitHubPath[parts,"Username"->user]
			}],
		$Failed
		];


(* ::Subsubsection::Closed:: *)
(*GitHubRepoParse*)



GitHubRepoParse[path:_String|_URL]:=
	If[GitHubPathQ[path],
		Replace[
			DeleteCases[""]@
				URLParse[path,"Path"],{
			{"repos",user_,parts__}|
			{user_,parts__,"releases"|"deployments"}|
			{user_,parts__,"releases"|"deployments","tag",___}:>
				GitHubPath[parts,"Username"->user]
			}],
		$Failed
		];


(* ::Subsubsection::Closed:: *)
(*GitHubPathQ*)



GitHubPathQ[path:_String|_URL]:=
	With[{p=URLParse[path]},
		MatchQ[p["Scheme"],"http"|"https"]&&
		p["Domain"]=="github.com"&&
		Length@p["Path"]>0
		];
GitHubPathQ[_GitHubPath]:=
	True;


(* ::Subsubsection::Closed:: *)
(*GitHubRepoQ*)



GitHubRepoQ[path:_String|_URL]:=
	With[{p=URLParse[path]},
		MatchQ[p["Scheme"],"http"|"https"]&&
		p["Domain"]=="github.com"&&
		Length@p["Path"]>0&&
		!MatchQ[p["Path"],
			{"repos",__}|
			{__,"releases"|"deployments"}|
			{__,"releases"|"deployments","tag",___}
			]
		];
GitHubRepoQ[GitHubPath[path__String,___?OptionQ]]:=
	!MatchQ[{path},
		{"repos",__}|
		{__,"releases"|"deployments"}|
		{__,"releases"|"deployments","tag",___}
		];
GitHubRepoQ[_]:=False


(* ::Subsubsection::Closed:: *)
(*GitHubReleaseQ*)



GitHubReleaseQ[GitHubPath[p__String,___?OptionQ]]:=
	MatchQ[{p},
		{__,"releases"}|
		{__,"releases","tag",_}
		];
GitHubReleaseQ[path:_String|_URL]:=
	If[GitHubPathQ@path,
		Replace[GitHubPathParse[path],{
			g_GitHubPath:>
				GitHubReleaseQ@g,
			_->False
			}],
		False
		];


(* ::Subsubsection::Closed:: *)
(*GitHubQuery*)



GitHubQuery[
	path:_?(MatchQ[Flatten@{#},{___String}]&):{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>]:=
	HTTPRequest[
		URLBuild@<|
			"Scheme"->"https",
			"Domain"->"api.github.com",
			"Path"->Flatten@{path},
			"Query"->{query}
			|>,
		headers
		];


(* ::Subsubsection::Closed:: *)
(*Auth*)



(*GitHubAuth[
	user:_String|Automatic:Automatic,
	scopes:_String|{__String}:{"public_repo"}]:=
	GitHubQuery[
		Replace[user,Automatic:>$GitHubUserName],
		<|
			"Headers"\[Rule]{
				"Authorization"\[Rule]"token OAUTH-TOKEN",
				"
				}
			|>
		];*)


(* ::Subsubsection::Closed:: *)
(*AuthHeader*)



GitHubAuthHeader[
	user:_String|Automatic:Automatic,
	password:_String|Automatic:Automatic
	]:=
	StringJoin@{
		"Basic ",
		Developer`EncodeBase64@
			StringJoin@{
				Replace[user,
					Automatic:>
						$GitHubUserName
					],
				":",
				Replace[password,
					Automatic:>
						GitHubPassword[user]
					]
				}
		};


(* ::Subsubsection::Closed:: *)
(*UserAPI*)



GitHubUserAPI[
	type:"users"|"org":"users",
	user:_String|Automatic:Automatic,
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubQuery[{
		type,
		Replace[user,Automatic:>$GitHubUserName],
		Flatten@path
		},
		query,
		headers
		];


(* ::Subsubsection::Closed:: *)
(*ReposAPI*)



GitHubReposAPI[
	repo_GitHubPath?GitHubRepoQ,
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubQuery[
		Flatten@{
			"repos",
			Sequence@@Normal@repo,
			path
			},
		query,
		headers
		];
GitHubReposAPI[
	s_String?GitHubRepoQ,
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubReposAPI[
		GitHubPathParse[s],
		path,
		query,
		headers
		];


(* ::Subsubsection::Closed:: *)
(*Repositories*)



GitHubRepositories[
	type:"user"|"org":"user",
	user:_String|Automatic:Automatic,
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	GitHubUserAPI[type,user,"repos",query,headers];


(* ::Subsubsection::Closed:: *)
(*Create*)



Options[GitHubCreate]=
	{
		"Username"->Automatic,
		"Password"->Automatic,
		"Description"->None,
		"HomePage"->None
		};
GitHubCreate[
	repo_String,
	ops:OptionsPattern[]
	]:=
	With[{u=Replace[OptionValue["Username"],Automatic:>$GitHubUserName]},
		GitHubQuery[
			{
				"user",
				"repos"
				},
			<|
				"Method"->"POST",
				"Body"->
					ExportString[
						Map[ToLowerCase[First@#]->Last@#&,
							DeleteCases[_->None]@
								FilterRules[
									{
										"Name"->repo,
										ops
										},
									Except["Password"]
									]
							],
						"JSON"
						],
				"Headers"->{
					"Authorization"->
						GitHubAuthHeader[
							u,
							OptionValue["Password"]
							]
						}
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*Delete*)



Options[GitHubDelete]=
	{
		"Username"->Automatic,
		"Password"->Automatic
		};
GitHubDelete[
	repo_GitHubPath?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	With[{r=Normal@repo},
		GitHubReposAPI[
			repo,
			<|
				"Method"->"DELETE",
				"Headers"->{
					"Authorization"->
						GitHubAuthHeader[
							First@r,
							OptionValue["Password"]
							]
						}
				|>
			]
		];
GitHubDelete[
	s_String?GitHubRepoQ,
	ops:OptionsPattern[]
	]:=
	Block[{$GitHubPathFormat=False},
		GitHubDelete[GitHubRepoParse@s,ops]
		];
GitHubDelete[
	s_String?(
		URLParse[#,"Scheme"]===None&&
		Length@URLParse[#,"Path"]===1&),
	ops:OptionsPattern[]
	]:=
	GitHubDelete[
		GitHubPath[s,
			FilterRules[{ops},Options@GitHubPath]
			],
		ops]


(* ::Subsubsection::Closed:: *)
(*CreateReadme*)



GitHubCreateReadme[repo_?GitRepoQ,readmeText:_String:""]:=
	With[{o=
		OpenWrite@
			FileNameJoin@{
				repo,
				"README.md"
				}
		},
		WriteString[o,readmeText];
		Close@o
		];


(* ::Subsubsection::Closed:: *)
(*Releases*)



GitHubReleases[
	repo:(_GitHubPath|_String)?GitHubRepoQ,
	identifier:_String|_Integer|None:None]:=
	GitHubReposAPI[
		repo,
		Switch[identifier,
			None,
				"releases",
			_Integer|_?(StringMatchQ[ToLowerCase@#,"latest"]&),
				{"releases",ToLowerCase@ToString@identifier},
			_,
				{"releases","tags",ToLowerCase@ToString@identifier}
			]
		];
GitHubReleases[
	repo:(_GitHubPath|_String)?GitHubReleaseQ,
	identifier:_String|_Integer|None:None
	]:=
	Replace[Replace[repo,s_String:>GitHubPathParse[s]],{
		GitHubPath[s__,"releases","tag",tag_String,o__?OptionQ]:>
			GitHubReleases[GitHubPath[s,o],tag],
		GitHubPath[s__,"releases",o__?OptionQ]:>
			GitHubReleases[GitHubPath[s,o],identifier]
		}]


(* ::Subsubsection::Closed:: *)
(*Deployments*)



GitHubDeployments[repo:(_GitHubRepo|_String)?GitHubRepoQ,
	identifier:_String|_Integer|None
	]:=
	GitHubReposAPI[repo,
		If[identifier===None,
			"deployments",
			{"deployments",ToLowerCase@ToString@identifier}
			]
		];


(* ::Subsubsection::Closed:: *)
(*GitHubClone *)



GitHubClone[
	repo:(_String|_GitHubPath)?GitHubRepoQ,
	dir:_String|Automatic:Automatic
	]:=
	Quiet[
		Replace[
			GitClone[
				If[MatchQ[repo,_GitHubPath],
					URL@repo,
					repo
					],
				dir
				],
			d:Except[_String?GitRepoQ]:>(
				SVNExport[
					If[MatchQ[repo,_GitHubPath],
						URL@repo,
						repo
						],
					dir,
					"TrustServer"->True
					]
				)
			],
	GitRun::err
	];
GitHubClone[
	repo:(_String|_GitHubPath)?GitHubReleaseQ,
	dir:_String|Automatic:Automatic
	]:=
	With[{release=
		GitHubImport["Releases",
			repo,
			"latest"
			]["Content"]
		},
		If[AssociationQ@release,
			If[Length@release["Assets"]>0,
				With[{url=
					release[["Assets",-1,"BrowserDownloadURL"]]
					},
					URLDownload[url,
						FileNameJoin@{
							Replace[dir,Automatic:>$TemporaryDirectory],
							URLParse[url,"Path"][[-1]]
							}
						]
					],
				ExtractArchive[
					URLDownload[
						release["ZipballURL"],
						FileNameJoin@{
							$TemporaryDirectory,
							URLParse[release["ZipballURL"],"Path"][[-1]]
							}
						],
					Replace[dir,
						Automatic:>
							$TemporaryDirectory
						]
					]
				],
			$Failed
			]
		]


(* ::Subsubsection::Closed:: *)
(*GitHubConfigure*)



GitHubConfigure[
	dirBase:_String?DirectoryQ|Automatic,
	repo:_String?GitHubRepoQ|_GitHubPath,
	ignorePats:{___String}|None:None,
	excludePats:{___String}|None:None
	]:=
	Module[{repoExistsQ, dir=Replace[dirBase, Automatic:>Directory[]]},
		If[!GitRepoQ@dir,
			GitInit[dir, ignorePats, excludePats];
			GitSetRemote[dir, repo];
			repoExistsQ=Between[URLRead[repo,"StatusCode"],{200,299}];
			If[repoExistsQ, GitRealignRemotes[dir]]
			];
		If[GitRepoQ@dir,
			If[!ValueQ[repoExistsQ],
				repoExistsQ=Between[URLRead[repo,"StatusCode"],{200,299}]
				];
			If[!repoExistsQ,
				GitHubImport["Create",
					URLParse[repo, "Path"][[-1]]
					];
				GitSetRemote[dir, repo]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*GitHubPush*)



GitHubPush[
	dir:_String?GitRepoQ,
	repo:_String|_GitHubPath|Automatic:Automatic
	]:=
	Replace[repo,{
		Automatic:>
			Replace[GitGetPushURL[dir],
				{
					s_String:>
						Git["Push", dir, s],
					(r_->s_):>
						Quiet@
							Check[
								Git["Push", dir, r, "master"],
								Git["Push", s]
								]
					}
				],
		s_String?(URLParse[#, "Scheme"]===None&):>
			Quiet@
				Check[
					Git["Push", dir, s, "master"],
					Git["Push", dir, URL@GitHubPath[s]]
					],
		s_String:>
			Git["Push", dir, s]
		}]


(* ::Subsubsection::Closed:: *)
(*GitHub*)



$GitHubActions=
	<|
		"Push"->
			GitHubPush,
		"Configure"->
			GitHubConfigure,
		"Repositories"->
			GitHubRepositories,
		"Clone"->
			GitHubClone,
		"Create"->
			GitHubCreate,
		"Delete"->
			GitHubDelete,
		"CreateReadme"->
			GitHubCreateReadme,
		"Releases"->
			GitHubReleases,
		"Deployments"->
			GitHubDownloads
		|>;


$githubactions:=
	KeyMap[ToLowerCase]@$GitHubActions


PackageAddAutocompletions[
	"GitHub",
	{
		Keys[$GitHubActions]
		}
	]


GitHub[
	command_?(KeyMemberQ[$githubactions,ToLowerCase@#]&),
	args___
	]:=
	Block[{$GitHubRepoFormat=True},
		With[{cmd=$githubactions[ToLowerCase@command]},
			With[{r=cmd[args]},
				Replace[r,
					h_HTTPRequest:>
						URLRead[h]
					]/;Head[r]=!=cmd
				]
			]
		];


GitHub[
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	Block[{$GitHubRepoFormat=True},
		URLRead[
			GitHubQuery[
				path,
				query,
				headers
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*GitHubImport*)



GitHubImport[a_Association]:=
	Association@
		KeyValueMap[
			StringReplace[
				StringJoin[
					Replace[
						HoldPattern[Capitalize[s_String]]:>
							(ToUpperCase@StringTake[s,1]<>StringDrop[s,1])
						]@*Capitalize/@StringSplit[#,"_"]
					],{
				"Id"~~EndOfString->"ID",
				"Url"->"URL",
				"Html"->"HTML"
				}]->
				Which[
					StringEndsQ[#,"_at"],
						DateObject@#2,
					StringEndsQ[#,"url"],
						URL[#2],
					True,
						GitHubImport@#2
					]&,
		a
		];
GitHubImport[h_HTTPResponse]:=
	<|
		"StatusCode"->
			h["StatusCode"],
		"Content"->
			If[MatchQ[h["StatusCode"],0|(_?(Between@{200,299}))],
				GitHubImport@Import[h,"RawJSON"],
				$Failed
				]
		|>;
GitHubImport[s_String]:=
	s;
GitHubImport[l_List]:=
	GitHubImport/@l;
GitHubImport[e_]:=
	e


GitHubImport[
	command_?(KeyMemberQ[$githubactions,ToLowerCase@#]&),
	args__
	]:=
	With[{gh=GitHub[command,args]},
		GitHubImport[gh]/;Head[gh]=!=GitHub
		]
GitHubImport[
	path:{___String}|_String:{},
	query:(_String->_)|{(_String->_)...}:{},
	headers:_Association:<||>
	]:=
	With[{gh=GitHub[path,query,headers]},
		GitHubImport[gh]/;Head[gh]=!=GitHub
		]


End[];



