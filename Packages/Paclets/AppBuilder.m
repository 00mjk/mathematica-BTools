(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Section:: *)
(*AppBuilder*)



(* ::Subsubsection::Closed:: *)
(*Find*)



$AppDirectoryRoot::usage="The directory root for finding apps";
$AppDirectoryName::usage="The basic extension to a directory for locating apps";
$AppDirectory::usage="Joins the root and name";
AppPath::usage=
	"A path parser for a given app name";


AppNames::usage="Finds the names of apps matching a pattern";
AppFileNames::usage="FileNames on an app";
AppPackage::usage="A function to find a package by name";
AppPackages::usage=
	"Finds the packages in a given app";
AppStylesheet::usage="A function to find a stylesheet by name";


(* ::Subsubsection::Closed:: *)
(*Edit*)



AppConfigure::usage=
	"Compiles an application from a series of packages or definitions";
AppConfigureSubapp::usage=
	"Creates a subapplication out of a set of packages or specs";
AppReconfigureSubapp::usage=
	"Reconfigures a subapp, preserving files, etc.";


AppAddContent::usage="Adds a file to the app";


AppConfigRegenerate::usage="Regenerates a config file";


(* ::Subsubsection::Closed:: *)
(*Analyze*)



AppGet::usage=
	"Runs get on the specified app package";
AppNeeds::usage=
	"Runs Needs on the specified package";
AppPackageOpen::usage=
	"Opens a package .m file";
AppFromFile::usage=
	"Gets an app from the current file";


(* ::Subsubsection::Closed:: *)
(*Docs*)



AppDocGen::usage="";


(* ::Subsubsection::Closed:: *)
(*Distribute*)



$AppCloudExtension::usage="The cloud extension for applications";


AppPublish::usage=
	"Publishes the app to GitHub and PacletServer";


(*PackageScopeBlock[
	AppBundle::usage="Creates a sync bunde for an app";
	AppUpload::usage="Uploads an application zip to the cloud";
	AppDownload::usage="Downloads an app into a directory";
	AppInstall::usage="Downloads/installs an application";
	AppBackup::usage="Backs up the app";
	AppBackups::usage="Gets all the backed-up versions of the app";
	AppRestore::usage="Restores the most recent version of the app";
	]*)


(* ::Subsubsection::Closed:: *)
(*Project*)



(*PackageScopeBlock[
	AppDeployReadme::usage=
		"Deploys the app README.md file";
	AppDeployHTML::usage=
		"Deploys app HTML files";
	AppDeployImages::usage=
		"Deploys the app img files";
	AppDeployCSS::usage=
		"Deploys the app css files";
	]*)


(* ::Subsubsection::Closed:: *)
(*Git*)



AppGit::usage=
	"Git-type wrapper for apps";


(* ::Subsubsection::Closed:: *)
(*Paclets*)



AppPacletExecute::usage="PacletExecute-type wrapper for apps";


Begin["`Private`"];


(* ::Subsection:: *)
(*Load*)



If[Length@OwnValues[$AppDirectoryRoot]==0,
	$AppDirectoryRoot=$UserBaseDirectory;
	];
If[Length@OwnValues[$AppDirectoryName]==0,
	$AppDirectoryName="Applications"
	];
If[Length@OwnValues[$AppDirectory]==0,
	$AppDirectory:=
		FileNameJoin@{$AppDirectoryRoot, $AppDirectoryName}
	];
If[Length@OwnValues[$AppDirectories]==0,
	$AppDirectories:=
		Prepend[
			Join[
				PacletManager`Package`$extraPacletDirs,
				$Path
				],
			$AppDirectory
			]
	];
If[Length@OwnValues[$AppUploadDefault]==0,
	$AppUploadDefault="Cloud"
	];
If[Length@OwnValues[$AppBackupDefault]==0,
	$AppBackupDefault=
		Which[
			DirectoryQ@FileNameJoin@{$HomeDirectory, "Google Drive"},
				"GoogleDrive",
			DirectoryQ@FileNameJoin@{$HomeDirectory, "Dropbox"},
				"Dropbox",
			DirectoryQ@FileNameJoin@{$HomeDirectory, "OneDrive"},
				"OneDrive",
			_,
				"Cloud"
			]
	];
If[$AppBuilderConfigLoaded=!=True,
	Replace[
		SelectFirst[
			PackageFilePath["Private", "Config", "AppBuilderConfig."<>#]&/@{"m","wl"},
			FileExistsQ
			],
			f_String:>Get@f
		];
	$AppBuilderConfigLoaded=True
	];


(* ::Subsection:: *)
(*Execute*)



(*	<|
		"Path"->
			AppPath,
		"Configure"->
			AppConfigure,
		"ConfigureSubapp"->
			AppConfigureSubapp,
		"ReconfigureSubapp"->
			AppReconfigureSubapp,
		"FileNames"->
			AppFileNames,
		"Packages"->
			AppPackages,
		"Packages"->
			AppPackages,
		"AddContent"->
			AppAddContent,
		"GitHubConfigure"->
			AppGitHubRepo,
		"GitHubPush"->
			AppGitHubPush,
		"GitHubDelete"->
			AppGitHubDelete
		|>
AppObjectExecute[
	
	]:=*)


(*AppObject[appName_String]:=*)


(* ::Subsection:: *)
(*Find*)



(* ::Subsubsection::Closed:: *)
(*AppNames*)



AppNames[
	pat:_?StringPattern`StringPatternQ:WordCharacter..,
	baseName:True|False:True
	]:=
	DeleteDuplicates@
	If[baseName, Map[FileBaseName], Identity]@
		Select[FileExistsQ@FileNameJoin[{#, "PacletInfo.m"}]&]@
			DeleteDuplicates@
				Join[
					FileNames[pat, $AppDirectory],
					FileNames[pat, $AppDirectories]
					];


(* ::Subsubsection::Closed:: *)
(*AppFileNames*)



Options[AppFileNames]=
	Join[
		Options[FileNames],
		{
			"DropDirectory"->True,
			Select->Automatic
			}
		];
AppFileNames[
	app:_String|Automatic,
	p___String,
	pat:_?StringPattern`StringPatternQ:"*",
	depth:_Integer?Positive|Infinity:1,
	ops:OptionsPattern[]
	]:=
	With[{d=AppPath[app, p], sel=OptionValue[Select]},
		If[TrueQ@OptionValue["DropDirectory"],
			Map[FileNameDrop[#, FileNameDepth[d]]&],
			Identity
			]@
			If[sel=!=Automatic, 
				Select[TrueQ@sel[#]&], 
				Identity
				]@
			FileNames[pat, d, depth,
				FilterRules[{ops}, Options@FileNames]
				]
		]


(* ::Subsubsection::Closed:: *)
(*AppPackages*)



Options[AppPackages]=
	Options[AppComponentFiles]
AppPackages[
	app:_String|Automatic
	]:=
	AppComponentFiles[app, "Packages", "m"|"wl"]


(* ::Subsection:: *)
(*Builder*)



(* ::Subsubsection::Closed:: *)
(*AppPath*)



AppPath//Clear


AppPath[format:True|False:False, app:_String|Automatic, e___]:=
	With[{base=AppDirectory[app, e]},
		If[!FileExistsQ@base,
			Replace[
				PacletManager`PacletFind[app],
				{
					{p_,___}:>
						FileNameJoin@Flatten@{p["Location"], AppPathFormat@{e}},
					_->base
					}
				],
			base
			]
		];


AppPackage[app_:Automatic,pkg_String]:=
	Replace[
		AppPath[AppFromFile[app],"Packages",pkg],{
			f_?FileExistsQ:>
				f,
			f_:>
				If[FileExtension@f==="",
					SelectFirst[f<>#&/@{".nb",".m",".wl"},
						FileExistsQ
						],
					Missing["NotFound"]]
			}]


(* ::Subsubsection::Closed:: *)
(*AppConfigure*)



Options[AppConfigure]={
	Directory->Automatic,
	Extension->Automatic,
	"Documentation"->{},
	"StyleSheets"->{},
	"Palettes"->{},
	"TextResources"->{},
	"SystemResources"->{},
	"AutoCompletionData"->{},
	"Resources"->{},
	"PacletInfo"->{},
	"BundleInfo"->{},
	"LoadInfo"->None,
	"UploadInfo"->None
	};
AppConfigure[
	name_?StringQ,
	packages:
		(
			_Symbol|Except[_Symbol]?(MatchQ[(_String|_File)?FileExistsQ])
			)|
		{
			(
				_Symbol|Except[_Symbol]?(MatchQ[(_String|_File)?FileExistsQ])|
					{
						Except[_Symbol]?(MatchQ[(_String|_File)?FileExistsQ]),
						Except[_Symbol]?(MatchQ[_String|{__String}])
						}
				)...}:
		None,
	ops:OptionsPattern[]
	]:=
	Block[{
		$AppDirectoryRoot=
			Replace[OptionValue@Directory,
				Automatic:>$AppDirectoryRoot],
		$AppDirectoryName=
			Replace[OptionValue@Extension,{
				Automatic:>$AppDirectoryName,
				Except[_String]->Nothing
				}]
		},
		configureDirectories@name;
		Replace[
			Hold[packages]/.{
				None->{},
				f:Except[_Symbol]:>
					With[{r=f},r/;True]
				},
			Hold[p__]:>configurePackages[name,p]
			];
		AppRegenerateInit@name;
		configureDocs[name,
			Sequence@@Flatten@{OptionValue@"Documentation"}
			];
		configureFE[name,
			OptionValue["StyleSheets"],
			OptionValue["Palettes"],
			OptionValue["TextResources"],
			OptionValue["SystemResources"]
			];
		configureResources[name,
			OptionValue["Resources"]
			];
		If[OptionValue["PacletInfo"]=!=None,
			AppRegeneratePacletInfo[name,
				Sequence@@Flatten@{OptionValue@"PacletInfo"}]
			];
		If[OptionValue["LoadInfo"]=!=None,
			AppRegenerateLoadInfo[name,OptionValue["LoadInfo"]]
			];
		If[OptionValue["UploadInfo"]=!=None,
			AppRegenerateUploadInfo[name,OptionValue["UploadInfo"]]
			];
		If[OptionValue["BundleInfo"]=!=None,
			AppRegenerateBundleInfo[name,OptionValue["BundleInfo"]]
			];
		FileNameJoin@{$AppDirectoryRoot,$AppDirectoryName,name}
		];
AppConfigure~SetAttributes~HoldAll;


(* ::Subsubsection::Closed:: *)
(*AppConfigureSubapp*)



appConfigureSubResource[app_,new_,resType_,resList_]:=
	Map[
		#->
			StringReplace[#,
				StringTrim@FileNameJoin@{" ",app," "}->
					StringTrim@FileNameJoin@{" ",new," "}
				]&
		]@
	DeleteCases[Except[_String?(StringLength@#>0&&FileExistsQ@#&)]]@
	Map[
		SelectFirst[
			{
				AppPath[app,resType, #],
				AppPath[app,resType,
					StringTrim[#,".nb"]<>".nb"],
				AppPath[app,resType,app, #],
				AppPath[app,resType,app,
					StringTrim[#,".nb"]<>".nb"]
				},
			FileExistsQ,
			Nothing
			]&,
		Flatten[{resList}, 1]
		]


Options[AppConfigureSubapp]=
	DeleteDuplicatesBy[First]@
		Join[
			{
				"Name"->Automatic,
				"Packages"->{},
				"StyleSheets"->{},
				"Palettes"->{},
				"Documentation"->{},
				"Symbols"->{},
				"Guides"->{},
				"Tutorials"->{}
				},
			FilterRules[Options@AppConfigure,
				Except[Directory|Extension]
				]
			];
AppConfigureSubapp[
	appName_:Automatic,
	path_String?(StringLength@DirectoryName@#>0&&FileExistsQ@DirectoryName@#&),
	ops:OptionsPattern[]
	]:=
	With[{app=AppFromFile[appName]},
		With[{
			packages=
				Map[
					{#,
						FileNameSplit@
							FileNameDrop[#,FileNameDepth@AppDirectory[app,"Packages"]]
						}&
					]@
						DeleteCases[Except[_String?(StringLength@#>0&&FileExistsQ@#&)]]@
						Flatten[
							{
								AppPackage[app,StringTrim[#,".nb"|".m"|".wl"]],
								Replace[
									AppPackage[app,
										StringTrim[#,".nb"|".m"]<>".m"
										],
									$Failed:>
										AppPackage[app,
											StringTrim[#,".nb"|".wl"]<>".wl"
											]
									]
								}&/@
								Replace[Flatten[{OptionValue["Packages"]},1],
									Except[_String]->Nothing,
									1
									]
							],
			palettes=
				appConfigureSubResource[app,FileBaseName[path],
					"Palettes",
					OptionValue["Palettes"]
					],
			stylesheets=
				appConfigureSubResource[app,FileBaseName[path],
					"StyleSheets",
					OptionValue["StyleSheets"]
					],
			textresources=
				appConfigureSubResource[app,FileBaseName[path],
					"TextResources",
					OptionValue["TextResources"]
					],
			systemresources=
				appConfigureSubResource[app,FileBaseName[path],
					"SystemResources",
					OptionValue["SystemResources"]
					],
			resources=
				appConfigureSubResource[app,FileBaseName[path],
					"Resources",
					OptionValue["Resources"]
					],
			docs=
				{}(*DeleteCases[Except[_String?(StringLength@#>0&&FileExistsQ@#&)]]@
				Join[
					AppPath[app,"Symbols",
						StringTrim[#,".nb"]<>".nb"]&/@
							Flatten@{OptionValue["Symbols"]},
					AppPath[app,"Symbols",
						StringTrim[#,".nb"]<>".nb"]&/@
							Flatten@{OptionValue["Guides"]},
					AppPath[app,"Symbols",
						StringTrim[#,".nb"]<>".nb"]&/@
							Flatten@{OptionValue["Tutorials"]},
					AppPath[app,"Documentation","English",
						If[StringQ@#,StringTrim[#,".nb"]<>".nb",#]
						]&/@
							Flatten@{OptionValue["Documentation"]}
					]*)
			},
			AppConfigure[
				FileBaseName@path,
				packages,
				Evaluate@FilterRules[{
					"Palettes"->palettes,
					"StyleSheets"->stylesheets,
					"TextResources"->textresources,
					"SystemResources"->systemresources,
					"Documentation"->docs,
					"Resources"->resources,
					Directory->DirectoryName@path,
					Extension->None,
					ops
					},
					Options@AppConfigure
					]
				]
			]
		];
AppConfigureSubapp[
	app_,
	name:_String|{__String},
	dir:(_String?DirectoryQ|Automatic):Automatic,
	ops:OptionsPattern[]
	]:=
	With[{
		appName=
			Replace[OptionValue@"Name",
				Automatic:>
					First@Flatten@{name}
				],
		buildd=Replace[dir,Automatic:>$TemporaryDirectory]
		},
		AppConfigureSubapp[
			app,
			Quiet@
				DeleteDirectory[
					FileNameJoin@{buildd,appName},
					DeleteContents->True
					];
			FileNameJoin@{buildd,appName},
			FilterRules[{
				"Packages"->
					Join[
						#,
						OptionValue["Packages"]
						],
				ops,
				"LoadInfo"->{
					"PackageScope"->
						DeleteCases[
							Select[#,StringQ],
							Alternatives@@Flatten@{name}
							]
					}
				},
				Options@AppConfigureSubapp
				]&@Keys@AppPackageDependencies[app,name]
			]
		];


(* ::Subsubsection::Closed:: *)
(*AppReconfigureSubapp*)



appCopyContent[
	files_,
	oldDir_,
	newDir_
	]:=
	With[
			{
				old=
					FileNameJoin@
						Flatten@
							{
								oldDir,
								AppPathFormat[#]
								},
				new=
					FileNameJoin@
						Flatten@{
							newDir,
							AppPathFormat[#]
							}
				},
			If[FileExistsQ@old,
				If[!DirectoryQ@DirectoryName[new],
					CreateDirectory[DirectoryName[new],
						CreateIntermediateDirectories->True]
					];
				If[DirectoryQ@old,
					If[DirectoryQ@new,
						DeleteDirectory[new,DeleteContents->True]
						];
					CopyDirectory[old,new],
					CopyFile[old,new,
						OverwriteTarget->True
						]
					]
				]
			]&/@files


Options[AppReconfigureSubapp]=
	Join[
		Options[AppConfigureSubapp],
		{
			"PreserveFiles"->
				{
					".git", 
					".gitignore",
					"README.md",
					"README.nb",
					"project"
					},
			"PreservePacletInfo"->True
			}
		];
AppReconfigureSubapp[
	app_,
	name:_String|{__String},
	dir:(_String?DirectoryQ|Automatic):Automatic,
	ops:OptionsPattern[]
	]:=
	Module[
		{
			appName=
				Replace[OptionValue@"Name",
					Automatic:>
						First@Flatten@{name}
					],
			appDir,
			presFiles=
				OptionValue["PreserveFiles"],
			presPI=
				OptionValue["PreservePacletInfo"],
			tmp
			},
		appDir=
			FileNameJoin@{
				Replace[dir,
					Automatic:>
						$TemporaryDirectory
					],
				appName
				};
		tmp=CreateDirectory[];
		CheckAbort[
			appCopyContent[presFiles,appDir,tmp];
			AppConfigureSubapp[
				app,
				name,
				dir,
				If[presPI,
					"PacletInfo"->
						Flatten@
							{
								Replace[OptionValue["PacletInfo"],
									Except[_List]->{}
									],
									Normal@PacletInfoAssociation[appDir]
									},
					Sequence@@{}
					],
				ops
				];
			appCopyContent[presFiles,tmp,appDir];
			DeleteDirectory[tmp,
				DeleteContents->True],
			DeleteDirectory[tmp,
				DeleteContents->True]
			];
		appDir
		]


(* ::Subsubsection::Closed:: *)
(*Regens*)



$AppRegenRouter=
	<|
			"PacletInfo"->
				AppRegeneratePacletInfo,
			"Loader"->
				AppRegenerateInit,
			"Directories"->
				AppRegenerateDirectories,
			"LoadInfo"->
				AppRegenerateLoadInfo,
			"BundleInfo"->
				AppRegenerateBundleInfo,
			"UploadInfo"->
				AppRegenerateUploadInfo,
			"DocInfo"->
				AppRegenerateDocInfo,
			"README"->
				AppRegenerateReadme,
			"GitIgnore"->
				AppRegenerateGitIgnore,
			"GitExclude"->
				AppRegenerateGitExclude
		|>;
AppConfigRegenerate[app_, thing_?(KeyExistsQ[$AppRegenRouter, #]&), args___]:=
	$AppRegenRouter[thing][app, args];


(* ::Subsection:: *)
(*Edit*)



(* ::Subsubsection::Closed:: *)
(*Add Content*)



Options[AppAddContent]=
	Join[(*
		Options[CreateDirectory],*)
		Options[CopyFile]
		];
AppAddContent[
	name_,
	file_String?FileExistsQ,
	path__String,
	ops:OptionsPattern[]
	]:=
	With[
		{
			copyTo=
				AppPath[name,path,FileNameTake@file]
			},
		If[Not@FileExistsQ@DirectoryName@copyTo,
			CreateDirectory[DirectoryName@copyTo,
				CreateIntermediateDirectories->True
				]
			];
		CopyFile[file,copyTo,
			FilterRules[{ops}, Options@CopyFile]
			]
		];
AppAddContent[
	name_,
	file_String?FileExistsQ,
	ops:OptionsPattern[]
	]:=
	With[{path=
		Switch[
			{FileBaseName@file,FileExtension@file},
			{"PacletInfo","m"},{},
			{_,"m"|"wl"},"Packages",
			{_,"nb"},
				Replace[
					Get@file,
					{
						nb:Notebook[data_,
							{___,
								StyleDefinitions->_?(
										Not@*FreeQ@FrontEnd`FileName[{"Wolfram"},"Reference"]
										),___}]:>
								If[FreeQ[data,Cell[__,"GuideTitle",___]],
									"Symbols",
									"Guides"
									],
						Notebook[_,
							{___,(_Rule|_RuleDelayed)[AutoGeneratedPackage,Except[False]],___}]->
							"Packages",
						Notebook[
							_?(MemberQ[NotebookTools`FlattenCellGroups@#,
									Cell[StyleData[__],___]]&),
							___
						]->
							{name, "StyleSheets"},
						_->"Resources"
						}
					],
			_,{}
			]},
		AppAddContent[name,file,path,ops]
		];
AppAddContent[
	appName_,
	nb:(_NotebookObject|Automatic):Automatic,
	ops:OptionsPattern[]
	]:=
	Replace[
		NotebookFileName@Replace[nb,Automatic:>EvaluationNotebook[]],
		{
			fName_String:>AppAddContent[appName,nb,FileBaseName@fName,ops],
			_:>$Failed
			}
		];
AppAddContent[
	appName_,
	nb:(_NotebookObject|Automatic):Automatic,
	fName_String?(StringMatchQ[Except[$PathnameSeparator]..]),
	path:__String|None:None,
	ops:OptionsPattern[]
	]:=
	With[{file=
			NotebookSaveRename[
				Replace[nb,Automatic:>EvaluationNotebook[]],
				FileNameJoin@{$TemporaryDirectory,
					fName<>If[FileExtension[fName]==="",".nb",""]
					}
				]},
		With[{new=
			Check[
				If[{path}=!={None},
					AppAddContent[appName,file,path,ops],
					AppAddContent[appName,file,ops]
					],
				$Failed]},
			If[MatchQ[new,_String?FileExistsQ],
				SystemOpen@new;
				NotebookClose@Replace[nb,Automatic:>EvaluationNotebook[]],
				$Failed
				]
			]
		];


(* ::Subsection:: *)
(*Docs*)



(* ::Subsubsection::Closed:: *)
(*AppDocGen*)



(* ::Text:: *)
(*Use this to dispatch to all of the other App docs methods*)



$AppDocGenMethodRouter=
	<|
		"SymbolPage"->
			<|
				Automatic->
					AppSymbolNotebook,
				"Template"->
					AppSymbolNotebook,
				"PackageTemplate"->
					AppPackageSymbolNotebook,
				"Save"->
					AppSaveSymbolPages,
				"PackageSave"->
					AppPackageSaveSymbolPages
				|>,
		"Guide"->
			<|
				Automatic->
					AppGuideNotebook,
				"Save"->
					AppSaveGuide,
				"Template"->
					AppGuideNotebook
				|>,
		"Tutorial"->
			<|
				Automatic->AppTutorialNotebook,
				"PackageTemplate"->AppPackageDocumentationTemplate
				|>,
		"Documentation"->
			<|
				Automatic->AppGenerateDocumentation,
				"Package"->AppPackageGenerateDocumentation,
				"Template"->AppDocumentationTemplate
				|>,
		"HTML"->
			<|
				Automatic->AppGenerateHTMLDocumentation,
				"Package"->AppPackageGenerateHTMLDocumentation
				|>,
		"Index"->
			AppIndexDocs
		|>;


AppDocGen::nopkg=
	"Method `` requires ";
appDocGenDefault[
	app_String, type_String, 
	fun_Symbol, method:_String|_Symbol, 
	methOps_?OptionQ, ops___?OptionQ
	]:=
	Catch@
	With[
		{
			pkg=Lookup[methOps, "Package", None], 
			meth=ToString[method],
			dir=
				Lookup[methOps, Directory, Automatic],
			ext=
				Lookup[methOps, Extension, True],
			gtype=
				Lookup[methOps, "GenerateType", All],
			fnp=
				Lookup[methOps, "FileNamePattern", All]
			},
		If[StringStartsQ[meth, "Package"]&&!StringQ[pkg],
			Message[AppDocGen::nopkg, pkg];
			Throw@$Failed
			];
		Which[
			fun===AppGenerateDocumentation||StringEndsQ[meth, "Save"],
				If[StringStartsQ[meth, "Package"],
					fun[app, pkg, dir, ext,
						Evaluate@FilterRules[{ops}, Options@fun]
						],
					fun[app, dir, ext,
						Evaluate@FilterRules[{ops}, Options@fun]
						]
					],
			type==="Documentation",
				Which[
					StringStartsQ[meth, "Package"],
						fun[app, pkg, dir, gtype, fnp,
							Evaluate@FilterRules[{ops}, Options@fun]
							],
					StringStartsQ[meth, "Template"],
						fun[app,
							Evaluate@FilterRules[{ops}, Options@fun]
							],
					True,
						fun[app, dir, gtype, fnp,
							Evaluate@FilterRules[{ops}, Options@fun]
							]
					],
			StringStartsQ[meth, "Package"],
				fun[app, pkg, Evaluate@FilterRules[{ops}, Options@fun]],
			True,
				fun[app, Evaluate@FilterRules[{ops}, Options@fun]]
			]
		];


Options[AppDocGen]=
	{
		Method->Automatic
		};
AppDocGen[
	app_String,
	type:_?(KeyExistsQ[$AppDocGenMethodRouter, #]&):"SymbolPage",
	ops:OptionsPattern[]
	]:=
	Block[
		{
			$DocGenMethodRouter=$AppDocGenMethodRouter,
			$DocGenFunction=appDocGenDefault
			},
		DocGen[type, app, ops]
		]
AppDocGen~SetAttributes~HoldRest


(* ::Subsection:: *)
(*Publish*)



(* ::Subsubsection::Closed:: *)
(*AppPublish*)



Options[AppPublish]=
	{
		"PacletBackup"->True,
		"UpdatePaclet"->True,
		"GitCommit"->Automatic,
		"ConfigureGitHub"->Automatic,
		"PushToGitHub"->True,
		"PushToCloud"->False,
		"PushToServer"->True,
		"PublishServer"->Automatic,
		"MakeSite"->True,
		Verbose->True
		};
AppPublish[app_,ops:OptionsPattern[]]:=
	With[{
		updatePac=TrueQ[OptionValue["UpdatePaclet"]],
		gitCommit=OptionValue["GitCommit"],
		gitHubConfigure=OptionValue["ConfigureGitHub"],
		gitHubPush=TrueQ[OptionValue["PushToGitHub"]],
		pacletCloudPush=TrueQ[OptionValue["PushToCloud"]],
		pacletServerPush=TrueQ[OptionValue["PushToServer"]],
		pacletBackup=TrueQ[OptionValue["PacletBackup"]],
		verb=TrueQ@OptionValue[Verbose]
		},
		<|
			"PacletBackup"->
				If[pacletBackup,
					AppPacletBackup[app]
					],
			"UpdatePaclet"->
				If[updatePac,
					AppRegeneratePacletInfo[app]
					],
			"GitCommit"->
				If[TrueQ[gitCommit]||(gitHubPush&&gitCommit=!=False),
					AppGitSafeCommit[app]
					],
			"ConfigureGitHub"->
				If[TrueQ[gitHubConfigure]||(gitHubPush&&gitHubConfigure=!=Automatic),
					AppGitHubConfigure[app]
					],
			"PushToGitHub"->
				If[gitHubPush,
					Quiet[AppGitHubPush[app], Git::err];
					AppGitHubRepo[app]
					],
			"PushToCloud"->
				If[pacletCloudPush,
					(*<|
						"Upload"->
							AppPacletUpload[app,
								"ServerBase"\[Rule]Default,
								"ServerName"\[Rule]Default
								],
						"ServerPage"->
							PacletServerPage[]
					|>*)
					AppPacletUpload[app,
						"ServerBase"->Default,
						"ServerName"->Default
						]
					],
			"PushToServer"->
				Association@{
					If[TrueQ@pacletServerPush,
						"ServerPaclet"->
							PacletServerAdd[$PacletServer, app],
						Nothing
						],
					If[TrueQ@OptionValue["PublishServer"]||
						TrueQ[pacletServerPush]&&OptionValue["PublishServer"]===Automatic,
						"ServerURL"->
							With[{mf=TrueQ@OptionValue["MakeSite"]},
								Replace[
									MinimalBy[
										Select[
											Cases[
												PacletServerBuild[$PacletServer, 
													"AutoDeploy"->True,
													"RegenerateContent"->mf,
													"BuildSite"->mf,
													"DeployOptions"->
														{
															Monitor->False,
															"DeployPages"->mf
															}
													],
												CloudObject[c_,___]:>c
												],
											StringEndsQ["/index.html"]
											],
										Length@URLParse[#,"Path"]&
										],
									{m_, ___}:>
										Function[
											URLBuild@
												ReplacePart[#,
													"Path"->
														Append[Most[#Path],"main.html"]
													]&@
												URLParse[m]
											]
									]
								],
							Nothing
							]
						}
			|>
		]


(* ::Subsection:: *)
(*Git*)



(* ::Subsubsection::Closed:: *)
(*Git*)



$AppGitRouter=
	<|
		"Init"->
			AppGitInit,
		"Clone"->
			AppGitClone,
		"Commit"->
			AppGitSafeCommit,
		"GitHubRepo"->
			AppGitHubRepo,
		"GitHubConfigure"->
			AppGitHubRepo,
		"GitHubPush"->
			AppGitHubPush,
		"GitHubDelete"->
			AppGitHubDelete
		|>


AppGit[
	app_,
	k_?(KeyExistsQ[$AppGitRouter, #]&),
	args___
	]:=
	With[{fn=$AppGitRouter[k]},
		With[{res=fn[app, args]},
			res/;Head[res]=!=fn
			]
		];
AppGit[
	k_?(KeyExistsQ[$AppGitRouter, #]&),
	Optional["Function", "Function"]
	]:=
	$AppGitRouter[k];
AppGit[
	k_?(KeyExistsQ[$AppGitRouter, #]&),
	"Options"
	]:=
	Options@Evaluate@$AppGitRouter[k];


(* ::Subsection:: *)
(*Loading*)



(* ::Subsubsection::Closed:: *)
(*AppGet*)



AppGet[appName_,pkgName_String]:=
	With[{
		app=AppFromFile[appName],
		cont=$Context
		},
		Replace[
			Names[app<>"`*`PackageAppGet"],{
				{n_, ___}:>
					Replace[
						FileNames[pkgName~~".wl"|".m",
							AppPath[app,"Packages"],
							\[Infinity]
							],
						{f_,___}:>
							ToExpression[n][ExpandFileName@f]
						],
			_:>(
				If[DirectoryQ@AppPath[app,"Packages",pkgName],
					BeginPackage[app<>"`"];
					Begin["`"<>StringTrim[StringReplace[pkgName,$PathnameSeparator->"`"],"`"]<>"`"];
					FrontEnd`Private`GetUpdatedSymbolContexts[];
					EndPackage[],
					With[{
						pkg=
							SelectFirst[
								SortBy[FileNameDepth]@
									FileNames[
										StringTrim[pkgName,".m"]<>".m",
										AppPath[app,"Packages"],
										Infinity
										],
								FileExistsQ
								]
						},
						If[FileExistsQ@pkg,
							With[{
								pkCont=
									StringReplace[
										app<>"`"<>
											StringReplace[
												FileNameDrop[DirectoryName@pkg,
													FileNameDepth@AppDirectory[app,"Packages"]],
												$PathnameSeparator->"`"
												]<>"`",
										"``"->"`"
										]
								},
								BeginPackage[pkCont]
								];
							$ContextPath=
								DeleteDuplicates@
									Join[
										Replace[
											ToExpression[
												$Context<>"PackageScope`Private`$PackageContexts"
												],
											Except[{__String}]->{}
											],
										$ContextPath
										];
							CheckAbort[
								Get@pkg;
								EndPackage[],
								EndPackage[];
								Catch[
									Catch[
										Do[
											If[i<100,
												If[$Context===cont,Throw[$Context,"success"],End[]],
												Throw[$Failed,"fail"]
												],
											{i,1000}
											],
										"fail",
										Begin[cont]&
										],
									"success"
									];
								]
							]
						]
					];
				Catch[
					Catch[
						Do[
							If[i<100,
								If[$Context===cont, Throw[$Context,"success"],End[]],
								Throw[$Failed,"fail"]
								],
							{i,1000}
							],
						"fail",
						Begin[cont]&
						],
					"success"
					]
				)
		}]
	];
AppGet[appName_,pkgName:{__String}]:=
	AppGet[appName,FileNameJoin@pkgName];
AppGet[appName_,Optional[Automatic,Automatic]]:=
	AppGet[appName,FileBaseName@NotebookFileName[]];
AppGet[Optional[Automatic,Automatic]]:=
	With[{app=FileNameTake[NotebookFileName[],{FileNameDepth@$AppDirectory+1}]},
		AppGet[app,Automatic]
		];


(* ::Subsubsection::Closed:: *)
(*AppNeeds*)



If[Not@AssociationQ@$AppLoadedPackages,
	$AppLoadedPackages=<||>
	];
AppNeeds[appName_,pkgName_String]:=
	If[!Lookup[$AppLoadedPackages,Key@{appName,pkgName},False],
		$AppLoadedPackages[{appName,pkgName}]=True;
		AppGet[appName,pkgName];
		];
AppNeeds[appName_,Optional[Automatic,Automatic]]:=
	AppNeeds[appName,FileBaseName@NotebookFileName[]];
AppNeeds[Optional[Automatic,Automatic]]:=
	With[{app=FileNameTake[NotebookFileName[],{FileNameDepth@$AppDirectory+1}]},
		AppNeeds[app,Automatic]
		];


(* ::Subsubsection::Closed:: *)
(*AppFromFile*)



AppFromFile[f_String]:=
	With[{
		splitPath=FileNameSplit[DirectoryName[ExpandFileName@f]]
		},
		Replace[
			SelectFirst[Range[Length@splitPath,1,-1],
				FileExistsQ@FileNameJoin@Append[Take[splitPath,#], "PacletInfo.m"]&,
				Which[
					StringMatchQ[ExpandFileName@f,$AppDirectory~~__],
						FileNameTake[
							FileNameDrop[f,FileNameDepth@$AppDirectory],
							1
							],
					StringMatchQ[f,"http*"~~"/"~~WordCharacter..],
						URLParse[f]["Path"]//Last,
					MemberQ[FileNameTake/@AppNames["*", False], f],
						f,
					Length@PacletManager`PacletFind[f]>0,	
						PacletManager`PacletFind[f][[1]]["Location"]//FileBaseName,
					True,
						$Failed
					]
				],
			i_Integer:>
				splitPath[[i]]
			]
		];
AppFromFile[nb_NotebookObject]:=
	Replace[Quiet@NotebookFileName[nb],
		s_String:>
			AppFromFile[s]
		];
AppFromFile[Optional[Automatic,Automatic]]:=
	AppFromFile@InputNotebook[];


(* ::Subsubsection::Closed:: *)
(*AppPackageOpen*)



AppPackageOpen[app_:Automatic,pkg_]:=
	Replace[AppPackage[app,pkg<>".m"],{
		f_String?FileExistsQ:>
			SystemOpen@f,
		_->$Failed
		}];
AppPackageOpen[Optional[Automatic,Automatic]]:=
	Replace[Quiet@NotebookFileName[],
		f_String:>
			AppPackageOpen[Automatic,
				FileBaseName@f
				]
		]


(* ::Subsection:: *)
(*ZIP dist*)



$AppCloudExtension="applications";
$AppBackupDirectoryName="_appcache"


(* ::Subsubsection::Closed:: *)
(*AppInstall*)



AppInstall[
		name_String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..]),
		loadFE_:Automatic]:=
	With[{},
		If[!DirectoryQ@AppDirectory@name,AppDownload@name];
		If[Replace[loadFE,
			Automatic:>(FileNames["*",{
				AppDirectory[name,"Palettes"],
				AppDirectory[name,"StyleSheets"]}
				]=!={})
			],
			DialogInput[Column@{
"Front end must quit to complete installation. 
Would you like to do that now?",
				Row@{
					DefaultButton["Quit Now",
						FrontEndTokenExecute@"FrontEndQuit"],
					Button["Wait",
						DialogReturn[]]
					}
				},
				WindowTitle->"Quit Mathematica"
				];
			];
		Get@FileNameJoin@{$UserBaseDirectory,"Applications",name,"Kernel","init.m"};
	];


AppInstall[try___]:=
	With[{result=AppDownload[try]},
		Replace[result,{
			_AppDownload:>$Failed,
			f_:>If[DirectoryQ@AppDirectory@FileNameTake@f,
					AppInstall@f
					];
			}]
		]


(* ::Subsubsection::Closed:: *)
(*AppDownload*)



Options[AppDownload]:=
	Options@DownloadFile;
AppDownload[
		file:File[_String?DirectoryQ]|_String?DirectoryQ,
		name:(
				_String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..])|
				Automatic
				):Automatic,
		root:File[_String?DirectoryQ]|_String?DirectoryQ|Automatic:Automatic,
		ops:OptionsPattern[]
		]:=
	With[{appName=StringReplace[
		FileBaseName@file,{
			Whitespace->"",
			Except[WordCharacter|DigitCharacter]->"$"
			}]},
			Block[{$BackupDirectoryName=$AppBackupDirectoryName},
				BackupCopyFile[file,name,Replace[root,Automatic:>$AppDirectory],ops]
				]
			];


AppDownload[
		file:(
				File[_String?(FileExtension@#==="zip"&)]|
				_String?(FileExtension@#==="zip"&)
				),
		name:(
				_String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..])|
				Automatic
				):Automatic,
		root:File[_String?DirectoryQ]|_String?DirectoryQ|Automatic:Automatic,
		ops:OptionsPattern[]
		]:=
	Block[{$BackupDirectoryName=$AppBackupDirectoryName},
		DownloadFile[file,name,Replace[root,Automatic:>$AppDirectory],ops]
		];


AppDownload[
		file:(_CloudObject|_URL|_String),
		name:(
				_String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..])|
				Automatic
				):Automatic,
		root:File[_String?DirectoryQ]|_String?DirectoryQ|Automatic:Automatic,
		ops:OptionsPattern[]
		]:=
	Block[{$BackupDirectoryName=$AppBackupDirectoryName},
		DownloadFile[
			Replace[file,_String:>
				Switch[
					OptionValue@"DownloadFrom",
					CloudObject,
						URLBuild@{$AppCloudExtension,file},
					"Google Drive",
						FileNameJoin@{$AppDirectoryName,file}
					]
				],
			name,
			Replace[root,Automatic:>$AppDirectory],
			ops]
		];


AppDownload[
	file_,
	name:(
				_String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..])|
				Automatic
				):Automatic,
	root:File[_String?DirectoryQ]|_String?DirectoryQ,
	source:Except[_Rule],
	ops:OptionsPattern[]
	]:=
	AppDownload[file,name,root,"DownloadFrom"->source,ops];


(* ::Subsubsection::Closed:: *)
(*AppBundle*)



Options[AppBundle]:=
	Join[
		Options@CreateSyncBundle,{
		"BundleInfo"->Automatic
		}];
AppBundle[
	paths:_String|{__String},
	exportDir:_String?DirectoryQ|Automatic:Automatic,
	metadata:{(_Rule|_RuleDelayed)..}|_Assocation:{},
	ops:OptionsPattern[]]:=
	Replace[OptionValue["BundleInfo"],{
		Automatic:>
			AppBundle[paths,exportDir,metadata,
				"BundleInfo"->
					Replace[
						AppPath[First@Flatten@{paths},
							"Config","BundleInfo.m"],
						Except[_String?FileExistsQ]:>
							AppPath[First@Flatten@{paths},
								"Config","BundleInfo.wl"]
						],
				ops
				],
		f:(_String|_File)?FileExistsQ|_URL:>
			AppBundle[paths,exportDir,metadata,
				"BundleInfo"->None,
				Replace[Import[f],{
					o:{__?OptionQ}:>
						(Sequence@@FilterRules[o,Options@AppBundle]),
					_:>(Sequence@@{})
					}],
				ops
				],
		_:>
			bundleApp[paths,exportDir,metadata,ops]
		}];
Options[bundleApp]=
	Options@AppBundle;
bundleApp[paths_,
	exportDir:_String?DirectoryQ|Automatic:Automatic,
	metadata:{(_Rule|_RuleDelayed)..}|_Assocation:{},
	ops:OptionsPattern[]]:=
	With[{bundle=
		CreateSyncBundle[
			Table[If[!FileExistsQ@app,AppDirectory@app,app],{app,Flatten@{paths}}],
			metadata,
			FilterRules[{
				ops,
				Directory->
					Automatic,
				Root->
					If[!FileExistsQ@First@Flatten@{paths},
						AppDirectory@First@Flatten@{paths},
						$AppDirectory
						]
				},
				Options@CreateSyncBundle
				]
			]},
		If[exportDir=!=Automatic,
			RenameFile[bundle,FileNameJoin@{exportDir,FileNameTake@bundle}],
			bundle
			]
		];


(* ::Subsubsection::Closed:: *)
(*AppUpload*)



(* ::CodeInput::Plain:: *)
Options[AppUpload]:=
	Join[
		Options@AppBundle,
		Options@UploadFile,
		{
			Directory->Automatic
			}
		];
AppUpload[
	appName_String,
	ops:OptionsPattern[]]:=
	With[{dir=
		Block[{
			$AppDirectoryRoot=
				Replace[
					OptionValue@Directory,
					Except[_String?DirectoryQ]:>
						$AppDirectoryRoot
					]},
			If[!FileExistsQ@appName,AppDirectory@appName,appName]
			]},
		UploadFile[
			If[FileExistsQ@appName,
				appName,
				AppBundle[appName,
					FilterRules[{ops},Options@AppBundle]]
				],
			$AppCloudExtension,
			ops
			]
		];


AppUpload[
	appName_,
	sourceLink:"Google Drive"|CloudObject|Automatic,
	ops:OptionsPattern[]
	]:=
	AppUpload[appName,
		"UploadTo"->sourceLink,
		ops]


(* ::Subsubsection::Closed:: *)
(*AppBackup*)



AppBackup[appName_]:=
	With[{
		appDir=AppDirectory[appName]
		},
		BackupFile[appDir,$AppDirectory,$AppBackupDirectoryName]
		];	


(* ::Subsubsection::Closed:: *)
(*AppIndex*)



AppIndex[]:=Table[
{"Name","LastModified"}/.First@CloudObjectInformation@o,
{o,CloudObjects@CloudObject["applications"]}
];


(* ::Subsubsection::Closed:: *)
(*AppBackups*)



AppBackups[appName_:""]:=
	FileBackups[appName,AppDirectory@$AppBackupDirectoryName];


(* ::Subsubsection::Closed:: *)
(*AppRestore*)



AppRestore[appName_]:=
	RestoreFile[
		appName,
		AppDirectory@$AppBackupDirectoryName,
		$AppDirectory
		];


(* ::Subsection:: *)
(*Project Dist*)



$AppProjectExtension="project";
$AppProjectImages="img";
$AppProjectCSS="css";


(* ::Subsubsection::Closed:: *)
(*Readme*)



Options[AppDeployReadme]=
	{
		"UploadTo"->"Paclet"
		};
AppDeployReadme[appName_,ops:OptionsPattern[]]:=
	With[{app=AppFromFile[appName]},
		If[FileExistsQ@AppPath[app,"README.md"],
			Replace[OptionValue["UploadTo"],{
				"Paclet":>
					XMLDeploy[
						MarkdownGenerate[AppPath[app,"README.md"]],
						URLBuild@{AppPacletSiteURL[app],"README"},
						Permissions->"Public"
						],
				CloudObject[o_,___]:>
					XMLDeploy[
						MarkdownGenerate[AppPath[app,"README.md"]],
						URLBuild@{o,"README"},
						Permissions->"Public"
						],
				d_String?DirectoryQ:>
					XMLExport[
						MarkdownGenerate[AppPath[app,"README.md"]],
						FileNameJoin@{d,"README.html"}
						],
				d_String?SyncPathQ:>
					XMLExport[
						MarkdownGenerate[AppPath[app,"README.md"]],
						FileNameJoin@{SyncPath[d],"README.html"}
						]
				}
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*Imgs*)



Options[AppDeployImages]=
	{
		"UploadTo"->"Paclet"
		};
AppDeployImages[appName_,ops:OptionsPattern[]]:=
	With[{app=AppFromFile[appName]},
		With[{imgFiles=
			FileNames["*."~~
				Alternatives@@ToLowerCase@Image`$ExportImageFormats,
				AppPath[app,$AppProjectExtension,$AppProjectImages]
				]
			},
			If[Length@imgFiles>0,
				Replace[OptionValue["UploadTo"],{
					"Paclet":>
						Map[
							CopyFile[File[#],
								CloudObject[
									URLBuild@{
										AppPacletSiteURL[app],
										$AppProjectExtension,$AppProjectImages,
										FileNameTake[#]
										},
									Permissions->"Public"
									]
								]&,
							imgFiles
							],
					CloudObject[o_,___]:>
						Map[
							CopyFile[File[#],
								CloudObject[
									URLBuild@{
										o,
										$AppProjectExtension,$AppProjectImages,
										FileNameTake[#]
										},
									Permissions->"Public"
									]
								]&,
							imgFiles
							],
					d_String?DirectoryQ:>
						Map[
							CopyFile[
								#,
								FileNameJoin@{
									d,
									$AppProjectExtension,$AppProjectImages,
									FileNameTake[#]
									}
								]&,
							imgFiles
							],
					d_String?SyncPathQ:>
						Map[
							CopyFile[
								#,
								FileNameJoin@{
									SyncPath[d],
									$AppProjectExtension,
									$AppProjectImages,
									FileNameTake[#]
									}
								]&,
							imgFiles
							]
					}
					]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*CSS*)



Options[AppDeployCSS]=
	{
		"UploadTo"->"Paclet"
		};
AppDeployCSS[appName_,ops:OptionsPattern[]]:=
	With[{app=AppFromFile[appName]},
		With[{cssFiles=
			FileNames["*.css",
				AppPath[app,$AppProjectExtension,$AppProjectCSS]
				]
			},
			If[Length@cssFiles>0,
				Replace[OptionValue["UploadTo"],{
					"Paclet":>
						Map[
							CopyFile[File[#],
								CloudObject[
									URLBuild@{
										AppPacletSiteURL[app],
										$AppProjectExtension,$AppProjectCSS,
										FileNameTake[#]
										},
									Permissions->"Public"
									]
								]&,
							cssFiles
							],
					CloudObject[o_,___]:>
						Map[
							CopyFile[File[#],
								CloudObject[
									URLBuild@{
										o,
										$AppProjectExtension,$AppProjectCSS,
										FileNameTake[#]
										},
									Permissions->"Public"
									]
								]&,
							cssFiles
							],
					d_String?DirectoryQ:>
						Map[
							CopyFile[
								#,
								FileNameJoin@{
									d,
									$AppProjectExtension,$AppProjectCSS,
									FileNameTake[#]
									}
								]&,
							cssFiles
							],
					d_String?SyncPathQ:>
						Map[
							CopyFile[
								#,
								FileNameJoin@{
									SyncPath[d],
									$AppProjectExtension,
									$AppProjectCSS,
									FileNameTake[#]
									}
								]&,
							cssFiles
							]
					}
					]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*HTML*)



Options[AppDeployHTML]=
	{
		"UploadTo"->"Paclet"
		};
AppDeployHTML[appName_,ops:OptionsPattern[]]:=
	With[{app=AppFromFile[appName]},
		With[{htmlFiles=
			FileNames["*.html",
				AppPath[app,$AppProjectExtension]
				]
			},
			If[Length@htmlFiles>0,
				Replace[OptionValue["UploadTo"],{
					"Paclet":>
						Map[
							CopyFile[File[#],
								CloudObject[
									URLBuild@{
										AppPacletSiteURL[app],
										$AppProjectExtension,
										FileNameTake[#]
										},
									Permissions->"Public"
									]
								]&,
							htmlFiles
							],
					CloudObject[o_,___]:>
						Map[
							CopyFile[File[#],
								CloudObject[
									URLBuild@{
										o,
										$AppProjectExtension,
										FileNameTake[#]
										},
									Permissions->"Public"
									]
								]&,
							htmlFiles
							],
					d_String?DirectoryQ:>
						Map[
							CopyFile[
								#,
								FileNameJoin@{
									d,
									$AppProjectExtension,
									FileNameTake[#]
									}
								]&,
							htmlFiles
							],
					d_String?SyncPathQ:>
						Map[
							CopyFile[
								#,
								FileNameJoin@{
									SyncPath[d],
									$AppProjectExtension,
									FileNameTake[#]
									}
								]&,
							htmlFiles
							]
					}
					]
				]
			]
		];


(* ::Subsection:: *)
(*Paclet Dist*)



(* ::Subsubsection::Closed:: *)
(*PacletExecute*)



$AppPacletExecuteMethods=
	<|
		"Paclet"->
			AppPaclet,
		"SiteURL"->
			AppPacletSiteURL,
		"BundleSite"->
			AppPacletSiteBundle,
		"Upload"->
			AppPacletUpload,
		"Bundle"->
			PacletBundle,
		"Backup"->
			AppPacletBackup,
		"UploadSubpaclet"->
			AppSubpacletUpload
		|>;


AppPacletExecute//Clear


AppPacletExecute[
	app_,
	k_?(KeyExistsQ[$AppPacletExecuteMethods, #]&),
	args___
	]:=
	With[{fn=$AppPacletExecuteMethods[k]},
		With[{res=fn[app, args]},
			res/;Head[res]=!=fn
			]
		];
AppPacletExecute[
	k_?(KeyExistsQ[$AppPacletExecuteMethods, #]&),
	Optional["Function", "Function"]
	]:=
	$AppPacletExecuteMethods[k];
AppPacletExecute[
	k_?(KeyExistsQ[$AppPacletExecuteMethods, #]&),
	"Options"
	]:=
	Options@Evaluate@$AppPacletExecuteMethods[k];


(* ::Subsection:: *)
(*FE Stuff*)



(* ::Subsubsection::Closed:: *)
(*Autocompletions*)



$AppNamesCurrent=
	AppNames["*", True];


PackageAddAutocompletions@
	Map[
		#->
			{
				$AppNamesCurrent,
				Keys@$AppPathMap
				}&,
		{
			"AppPath"
			}
		]


PackageAddAutocompletions@
	Map[
		#->
			{
				$AppNamesCurrent,
				FileName,
				Keys@$AppPathMap
				}&,
		{
			"AppAddContent"
			}
		]


PackageAddAutocompletions@
	Map[
		#->
			{
				$AppNamesCurrent,
				Keys@$AppDocGenMethodRouter
				}&,
		{
			"AppDocGen"
			}
		]


PackageAddAutocompletions@
	Map[
		#->
			{
				$AppNamesCurrent,
				Join[{"Function", "Options"}, Keys@$AppPacletExecuteMethods]
				}&,
		{
			"AppPacletExecute"
			}
		]


PackageAddAutocompletions@
	Map[
		#->
			{
				$AppNamesCurrent,
				Join[{"Function", "Options"}, Keys@$AppGitRouter]
				}&,
		{
			"AppGit"
			}
		]


PackageAddAutocompletions@
	Map[
		#->
			{
				$AppNamesCurrent,
				Keys@$AppRegenRouter
				}&,
		{
			"AppConfigRegenerate"
			}
		]


PackageAddAutocompletions@
	Map[
		#->
		{
			$AppNamesCurrent
			}&,
		{
			"AppConfigure","AppConfigureSubapp","AppReconfigureSubapp",
			"AppFileNames","AppPackages",
			"AppPackage","AppPackageOpen","AppPackageFunctions",
			"AppStylesheet",
			"AppFunctionDependencies",
			"AppGet","AppNeeds","AppPublish"
			}
		]	


End[];



