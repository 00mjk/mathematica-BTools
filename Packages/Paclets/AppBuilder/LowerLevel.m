(* ::Package:: *)

(* Autogenerated Package *)

(* ::Section:: *)
(*AppBuilder*)



(* ::Text:: *)
(*Internal cruft that\[CloseCurlyQuote]s been pushed to a lower-context*)



(* ::Subsubsection::Closed:: *)
(*Methods*)



$AppExecuteMethods::usage=
	"The set of methods known to AppExecute";
$AppDocGenMethodRouter::usage=
	"The set of methods known to AppDocGen";
$AppGitRouter::usage=
	"The set of methods known to AppGit";
$AppPacletExecuteMethods::usage=
	"The set of methods known to AppPacletExecute";


(* ::Subsubsection::Closed:: *)
(*Find*)



$AppPathMap::usage="";
AppLocate::usage="Locates an app";
AppPathFormat::usage="";
AppFileNames::usage="FileNames on an app";


AppComponentFiles::usage="";
AppPackages::usage=
	"Finds the packages in a given app";
AppStyleSheets::usage="";
AppPalettes::usage=""
AppSymbolPages::usage="";
AppGuides::usage="";
AppTutorials::usage="";


AppPacletContexts::usage="";
AppMainContext::usage="";
AppContexts::usage="";


AppFindFile::usage="";
AppPackage::usage="";
AppStylesheet::usage="";
AppSymbolPage::usage="";
AppGuidePages::usage="";


AppDirectory::usage=
	"Used by AppPath find appropriate directories"


(* ::Subsubsection::Closed:: *)
(*Edit*)



AppAddPackage::usage="Adds a package";
AppAddPalette::usage="Adds a palette to the app";
AppAddStylesheet::usage="Adds a stylesheet to the app";
AppAddDocPage::usage="Adds a doc page for a symbol to the app";
AppAddGuidePage::usage="Adds a guide to the app";
AppAddTutorialPage::usage="Adds a tutorial page to the app";


AppRegenerateDirectories::usage=
	"Regenerates missing directories in the app";
AppRegenerateContextLoadFiles::usage=
	"Regenerates missing contex loader files in the app";
AppRegenerateInit::usage=
	"Regenerates a default init file";
AppRegenerateDocInfo::usage=
	"Regenerates the DocInfo.m file";
AppRegenerateBundleInfo::usage=
	"Regenerates the BundleInfo file";
AppRegenerateLoadInfo::usage=
	"Regenerates the LoadInfo file";
AppRegenerateGitIgnore::usage=
	"Rebuilds the .gitignore file";
AppRegenerateGitExclude::usage=
	"Rebuilds the .git/info/exclude file";
AppRegenerateReadme::usage=
	"Generates a GitHub README.md file for the app";
AppRegenerateUploadInfo::usage=
	"Regenerates the UploadInfo.m file";


(* ::Subsubsection::Closed:: *)
(*Analyze*)



AppGenerateTestingNotebook::usage=
	"Generates a standard testing notebook for an app";


AppPackageFunctions::usage=
	"Gets the function names declared in a package or set of packages";
AppFunctionDependencies::usage=
	"Gets the package dependency chain for a function";
AppPackageDependencies::usage=
	"Gets the dependency structure for a full app package";


(* ::Subsubsection::Closed:: *)
(*Docs*)



AppIndexDocs::usage=
	"Indexes the doc pages of an app";
AppGenerateSymbolNotebook::usage=
	"";
AppSymbolNotebook::usage=
	"Generates a doc template for an app";
AppGeneratePackageSymbolNotebook::usage=
	"";
AppPackageSymbolNotebook::usage=
	"Generates a doc template for a package";
AppGuideNotebook::usage=
	"Generates a guide overview for the app";
AppPackageGuideNotebook::usage=
	"Generates a guide overview for a package";
AppTutorialNotebook::usage=
	"Generates a tutorial overview for the app";
AppDocumentationTemplate::usage=
	"Creates a total documentation template for an app";
AppSaveSymbolPages::usage=
	"Saves auto-generated symbol pages";
AppPackageSaveSymbolPages::usage=
	"Saves auto-generated symbol pages for a package";
AppSaveGuide::usage=
	"Saves an auto-generated guide for an app";
AppPackageSaveGuide::usage=
	"Saves auto-generated guide for a package";
AppGenerateDocumentation::usage=
	"Generates symbol pages and guide page for an app";
AppPackageGenerateDocumentation::usage=
	"Generates symbol pages and guide page for a package";
AppGenerateHTMLDocumentation::usage=
	"Generates HTML documentation for an app";


(* ::Subsubsection::Closed:: *)
(*Distribute*)



(*PackageScopeBlock[
	AppBundle::usage="Creates a sync bunde for an app";
	AppUpload::usage="Uploads an application zip to the cloud";
	AppDownload::usage="Downloads an app into a directory";
	AppInstall::usage="Downloads/installs an application";
	AppBackup::usage="Backs up the app";
	AppBackups::usage="Gets all the backed-up versions of the app";
	AppRestore::usage="Restores the most recent version of the app";
	]*)


(* ::Subsubsection::Closed:: *)
(*Project*)



(*PackageScopeBlock[
	AppDeployReadme::usage=
		"Deploys the app README.md file";
	AppDeployHTML::usage=
		"Deploys app HTML files";
	AppDeployImages::usage=
		"Deploys the app img files";
	AppDeployCSS::usage=
		"Deploys the app css files";
	]*)


(* ::Subsubsection::Closed:: *)
(*Git*)



AppGitInit::usage=
	"Configures a Git repository for the app";
AppGitClone::usage=
	"Clones a Git repo";
AppGitCommit::usage=
	"Configures pushes to the git repo";
AppGitSafeCommit::usage=
	"Commits, making sure the ignore and exclude exist";
AppGitHubConfigure::usage=
	"Configures the app to be able to push to github";
AppGitHubRepo::usage=
	"The GitHub repo for the app";
AppGitHubSetRemote::usage=
	"Sets the remote for the app";
AppGitRealignRemotes::usage=
	"Makes sure git will work across remotes";
AppGitHubPull::usage=
	"Pulls the app from its master branch";
AppGitHubPush::usage=
	"Pushes the app to its master branch";
AppGitHubDelete::usage=
	"Removes a repo from github";
AppGitHubCreateRelease::usage=
	"Creates a release on GitHub";


(* ::Subsubsection::Closed:: *)
(*Paclets*)



AppPacletBundle::usage=
	"Packs the .paclet file, removing the specified paths first";
AppPaclet::usage=
	"Generates the paclet expression for app";
AppPacletInfo::usage=
	"Gathers paclet info as an association";
AppRegeneratePacletInfo::usage=
	"Regenerates the PacletInfo file";
AppPacletSiteBundle::usage=
	"Generates the PacletSite.mz file for a collection of apps";
AppPacletSiteInfo::usage=
	"Pulls PacletSite expressions";
AppPacletBackup::usage=
	"Backs up an app to a server";
AppPacletDirectoryAdd::usage=
	"PacletDirectoryAdd on an app name";
AppPacletSiteURL::usage=
	"Gets an app paclet site to add";
AppPacletInstallerURL::usage=
	"Gets the URL to the auto-configured installer";
AppPacletUninstallerURL::usage=
	"Gets the URL to the auto-configure uninstaller";
AppPacletServerPage::usage=
	"Uploads a paclet access page to a server";
AppPacletUpload::usage=
	"Uploads paclet files to a server";
AppSubpacletUpload::usage=
	"Uploads a sub-app";


Begin["`Private`"];


(* ::Subsection:: *)
(*Find*)



(* ::Subsubsection::Closed:: *)
(*AppPathFormat*)



$AppPathMap=
	{
			"Packages"->{"Packages"},
			"Resources"->{"Resources"},
			"Palettes"->{"FrontEnd","Palettes"},
			"StyleSheets"->{"FrontEnd","StyleSheets"},
			"TextResources"->{"FrontEnd","TextResources"},
			"SystemResources"->{"FrontEnd","SystemResources"},
			"Guides"->{"Documentation","English","Guides"},
			"Tutorials"->{"Documentation", "English","Tutorials"},
			"ReferencePages"->{"Documentation","English","ReferencePages"},
			"Symbols"->{"Documentation", "English","ReferencePages","Symbols"},
			"SymbolPages"->{"Documentation", "English","ReferencePages","Symbols"},
			"MessagePages"->{"Documentation", "English","ReferencePages","Messages"},
			"Objects"->{"Resources", "Objects"},
			"Private"->{"Private"}
			};


AppPathFormat[pspec_]:=
	Replace[
		Flatten[{pspec}, 1],
		$AppPathMap,
		1]


(* ::Subsubsection::Closed:: *)
(*AppLocate*)



AppLocate[app_]:=
	Replace[
		AppNames[app, False], 
		{
			{
				f_,
				___
				}:>f,
			_->$Failed
			}
		]


(* ::Subsubsection::Closed:: *)
(*AppFileNames*)



Options[AppFileNames]=
	Join[
		Options[FileNames],
		{
			"DropDirectory"->True,
			Select->Automatic
			}
		];
AppFileNames[
	app:_String|Automatic,
	p___String,
	pat:_?StringPattern`StringPatternQ:"*",
	depth:_Integer?Positive|Infinity:1,
	ops:OptionsPattern[]
	]:=
	With[{d=AppPath[app, p], sel=OptionValue[Select]},
		If[TrueQ@OptionValue["DropDirectory"],
			Map[FileNameDrop[#, FileNameDepth[d]]&],
			Identity
			]@
			If[sel=!=Automatic, 
				Select[TrueQ@sel[#]&], 
				Identity
				]@
			FileNames[pat, d, depth,
				FilterRules[{ops}, Options@FileNames]
				]
		]


(* ::Subsubsection::Closed:: *)
(*AppComponentFiles*)



Options[AppComponentFiles]=
	Join[
		{
			"DropExtension"->Automatic
			},
		Options[AppFileNames]
		];
AppComponentFiles[
	app:_String,
	path___String,
	ext:
		Except[
			"Palettes"|"Packages"|"StyleSheets"|
				"SymbolPages"|"Guides"|"Tutorials",
			_?StringPattern`StringPatternQ
			],
	o:OptionsPattern[]
	]:=
	If[TrueQ@OptionValue["DropExtension"]||
		(OptionValue["DropExtension"]=!=False&&OptionValue["DropDirectory"]=!=False),
		StringTrim[#, "."~~ext],
		#
		]&@
		AppFileNames[
			app,
			path,
			__~~"."~~ext,
			Infinity,
			IgnoreCase->True,
			FilterRules[{o}, Options[AppFileNames]]
			]	


AppComponentFiles[app_String, "Packages", ops:OptionsPattern[]]:=
	AppComponentFiles[app, "Packages", "m"|"wl", ops];
AppComponentFiles[app_String, "Palettes", ops:OptionsPattern[]]:=
	AppComponentFiles[app, "Palettes", "nb", ops];
AppComponentFiles[app_String, "StyleSheets", ops:OptionsPattern[]]:=
	AppComponentFiles[app, "StyleSheets", "nb", ops];
AppComponentFiles[app_String, "SymbolPages", ops:OptionsPattern[]]:=
	AppComponentFiles[app, "SymbolPages", "nb", ops];
AppComponentFiles[app_String, "Guides", ops:OptionsPattern[]]:=
	AppComponentFiles[app, "Guides", "nb", ops];
AppComponentFiles[app_String, "Tutorials", ops:OptionsPattern[]]:=
	AppComponentFiles[app, "Tutorials", "nb", ops];


(* ::Subsubsection::Closed:: *)
(*AppPackages*)



Options[AppPackages]=
	Options[AppComponentFiles]
AppPackages[
	app:_String,
	ops:OptionsPattern[]
	]:=
	Select[
		AppComponentFiles[app, "Packages", "m"|"wl", ops],
		StringFreeQ["__"]
		]


(* ::Subsubsection::Closed:: *)
(*AppPacletContexts*)



AppPacletContexts[app_]:=
	With[{pi=AppPacletInfo[app]},
		Replace[
			Fold[
				Lookup[##, <||>]&,
				If[AssociationQ@pi, pi, <||>],
				{"Extensions", "Kernel", "Context"}
				],
			{
				Except[{__String}]:>{}
				}
			]
		]


(* ::Subsubsection::Closed:: *)
(*AppContext*)



AppMainContext[app_]:=
	Replace[
		AppPacletContexts[app],
		{
			{s_String, ___}:>s,
			_:>AppFromFile[app]<>"`"
			}
		]


(* ::Subsubsection::Closed:: *)
(*AppContexts*)



AppContexts//Clear


Options[AppContexts]=
	{
		"FullContext"->True
		};
AppContexts[
	app:_String,
	ops:OptionsPattern[]
	]:=
	With[
		{
			subconts=
				StringReplace[
					AppFileNames[app, 
						"Packages", 
						WordCharacter..,
						Infinity,
						"DropDirectory"->True,
						Select->DirectoryQ
						],
					$PathnameSeparator->"`"
					]
			},
		If[Length@subconts==0,
			If[!TrueQ@OptionValue["FullContext"], 
				DeleteCases[""]@StringTrim[#, AppMainContext[app]]&, 
				Identity
				]@
				AppPacletContexts[app],
			If[TrueQ@OptionValue["FullContext"],
				With[{mc=AppMainContext[app]},
					Prepend[Map[mc<>#<>"`"&, subconts], mc]
					],
				#<>"`"&/@subconts
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*AppStyleSheets*)



Options[AppStyleSheets]=
	Options[AppComponentFiles]
AppStyleSheets[
	app:_String,
	ops:OptionsPattern[]
	]:=
	AppComponentFiles[app, "StyleSheets", "nb", ops]


(* ::Subsubsection::Closed:: *)
(*AppPalettes*)



Options[AppPalettes]=
	Options[AppComponentFiles]
AppPalettes[
	app:_String,
	ops:OptionsPattern[]
	]:=
	AppComponentFiles[app, "Palettes", "nb", ops]


(* ::Subsubsection::Closed:: *)
(*AppSymbolPages*)



Options[AppSymbolPages]=
	Options[AppComponentFiles]
AppSymbolPages[
	app:_String,
	ops:OptionsPattern[]
	]:=
	AppComponentFiles[app, "SymbolPages", "nb", ops]


(* ::Subsubsection::Closed:: *)
(*AppGuides*)



Options[AppGuides]=
	Options[AppComponentFiles]
AppGuides[
	app:_String,
	ops:OptionsPattern[]
	]:=
	AppComponentFiles[app, "Guides", "nb", ops]


(* ::Subsubsection::Closed:: *)
(*AppTutorials*)



Options[AppTutorials]=
	Options[AppComponentFiles]
AppTutorials[
	app:_String,
	ops:OptionsPattern[]
	]:=
	AppComponentFiles[app, "Tutorials", "nb", ops]


(* ::Subsubsection::Closed:: *)
(*AppFindFile*)



AppFindFile[app_, path__String, exts_]:=
	Replace[
		AppPath[app, path],{
			f_?(FileExistsQ[#]&&!DirectoryQ[#]&):>
				f,
			f_:>
				If[FileExtension@f==="",
					SelectFirst[f<>#&/@exts,
						FileExistsQ
						],
					Missing["NotFound"]
					]
			}]


(* ::Subsubsection::Closed:: *)
(*AppPackage*)



AppPackage[app_, pkg_String]:=
	AppFindFile[app, "Packages", pkg, {".nb", ".m", ".wl"}]


(* ::Subsubsection::Closed:: *)
(*AppStylesheet*)



AppStylesheet[app_, pkg_String]:=
	AppFindFile[app, "Stylesheet", pkg, {".nb"}]


(* ::Subsubsection::Closed:: *)
(*AppPalette*)



AppPalette[app_, pkg_String]:=
	AppFindFile[app, "Palette", pkg, {".nb"}]


(* ::Subsubsection::Closed:: *)
(*AppSymbolPage*)



AppSymbolPage[app_, pkg_String]:=
	AppFindFile[app, "Symbols", pkg, {".nb"}]


(* ::Subsubsection::Closed:: *)
(*AppGuidePage*)



AppSymbolPage[app_, pkg_String]:=
	AppFindFile[app, "Guides", pkg, {".nb"}]


(* ::Subsubsection::Closed:: *)
(*AppTutorialPage*)



AppSymbolPage[app_, pkg_String]:=
	AppFindFile[app, "Tutorials", pkg, {".nb"}]


(* ::Subsection:: *)
(*Builder*)



(* ::Subsubsection::Closed:: *)
(*AppDirectory*)



AppDirectory[app_, extensions___]:=
	FileNameJoin@
		Flatten@
			{
				Replace[
					AppLocate[app],
					$Failed:>
						{
							$AppDirectory,
							app
							}
					],
				AppPathFormat@{extensions}
				};


(* ::Subsubsection::Closed:: *)
(*InitTemplates*)



$appInitStrings:=
	Association[
		FileBaseName[#]->
			StringReplace[
				StringReplace[
					StringTrim[
						Import[#,"Text"],
						Verbatim["(* ::Package:: *)\n\n"]
						],
					"`"->"`tick`"
					],{
				"$InitCode"->"`cores`",
				"$Name"->"`name`"
				}]&/@
				FileNames[
					"*.wl",
					PackageFilePath[
						"Resources",
						"Templates",
						"Initialization"
						]
					]
			]


appInitTemplate[pkg_]:=
	With[{strings=$appInitStrings},
		TemplateApply[
			TemplateApply[strings["init"],<|
				"cores"->
					StringRiffle[StringTrim/@{
						strings["Constants"],
						strings["Paths"],
						strings["Loading"],
						strings["Dependencies"],
						strings["Exceptions"],
						strings["Autocomplete"],
						strings["FrontEnd"]
						},
						"\n"
						],
				"tick"->"`tick`",
				"name"->"`name`"
				|>],<|
			"name"->pkg,
			"tick"->"`"
			|>]
		];


(* ::Subsubsection::Closed:: *)
(*AppRegenerateInit*)



(*AppRegenerateInit[name]~PackageAddUsage~
	"regenerates the main package .m file for the application name";*)
AppRegenerateInit[name_String]:=
	With[{
		packageGet=name<>"`"<>name<>"`",
		loaderGet=
			"If[!TrueQ["<>name<>"`PackageScope`Private`$LoadCompleted],\n  <<"<>
				name<>"`"<>name<>"Loader`\n  ]",
		loader=AppDirectory[name,name<>"Loader.m"],
		pkg=AppDirectory[name,name<>".wl"],
		init=AppDirectory[name,"Kernel","init.m"]
		},
		Export[loader,appInitTemplate[name],"Text"];
		Put[Unevaluated[Get[packageGet];],init];
		Export[pkg, loaderGet, "Text"]
		];


(* ::Subsubsection::Closed:: *)
(*AppPacletDocs*)



Options[AppPacletDocs]=
	Options[PacletDocsInfo]
AppPacletDocs[ops:OptionsPattern[]]:=
	PacletDocsInfo[ops];
AppPacletDocs[app_String,ops:OptionsPattern[]]:=
	PacletDocsInfo[AppDirectory[app],ops];


(* ::Subsubsection::Closed:: *)
(*AppPaclet*)



Options[AppPaclet]=
	Options[PacletInfoExpression];
AppPaclet[ops:OptionsPattern[]]:=
	PacletInfoExpression[ops];
AppPaclet[app_String,ops:OptionsPattern[]]:=
	PacletInfoExpression[
		AppDirectory[app],
		"Kernel"->{
			"Root" -> ".",
			"Context" -> 
				Join[
					{app<>"`"},
					StringRiffle[
						Prepend[app]@
							FileNameSplit[
								FileNameDrop[#,
									FileNameDepth@AppDirectory[app,"Packages"]
									]
								],
						"`"]<>"`"
						&/@
						Select[
							FileNames["*",AppDirectory[app,"Packages"],\[Infinity]],
							DirectoryQ@#&&
								AllTrue[
									FileNameSplit@
										FileNameDrop[#,FileNameDepth@AppDirectory[app,"Packages"]],
									StringMatchQ[
										#,
										(WordCharacter|"$")..
										]
									]&
							]
					]
			},
		ops];


(* ::Subsubsection::Closed:: *)
(*AppPacletInfo*)



AppPacletInfo[app_String]:=
	PacletInfoAssociation@AppDirectory[app];


(* ::Subsubsection::Closed:: *)
(*AppRegeneratePacletInfo*)



Options[AppRegeneratePacletInfo]=
	Options[AppPaclet];
AppRegeneratePacletInfo[name_,
	pacletOps:OptionsPattern[]
	]:=
	PacletInfoExpressionBundle[
		AppPaclet[name,pacletOps],
		AppDirectory[name]
		];


(* ::Subsection:: *)
(*Edit*)



(* ::Subsubsection::Closed:: *)
(*Add Elements*)



AppAddPackage[name_,file_]:=
	AppAddContent[name,file,"Packages"];


AppAddStylesheet[name_,file_]:=
	AppAddContent[name,file,"StyleSheets"];


AppAddPalette[name_,file_]:=
	AppAddContent[name,file,"Palettes"];


AppAddDocPage[name_,file_]:=
	AppAddContent[name,file,"Symbols"];


AppAddGuidePage[name_,file_]:=
	AppAddContent[name,file,"Guides"];


AppAddTutorialPage[name_,file_]:=
	AppAddContent[name,file,"Tutorials"];


(* ::Subsubsection::Closed:: *)
(*RegenerateBundleInfo*)



Options[AppRegenerateBundleInfo]=
	Options@AppPacletBundle;
AppRegenerateBundleInfo[app_String,ops:OptionsPattern[]]:=
	Export[AppPath[app,"Config","BundleInfo.m"],
		DeleteDuplicatesBy[First]@
			Flatten@{
				ops,
				"RemovePaths"->{
					"Private",
					"project",
					"GitHub",
					".git"
					},
				"RemovePatterns"->{
					"Packages/*.nb",
					"Packages/*/*.nb",
					"Packages/*/*/*.nb",
					".DS_Store"
					}
				}
		];


(* ::Subsubsection::Closed:: *)
(*RegenerateLoadInfo*)



Options[AppRegenerateLoadInfo]=
	{
		"PreLoad"-> None,
		"FEHidden" -> {},
		"PackageScope"->None
		};
AppRegenerateLoadInfo[app_String,ops:OptionsPattern[]]:=
	Export[AppPath[app,"Config","LoadInfo.m"],
		DeleteDuplicatesBy[First]@
			Flatten@{
				ops,
				Options@AppRegenerateLoadInfo
			}
		];


(* ::Subsubsection::Closed:: *)
(*RegenerateContextLoadFiles*)



AppRegenerateContextLoadFiles[app_]:=
	With[
		{
			cts=Rest@AppContexts[app, "FullContext"->True],
			ctf=
				Import[
					PackageFilePath["Resources", "Templates", "ContextLoader.wl"],
					"Text"
					]
			},
		Map[
			With[
				{
					target=
						AppPath[app, Sequence@@{#[[;;-2]], #[[-1]]<>".wl"}&@StringSplit[#, "`"]]
					},
				Quiet@
					CreateDirectory[DirectoryName@target, CreateIntermediateDirectories->True];
				WriteString[
					target,
					StringReplace[ctf, "$ContextDepth$"->ToString[StringCount[#, "`"]-1]]
					];
				Close[target]
				]&,
			cts
			]
		]


(* ::Subsection:: *)
(*Docs*)



(* ::Subsubsection::Closed:: *)
(*DocInfo*)



Options[AppRegenerateDocInfo]=
	Options@DocContextTemplate;
AppRegenerateDocInfo[app_String,ops:OptionsPattern[]]:=
	Export[AppPath[app,"Config","DocInfo.m"],
		Flatten@{
			ops,
			"Usage"->Automatic,
			"Functions"->Automatic,
			"Details"->Automatic,
			"Examples"->Defer,
			"RelatedLinks"->None,
			"GuideOptions"->{},
			"TutorialOptions"->{}
			}
		];


(* ::Subsubsection::Closed:: *)
(*AppIndexDocs*)



AppIndexDocs[app_,lang:_String:"English"]:=
	DocGen[
		"Index",
		AppPath[app,"Documentation",lang]
		];


(* ::Subsubsection::Closed:: *)
(*AppSymbolNotebook*)



Options[AppSymbolNotebook]=
	Prepend["DocInfo"->Automatic]@
		Options@SymbolPageTemplate;
AppSymbolNotebook[app_, ops:OptionsPattern[]]:=
	Replace[OptionValue@"DocInfo",{
		Automatic:>
			AppSymbolNotebook[app,
				"DocInfo"->
					AppPath[app,
						"Config",
						"DocInfo.m"],
				ops],
		f_String?FileExistsQ:>
			AppSymbolNotebook[app,
				"DocInfo"->None,
				ops,
				Sequence@@
					FilterRules[
						DeleteCases[Import[f],
								Alternatives@@Options@AppSymbolNotebook],
						Options@AppSymbolNotebook
						]
					],
		e_:>
			With[{fs=AppPackageFunctions[app]},
				Notebook[
					Flatten@{
						Cell[app<>" Documentation Template","Title"],
						Cell[BoxData@RowBox@{"<<",app<>"`"},
							"Input"],
						Cell[BoxData@RowBox@{"$DocActive","=","\""<>app<>"\"",";"},
							"Input"],
						Cell["","BlockSeparator"],
						First/@#
						},
					Sequence@@Rest@First@#
					]&@
					KeyValueMap[
						SymbolPageTemplate[#2,
							Sequence@@FilterRules[{ops},
								Options@SymbolPageTemplate],
							"Usage"->Automatic,
							"Details"->Automatic,
							"Functions"->#2,
							"Examples"->Defer,
							"RelatedGuides"->{
								app<>" Overview"->app,
								#<>" Package"->#<>"Package"
								},
							"RelatedTutorials"->{
								app<>" Tutorial"
								},
							"RelatedLinks"->None
							]&,
						fs
						]
				]
		}];


(* ::Subsubsection::Closed:: *)
(*AppGenerateSymbolNotebook*)



Options[AppGenerateSymbolNotebook]=
	Options@AppSymbolNotebook;
AppGenerateSymbolNotebook[app_, ops:OptionsPattern[]]:=
	CreateDocument@
		AppSymbolNotebook[app, ops]


(* ::Subsubsection::Closed:: *)
(*AppPackageSymbolNotebook*)



Options[AppPackageSymbolNotebook]=
	Prepend[Options@SymbolPageTemplate,
		"DocInfo"->Automatic
		];
AppPackageSymbolNotebook[app_,pkg_,ops:OptionsPattern[]]:=
	Replace[OptionValue@"DocInfo",{
		Automatic:>
			AppPackageSymbolNotebook[app,pkg,
				"DocInfo"->
					AppPath[app,
						"Config",
						"DocInfo.m"],
				ops],
		f_String?FileExistsQ:>
			AppPackageSymbolNotebook[app,pkg,
				"DocInfo"->None,
				ops,
				Sequence@@
					FilterRules[
						DeleteCases[Import[f],
								Alternatives@@Options@AppPackageSymbolNotebook],
						Options@AppPackageSymbolNotebook
						]
					],
		e_:>
			With[{fs=AppPackageFunctions[app,pkg]},
				Replace[
					SymbolPageTemplate[fs,
						Sequence@@FilterRules[{ops},
							Options@SymbolPageTemplate],
						"Usage"->Automatic,
						"Details"->Automatic,
						"Functions"->fs,
						"Examples"->Defer,
						"RelatedGuides"->{
							app<>" Overview"->app,
							pkg<>" Package"->pkg<>"Package"
							},
						"RelatedTutorials"->{
							app<>" Tutorial"
							},
						"RelatedLinks"->None
						],
					Notebook[{a__},o___]:>
						Notebook[{
							Cell[app<>" Documentation Template","Title"],
							Cell[BoxData@RowBox@{"<<",app<>"`"},
								"Input"],
							Cell[BoxData@RowBox@{"$DocActive","=","\""<>app<>"\"",";"},
								"Input"],
							Cell["","BlockSeparator"],
							a
							},
							o
							]
					]
				]
		}];


(* ::Subsubsection::Closed:: *)
(*AppGeneratePackageSymbolNotebook*)



Options[AppGeneratePackageSymbolNotebook]=
	Options[AppPackageSymbolNotebook]
AppGeneratePackageSymbolNotebook[app_,pkg_,ops:OptionsPattern[]]:=
	CreateDocument@AppPackageSymbolNotebook[app, pkg, ops]


(* ::Subsubsection::Closed:: *)
(*AppGuideNotebook*)



Options[AppGuideNotebook]=
	Prepend["DocInfo"->Automatic]@
		Options@GuideTemplate;
AppGuideNotebook[app_,ops:OptionsPattern[]]:=
	Replace[OptionValue@"DocInfo",{
		Automatic:>
			AppGuideNotebook[app,
				"DocInfo"->
					AppPath[app,
						"Config",
						"DocInfo.m"],
				ops],
		f_String?FileExistsQ:>
			AppGuideNotebook[app,
				"DocInfo"->None,
				ops,
				Sequence@@
					FilterRules[
						DeleteCases[Lookup[Import[f],"GuideOptions",{}],
								Alternatives@@Options@AppGuideNotebook],
						Options@AppGuideNotebook
						]
					],
		e_:>
			With[{fs=AppPackageFunctions[app]},
				GuideTemplate[app,
					Sequence@@FilterRules[{ops},
						Options@GuideTemplate],
					"Title"->app<>" Application Overview",
					"Link"->app,
					"Abstract"->
						TemplateApply[
							"The `` app has `` subpackages and `` top-level functions",{
								app,
								Length@fs,
								Length/@fs//Total
								}],
					"Functions"->
						Flatten[List@@fs],
					"Subsections"->
						KeyValueMap[(#->(#<>"Package"))->#2&]@
							Map[Take[#,UpTo[4]]&,fs],
					"RelatedGuides"->
						Map[#->#<>"Package"&,
							Keys@fs],
					"RelatedTutorials"->
						Flatten@{
							app<>" Tutorial"
							},
					"RelatedLinks"->
						None
					]//
					Replace[
						Notebook[{a__},o___]:>
							Notebook[{
								Cell[app<>" Documentation","Title"],
								Cell[BoxData@RowBox@{"<<",app<>"`"},
									"Input"],
								Cell[BoxData@RowBox@{"$DocActive","=","\""<>app<>"\"",";"},
									"Input"],
								Cell["","BlockSeparator"],
								a
								},
								o
								]
							
						]
				]
	}];


(* ::Subsubsection::Closed:: *)
(*AppPackageGuideNotebook*)



Options[AppPackageGuideNotebook]=
	Prepend["DocInfo"->Automatic]@
		Options@GuideTemplate;
AppPackageGuideNotebook[app_,pkg_,ops:OptionsPattern[]]:=
	Replace[OptionValue@"DocInfo",{
		Automatic:>
			AppPackageGuideNotebook[app,pkg,
				"DocInfo"->
					AppPath[app,
						"Config",
						"DocInfo.m"
						],
				ops],
		f_String?FileExistsQ:>
			AppPackageGuideNotebook[app,pkg,
				"DocInfo"->None,
				ops,
				Sequence@@
					FilterRules[
						DeleteCases[Lookup[Import[f],"GuideOptions",{}],
								Alternatives@@Options@AppPackageGuideNotebook],
						Options@AppPackageGuideNotebook
						]
					],
		e_:>
			With[{fs=AppPackageFunctions[app,pkg]},
				With[{types=
					GroupBy[Keys@#,#]&@SymbolDetermineType[fs]
					},
					GuideTemplate[pkg,
						Sequence@@FilterRules[{ops},Options@GuideTemplate],
						"Title"->pkg<>" Package Overview",
						"Link"->pkg<>"Package",
						"Abstract"->
							guideAutoAbstract[
								TemplateApply[
									"in the `pkg` package",
									<|
										"pkg"->pkg
										|>
									],
								fs,
								types
								],
						"Functions"->
							fs,
						"Subsections"->
							DeleteCases[Delimiter]@
							Replace[
								guideAutoSubsections[types],
								(f_->l_):>(f->Flatten@l),
								1
								],
						"RelatedGuides"->
							{
								(app<>" Application Overview")->app
								},
						"RelatedTutorials"->
							Flatten@{
								app<>" Tutorial"
								},
						"RelatedLinks"->
							None
						]//
						Replace[
							Notebook[{a__},o___]:>
								Notebook[{
									Cell[app<>" "<>pkg,"Title"],
									Cell[BoxData@RowBox@{"<<",app<>"`"},
										"Input"],
									Cell[BoxData@RowBox@{"$DocActive","=","\""<>app<>"\"",";"},
										"Input"],
									Cell["","BlockSeparator"],
									a
									},
									o
									]
								
							]
					]
				]
		}];


(* ::Subsubsection::Closed:: *)
(*AppTutorialNotebook*)



Options[AppTutorialNotebook]=
	Prepend["DocInfo"->Automatic]@
		Options@TutorialTemplate;
AppTutorialNotebook[app_,ops:OptionsPattern[]]:=
	Replace[OptionValue@"DocInfo",{
		Automatic:>
			AppTutorialNotebook[app,
				"DocInfo"->
					AppPath[app,
						"Config",
						"DocInfo.m"],
				ops],
		f_String?FileExistsQ:>
			AppTutorialNotebook[app,
				"DocInfo"->None,
				ops,
				Sequence@@
					FilterRules[
						DeleteCases[Lookup[Import[f],"TutorialOptions",{}],
								Alternatives@@Options@AppTutorialNotebook],
						Options@AppTutorialNotebook
						]
					],
		e_:>
			With[{fs=AppPackageFunctions[app]},
				TutorialTemplate[app,
					Sequence@@FilterRules[{ops},
						Options@TutorialTemplate],
					"Title"->(app<>" Tutorial"),
					"Description"->
						TemplateApply["Tutorial for the `` application",app],
					"Content"->
						KeyValueMap[
							#->{
								TemplateApply["The `` package has `` functions.",
									{#,Length@#2}],
								"These are:",
								Thread@{#2}
								}&,
							fs],
					"Functions"->
						Flatten@(Values@fs),
					"RelatedGuides"->
						Prepend[
							Map[#->#<>"PackageGuide"&,
								Keys@fs],
							(app<>" Overview")->app
							],
					"RelatedTutorials"->
						None,
					"RelatedLinks"->
						None
					]//
					Replace[
						Notebook[{a__},o___]:>
							Notebook[{
								Cell[app<>" Documentation Template","Title"],
								Cell[BoxData@RowBox@{"<<",app<>"`"},
									"Input"],
								Cell[BoxData@RowBox@{"$DocActive","=","\""<>app<>"\"",";"},
									"Input"],
								Cell["","BlockSeparator"],
								a
								},
								o
								]
							
						]
				]
		}];


(* ::Subsubsection::Closed:: *)
(*AppPackageTutorialNotebook*)



Options[AppPackageTutorialNotebook]=
	Prepend["DocInfo"->Automatic]@
		Options@TutorialTemplate;
AppPackageTutorialNotebook[app_, pkg_, ops:OptionsPattern[]]:=
	Replace[OptionValue@"DocInfo",{
		Automatic:>
			AppPackageTutorialNotebook[app,
				"DocInfo"->
					AppPath[app,
						"Config",
						"DocInfo.m"
						],
				ops],
		f_String?FileExistsQ:>
			AppTutorialNotebook[app,
				"DocInfo"->None,
				ops,
				Sequence@@
					FilterRules[
						DeleteCases[
							Lookup[Import[f],"TutorialOptions",{}],
							Alternatives@@Options@AppTutorialNotebook
							],
						Options@AppTutorialNotebook
						]
					],
		e_:>
			With[{fs=AppPackageFunctions[app, pkg]},
				TutorialTemplate[app,
					Sequence@@FilterRules[{ops},
						Options@TutorialTemplate
						],
					"Title"->(app<>" "<>pkg<>" Tutorial"),
					"Description"->
						TemplateApply[
							"Tutorial for the `` package in the `` application",
							{pkg, app}
							],
					"Content"->
						KeyValueMap[
							#->{
								TemplateApply[
									"The `` package has `` functions.",
									{pkg, Length@fs}
									],
								"These are:",
								Thread@{fs}
								}&,
							fs
							],
					"Functions"->
						fs,
					"RelatedGuides"->
						Prepend[
							Map[#->#<>"PackageGuide"&, Keys@fs],
							(app<>" Overview")->app
							],
					"RelatedTutorials"->
						None,
					"RelatedLinks"->
						None
					]//
					Replace[
						Notebook[{a__},o___]:>
							Notebook[
								{
									Cell[app<>" Documentation Template","Title"],
									Cell[BoxData@RowBox@{"<<",app<>"`"}, "Input"],
									Cell[
										BoxData@RowBox@
											{
												ToBoxes[Unevaluated[$DocActive]],"="," \""<>app<>"\"",";"
												},
										"Input"
										],
									Cell["","BlockSeparator"],
									a
									},
								o
								]
						]
				]
		}];


(* ::Subsubsection::Closed:: *)
(*AppDocumentationTemplate*)



Options[AppDocumentationTemplate]=
	Join[
		Options[AppSymbolNotebook],
		Options[AppGuideNotebook],
		Options[AppTutorialNotebook]
		];
AppDocumentationTemplate[app_, ops:OptionsPattern[]]:=
	With[{docs=AppSymbolNotebook[app, FilterRules[{ops}, Options@AppSymbolNotebook]]},
		Notebook[
			Flatten@
				{
					Cell[app<>" Documentation Template","Title"],
					Cell[BoxData@RowBox@{"<<",app<>"`"},"Input"],
					Cell[BoxData@ToBoxes@Unevaluated[$DocActive=app;],
						"Input"
						],
					Cell["","BlockSeparator"],
					Cell[app<>" Ref Pages","Chapter"],
					First@docs,
					Cell[app<>" Guide Pages","Chapter"],
					First@AppGuideNotebook[app, FilterRules[{ops}, Options@AppGuideNotebook]],
					Map[
						First@AppPackageGuideNotebook[app,#]&,
						FileBaseName/@AppPackages[app]
						],
					Cell[app<>" Tutorial Page","Chapter"],
					First@AppTutorialNotebook[app, FilterRules[{ops}, Options@AppTutorialNotebook]]
					},
			Sequence@@Rest@docs
			]
	]


(* ::Subsubsection::Closed:: *)
(*AppPackageDocumentationTemplate*)



Options[AppPackageDocumentationTemplate]=
	Join[
		Options[AppPackageSymbolNotebook],
		Options[AppPackageGuideNotebook],
		Options[AppPackageTutorialNotebook]
		];
AppPackageDocumentationTemplate[app_, pkg_, ops:OptionsPattern[]]:=
	With[
		{
			docs=AppPackageSymbolNotebook[app, FilterRules[{ops}, Options@AppSymbolNotebook]]
			},
		Notebook[
			Flatten@
				{
					Cell[app " "<>pkg<>" Package Template","Title"],
					Cell[BoxData@RowBox@{"<<",app<>"`"},"Input"],
					Cell[BoxData@ToBoxes@Unevaluated[$DocActive=app;],
						"Input"
						],
					Cell["","BlockSeparator"],
					Cell[app<>" "<>pkg<>" Package Ref Pages","Chapter"],
					First@docs,
					Cell[app<>" "<>pkg<>" Package Guide Pages","Chapter"],
					First@
						AppPackageGuideNotebook[app, pkg,
							FilterRules[{ops}, Options@AppPackageGuideNotebook]],
					Cell[app<>" "<>pkg<>" Package Tutorial","Chapter"],
					First@
						AppPackageTutorialNotebook[app, pkg,
							FilterRules[{ops}, Options@AppPackageTutorialNotebook]]
					},
			Sequence@@Rest@docs
			]
	]


(* ::Subsubsection::Closed:: *)
(*AppSaveSymbolPages*)



Options[AppSaveSymbolPages]=
	Join[
		Options[AppPackageSymbolNotebook],
		Options[DocGenSaveSymbolPages]
		];
AppSaveSymbolPages[
	appName_,
	dir:(_String|_File)?DirectoryQ|Automatic:Automatic,
	extension:True|False:False,
	ops:OptionsPattern[]]:=
	With[{app=AppFromFile[appName]},
		With[{pkgs=FileBaseName/@AppPackages[app]},
			Map[
				With[{nb=
					If[TrueQ@OptionValue[Monitor],
						With[{pkg=#},
							Function[
								Null,
								Monitor[#,
									Internal`LoadingPanel[
										"Creating symbol template notebook for ``"~TemplateApply~pkg
										]
									],
								HoldFirst
								]
							],
						Identity
						]@
					CreateDocument[
						AppPackageSymbolNotebook[app,#,
							FilterRules[{ops},
								Options[AppPackageSymbolNotebook]
								]
							],
						Visible->False
						]
					},
					Function[NotebookClose[nb]; #]@
						DocGenSaveSymbolPages[
							nb,
							Replace[dir,Automatic:>AppDirectory[app,"Symbols"]],
							extension,
							FilterRules[{ops},
								Options[DocGenSaveSymbolPages]
								]
							]
					]&,
				pkgs
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*AppPackageSaveSymbolPages*)



Options[AppPackageSaveSymbolPages]=
	Join[
		Options[AppPackageSymbolNotebook],
		Options[DocGenSaveSymbolPages]
		];
AppPackageSaveSymbolPages[
	appName_,
	pkg_,
	dir:(_String|_File)?DirectoryQ|Automatic:Automatic,
	extension:True|False:False,
	ops:OptionsPattern[]]:=
	With[{app=AppFromFile[appName]},
		With[{nb=
			If[TrueQ@OptionValue[Monitor],
				Function[
					Null,
					Monitor[#,
						Internal`LoadingPanel[
							"Creating symbol template notebook"
							]
						],
					HoldFirst
					],
				Identity
				]@
			CreateDocument[
				AppPackageSymbolNotebook[app,pkg,
					FilterRules[{ops},
						Options[AppPackageSymbolNotebook]
						]
					],
				Visible->False
				]
			},
			Function[NotebookClose[nb]; #]@
				DocGenSaveSymbolPages[
					nb,
					Replace[dir,Automatic:>AppDirectory[app,"Symbols"]],
					extension,
					FilterRules[{ops},
						Options[DocGenSaveSymbolPages]
						]
					]
			]
		]


(* ::Subsubsection::Closed:: *)
(*AppSaveGuide*)



Options[AppSaveGuide]=
	Join[
		Options[AppGuideNotebook],
		Options[DocGenSaveGuide]
		];
AppSaveGuide[
	appName_, 
	dir:(_String|_File)?DirectoryQ|Automatic:Automatic,
	extension:True|False:False,
	ops : OptionsPattern[]] :=
	With[{app = AppFromFile[appName]},
		With[{nb =
			If[TrueQ@OptionValue[Monitor],
				Function[
					Null,
					Monitor[#,
						Internal`LoadingPanel[
							"Creating guide template notebook"
							]
						],
					HoldFirst
					],
				Identity
				]@
			CreateDocument[
				AppGuideNotebook[app, 
					FilterRules[{ops},
						Options[AppGuideNotebook]
						]
					], 
				Visible -> False]
			},
			Function[NotebookClose[nb]; #]@
				DocGenSaveGuide[
					nb,
					Replace[dir,Automatic:>AppDirectory[app, "Guides"]],
					extension,
					FilterRules[{ops},
						Options[DocGenSaveGuide]
						]
					]
			]
		]


(* ::Subsubsection::Closed:: *)
(*AppPackageSaveGuide*)



Options[AppPackageSaveGuide]=
	Join[
		Options[AppPackageGuideNotebook],
		Options[DocGenSaveGuide]
		];
AppPackageSaveGuide[
	appName_,
	pkg_,
	dir:(_String|_File)?DirectoryQ|Automatic:Automatic,
	extension:True|False:False,
	ops:OptionsPattern[]
	]:=
	With[{
		app=AppFromFile[appName]
		},
		With[{nb=
			If[TrueQ@OptionValue[Monitor],
				Function[
					Null,
					Monitor[#,
						Internal`LoadingPanel[
							"Creating guide template notebook"
							]
						],
					HoldFirst
					],
				Identity
				]@
			Function[Global`bleb=NotebookGet[#];#]@
			CreateDocument[
				AppPackageGuideNotebook[app,pkg,
					FilterRules[{ops},
						Options[AppPackageGuideNotebook]
						]
					],
				Visible->False
				]
			},
			Function[NotebookClose[nb];#]@
				DocGenSaveGuide[
					nb,
					Replace[dir,Automatic:>AppDirectory[app,"Guides"]],
					extension,
					FilterRules[{ops},
						Options[DocGenSaveGuide]
						]
					]
			]
		]


(* ::Subsubsection::Closed:: *)
(*AppGenerateDocumentation*)



Options[AppGenerateDocumentation]=
	Join[
		Options[AppSaveSymbolPages],
		Options[AppSaveGuide]
		];
AppGenerateDocumentation[
	app_,
	dir:(_String|_File)?DirectoryQ|Automatic:Automatic,
	extension:True|False:False,
	ops:OptionsPattern[]
	]:=
	Module[{docs=dir},
		If[extension&&dir=!=Automatic,
			Quiet@
				CreateDirectory[
					FileNameJoin@{dir,"Documentation","English"},
					CreateIntermediateDirectories->True
					];
			docs=FileNameJoin@{dir,"Documentation","English"}
			];
		AppSaveSymbolPages[app,docs,extension,ops];
		AppPackageSaveGuide[app,#,docs,extension,ops]&/@
			FileBaseName/@AppPackages[app];
		AppSaveGuide[app,docs,extension,ops];
		docs
		]


(* ::Subsubsection::Closed:: *)
(*AppPackageGenerateDocumentation*)



Options[AppPackageGenerateDocumentation]=
	Join[
		Options[AppPackageSaveSymbolPages],
		Options[AppPackageSaveGuide]
		];
AppPackageGenerateDocumentation[
	app_,
	pkg_,
	dir:(_String|_File)?DirectoryQ|Automatic:Automatic,
	extension:True|False:False,
	ops:OptionsPattern[]
	]:=
	Module[{docs=dir},
		If[extension&&dir=!=Automatic,
			Quiet@
				CreateDirectory[
					FileNameJoin@{dir,"Documentation","English"},
					CreateIntermediateDirectories->True
					];
			docs=FileNameJoin@{dir,"Documentation","English"}
			];
		AppPackageSaveSymbolPages[app,pkg,docs,extension,ops];
		AppPackageSaveGuide[app,pkg,docs,extension,ops];
		docs
		]


(* ::Subsubsection::Closed:: *)
(*AppGenerateHTMLDocumentation*)



AppGenerateHTMLDocumentation[
	app_,
	dir:(_String|_File)?DirectoryQ|Automatic:Automatic,
	which:"ReferencePages"|"Guides"|"Tutorials"|All:All,
	pattern:_String:"*",
	ops:OptionsPattern[]
	]:=
	With[{
		fils=
			Select[FileExistsQ@#&&StringMatchQ[FileBaseName[#],pattern]&]@
				FileNames[
					"*.nb",
					If[which===All,
						Replace[dir,{
							Automatic:>
								AppDirectory[app,"Documentation","English"],
							d_?DirectoryQ:>
								If[!FileNameSplit[d][[-2;;]]=={"Documentation","English"},
									FileNameJoin@{d,"Documentation","English"},
									d
									]
							}],
						Replace[dir,{
							Automatic:>
								AppDirectory[app,which],
							d_?DirectoryQ:>
								If[FileNameTake[d]=!=which,
									FileNameJoin@{
										If[!FileNameSplit[d][[-2;;]]=={"Documentation","English"},
											FileNameJoin@{d,"Documentation","English"},
											d
											],
										which
										},
									d
									]
								}]
						],
					\[Infinity]
					]
		},
		DocGenGenerateHTMLDocumentation[
			Automatic,
			fils,
			ops
			]
		];


(* ::Subsubsection::Closed:: *)
(*AppPackageGenerateHTMLDocumentation*)



AppPackageGenerateHTMLDocumentation[
	app_,
	pkg_,
	which:"ReferencePages"|"Guides"|"Tutorials"|All:All,
	pattern:_String:"*",
	ops:OptionsPattern[]]:=
	With[{
		fils=
			Select[FileExistsQ@#&&StringMatchQ[FileBaseName[#],pattern]&]@
				Join[
					AppPath[app,"Symbols",#<>".nb"]&/@AppPackageFunctions[app,pkg],
					AppPath[app,#,pkg<>".nb"]&/@{"Guides","Tutorials"}
					]
		},
		DocGenGenerateHTMLDocumentation[
			Automatic,
			fils,
			ops
			]
		];


(* ::Subsection:: *)
(*Git*)



(* ::Subsubsection::Closed:: *)
(*GitInit*)



AppGitInit[appName_:Automatic]:=
	With[{app=AppFromFile[appName]},
		With[{d=AppDirectory[app]},
			GitInit[d];
			AppRegenerateGitExclude[app];
			AppRegenerateGitIgnore[app];
			d
			]
		];


(* ::Subsubsection::Closed:: *)
(*RegenerateGitIgnore*)



AppRegenerateGitIgnore[appName_:Automatic,
	patterns:_String|{__String}:
		{
			"Packages/*.nb",
			"Packages/*/*.nb",
			"Packages/*/*/*/*.nb",
			".DS_Store"
			}]:=
	With[{
		app=
			AppFromFile[appName]
			},
		If[GitRepoQ@AppDirectory[app],
			With[{f=OpenWrite[AppPath[app,".gitignore"]]},
				WriteLine[f,
					StringJoin@Riffle[Flatten@{patterns},"\n"]
					];
				Close@f
				],
			$Failed
			]
		];


 (* ::Subsubsection::Closed:: *)
(*RegenerateGitExclude*)



AppRegenerateGitExclude[appName_:Automatic,
	patterns:_String|{__String}:{"Private/*"}]:=
	With[{
		app=
			AppFromFile[appName]
			},
		If[GitRepoQ@AppDirectory[app],
			If[Not@DirectoryQ@AppDirectory[app,".git","info"],
				CreateDirectory[AppDirectory[app,".git","info"]]
				];
			With[{f=OpenWrite[AppPath[app,".git","info","exclude"]]},
				WriteLine[f,
					StringJoin@Riffle[Flatten@{patterns},"\n"]
					];
				Close@f
				],
			$Failed
			]
		];


(* ::Subsubsection::Closed:: *)
(*RegenerateReadme*)



appREADMETemplate:=
	StringReplace[
		Import[
			PackageAppPath["Resources", "Templates", "README.md"],
			"Text"
			],{
		"`"->"`tick`",
		"$"~~l:LetterCharacter..~~"$":>"`"<>l<>"`"
		}]


Options[AppRegenerateReadme]={
	"Header"->"",
	"Footer"->""
	};
AppRegenerateReadme[appName:_String|Automatic:Automatic]:=
	With[{app=AppFromFile[appName]},
		GitHubCreateReadme[
			AppDirectory[app],
			TemplateApply[appREADMETemplate,<|
				"tick"->"`",
				"Name"->
					app,
				"FunctionCount"->
					(
						Needs[app<>"`"];
						Length@Names[app<>"`*"]
						),
				"PackageCount"->
					Length@AppPackages[app],
				"SymbolPages"->
					Replace[Length@AppSymbolPages[app],{
						0->
							"no ref pages",
						1->
							"1 ref page",
						n_:>
							ToString[n]<>" ref pages"
						}],
				"GuidePages"->
					Replace[Length@AppGuides[app],{
						0->
							"no guide pages",
						1->
							"1 guide page",
						n_:>
							ToString[n]<>" guide pages"
						}],
				"TutorialPages"->
					Replace[Length@AppTutorials[app],{
						0->
							"no tutorial pages",
						1->
							"1 tutorial page",
						n_:>
							ToString[n]<>" tutorial pages"
						}],
				"Stylesheets"->
					Replace[Length@AppStyleSheets[app],{
						0->
							"no stylesheets",
						1->
							"1 stylesheet",
						n_:>
							ToString[n]<>" stylesheet"
						}],
				"Palettes"->
					Replace[Length@AppPalettes[app],{
						0->
							"no palettes",
						1->
							"1 palette",
						n_:>
							ToString[n]<>" palettes"
						}],
				"Installer":>
					AppPacletInstallerURL@app,
				"Uninstaller":>
					AppPacletUninstallerURL@app
				|>]
			]
		]


(* ::Subsubsection::Closed:: *)
(*GitClone*)



AppGitClone[base_String]:=
	With[{
		url=
			If[StringMatchQ@MatchQ[base,"http*"],
				base,
				GitHubRepo[base]
				],
		app=
			AppFromFile[base]
		},
		GitClone[url,
			AppDirectory[app]
			]
		]


(* ::Subsubsection::Closed:: *)
(*GitCommit*)



AppGitCommit[
	appName:_String|Automatic:Automatic,
	message:_String|Automatic:Automatic,
	add:True|False:True
	]:=
	Replace[AppFromFile[appName],
		app_String:>
			With[{d=AppDirectory[app]},
				If[add,GitAdd[d,"-A"]];
				GitCommit[d,
					"Message"->
						Replace[message,
							Automatic:>
								TemplateApply[
									"Committed `` application @ ``",
									{
										app,
										StringReplace[
											DateString["ISODateTime"],
											"T"->"_"
											]}
									]
							]
					]
				]
		];


AppGitSafeCommit[
	appName:_String|Automatic:Automatic,
	message:_String|Automatic:Automatic,
	add:True|False:True
	]:=
	With[{app=AppFromFile[appName]},
		If[!FileExistsQ@AppPath[app,".gitignore"],	
			AppRegenerateGitIgnore[]
			];
		If[!FileExistsQ@AppPath[app,".git","info","exclude"],	
			AppRegenerateGitExclude[]
			];
		AppGitCommit[app,message,add]
		]


(* ::Subsubsection::Closed:: *)
(*GitHubRepo*)



$AppGitHubPrefix="";
	(*"mathematica-";*)


AppGitHubRepo[appName_, password_:None]:=
	Replace[
		AppFromFile[appName],
		s_String:>
			With[{u=Git["GetRemoteURL", AppPath[s]]},
				If[URLParse[u, "Domain"]=!="github.com",
					URL@
						GitHubPath[
							$AppGitHubPrefix<>s,
							"Password"->password
							],
					u
					]
				]
		];


(* ::Subsubsection::Closed:: *)
(*AppGitHubSetRemote*)



AppGitHubSetRemote[appName_,remote_:Automatic]:=
	With[{app=AppFromFile[appName]},
		Replace[Replace[remote,Except[_String]:>AppGitHubRepo[appName]],
			r_String:>
				(*Quiet@*)
					Check[
						Git["AddRemote", 
							AppPath[app],
							r
							],
						Git["RemoveRemote", AppPath[app],
							r
							];
						Git["AddRemote", 
							AppPath[app],
							r
							]
						]
			]
		]


(* ::Subsubsection::Closed:: *)
(*AppGitRealignRemotes*)



AppGitRealignRemotes[appName_]:=
	With[{
		app=AppFromFile[appName]
		},
		If[Git["ListRemotes", AppPath[app]]===Null,
			AppGitHubSetRemote[AppDirectory[app]]
			];
		Git["Fetch", AppPath[app]];
		Git["Reset", AppPath[app], "origin/master"];
		Git["Checkout", AppPath[app], "origin/master"];
		];


(* ::Subsubsection::Closed:: *)
(*GitHubConfigure*)



AppGitHubConfigure[appName_:Automatic]:=
	Catch@
		Module[{app=AppFromFile[appName],repo,repoExistsQ},
			repo=AppGitHubRepo[app];
			If[repo===$Failed,
				Throw[$Failed]
				];
			If[!GitRepoQ@AppDirectory[app],
				AppGitInit[app];
				AppGitHubSetRemote[app, repo];
				repoExistsQ=Between[URLRead[repo,"StatusCode"],{200,299}];
				If[repoExistsQ,
					AppGitRealignRemotes[app]
					]
				];
			If[Git["RepoQ", AppDirectory[app]],
				If[!ValueQ[repoExistsQ],
					repoExistsQ=Between[URLRead[repo, "StatusCode"],{200,299}]
					];
				If[!repoExistsQ,
					GitHub["Create", $AppGitHubPrefix<>app, "ImportedResult"];
					AppGitHubSetRemote[app,repo]
					];
				repo
				]
			];


(* ::Subsubsection::Closed:: *)
(*GitHubPush*)



AppGitHubPush[appName_:Automatic]:=
	With[{app=AppFromFile[appName]},
		If[GitRepoQ@AppDirectory[app],
			Git["PullOrigin", AppPath@app];
			Block[{$GitHubEncodePassword=True},
				GitHub["Push", AppDirectory[app]]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*GitHubDelete*)



AppGitHubDelete[appName_]:=
	With[{app=AppFromFile[appName]},
		If[GitRepoQ@AppPath[app],
			With[{r=AppGitHubRepo[app]},
				With[{res=GitHub["Delete", URLParse[r, "Path"][[-1]]]},
					If[res["StatusCode"]<400,
						Git["RemoveRemote", AppPath[app], r];
						Success["Removed", Prepend[res, "Repository"->r]],
						Failure["NotRemoved", res]
						]
					]
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*GitHubCreateRelease*)



Options[AppGitHubCreateRelease]:=
	Options[AppGitHubCreateRelease]=
		Join[
			GitHub["CreateRelease", "Options"],
			{
				"SubmitPaclet"->True
				}
			];
AppGitHubCreateRelease[
	app_, 
	rname:_String|Automatic:Automatic, 
	ops:OptionsPattern[]
	]:=
	Module[
		{
			repo=URLBuild@Normal@GitHub["Path", AppGitHubRepo[app]],
			release,
			paclet,
			asset
			},
		release=
			GitHub["CreateRelease", 
				repo, 
				Replace[rname, 
					Automatic:>"v"<>AppPacletExecute["PacletInfo", app]["Version"]
					],
				ops,
				"ResultObject"
				];
		If[!FailureQ@release,
			If[OptionValue["SubmitPaclet"]//TrueQ,
				paclet=
					PacletExecute["FindPacletFile", app, "BuildPaclets"->False];
				If[!(StringQ@paclet&&FileExistsQ@paclet), 
					paclet=AppPacletExecute["Bundle", app]
					];
				asset=
					GitHub["UploadReleaseAsset",
						release["ID"],
						paclet
						];
				];
			];
		release
		]


(* ::Subsection:: *)
(*Loading*)



(* ::Subsubsection::Closed:: *)
(*AppGet*)



AppGet[appName_,pkgName_String]:=
	With[{
		app=AppFromFile[appName],
		cont=$Context
		},
		Replace[
			Names[app<>"`*`PackageAppGet"],{
				{n_, ___}:>
					Replace[
						FileNames[pkgName~~".wl"|".m",
							AppPath[app,"Packages"],
							\[Infinity]
							],
						{f_,___}:>
							ToExpression[n][ExpandFileName@f]
						],
			_:>(
				If[DirectoryQ@AppPath[app,"Packages",pkgName],
					BeginPackage[app<>"`"];
					Begin["`"<>StringTrim[StringReplace[pkgName,$PathnameSeparator->"`"],"`"]<>"`"];
					FrontEnd`Private`GetUpdatedSymbolContexts[];
					EndPackage[],
					With[{
						pkg=
							SelectFirst[
								SortBy[FileNameDepth]@
									FileNames[
										StringTrim[pkgName,".m"]<>".m",
										AppPath[app,"Packages"],
										Infinity
										],
								FileExistsQ
								]
						},
						If[FileExistsQ@pkg,
							With[{
								pkCont=
									StringReplace[
										app<>"`"<>
											StringReplace[
												FileNameDrop[DirectoryName@pkg,
													FileNameDepth@AppDirectory[app,"Packages"]],
												$PathnameSeparator->"`"
												]<>"`",
										"``"->"`"
										]
								},
								BeginPackage[pkCont]
								];
							$ContextPath=
								DeleteDuplicates@
									Join[
										Replace[
											ToExpression[
												$Context<>"PackageScope`Private`$PackageContexts"
												],
											Except[{__String}]->{}
											],
										$ContextPath
										];
							CheckAbort[
								Get@pkg;
								EndPackage[],
								EndPackage[];
								Catch[
									Catch[
										Do[
											If[i<100,
												If[$Context===cont,Throw[$Context,"success"],End[]],
												Throw[$Failed,"fail"]
												],
											{i,1000}
											],
										"fail",
										Begin[cont]&
										],
									"success"
									];
								]
							]
						]
					];
				Catch[
					Catch[
						Do[
							If[i<100,
								If[$Context===cont, Throw[$Context,"success"],End[]],
								Throw[$Failed,"fail"]
								],
							{i,1000}
							],
						"fail",
						Begin[cont]&
						],
					"success"
					]
				)
		}]
	];
AppGet[appName_,pkgName:{__String}]:=
	AppGet[appName,FileNameJoin@pkgName];
AppGet[appName_,Optional[Automatic,Automatic]]:=
	AppGet[appName,FileBaseName@NotebookFileName[]];
AppGet[Optional[Automatic,Automatic]]:=
	With[{app=FileNameTake[NotebookFileName[],{FileNameDepth@$AppDirectory+1}]},
		AppGet[app,Automatic]
		];


(* ::Subsubsection::Closed:: *)
(*AppNeeds*)



If[Not@AssociationQ@$AppLoadedPackages,
	$AppLoadedPackages=<||>
	];
AppNeeds[appName_,pkgName_String]:=
	If[!Lookup[$AppLoadedPackages,Key@{appName,pkgName},False],
		$AppLoadedPackages[{appName,pkgName}]=True;
		AppGet[appName,pkgName];
		];
AppNeeds[appName_,Optional[Automatic,Automatic]]:=
	AppNeeds[appName,FileBaseName@NotebookFileName[]];
AppNeeds[Optional[Automatic,Automatic]]:=
	With[{app=FileNameTake[NotebookFileName[],{FileNameDepth@$AppDirectory+1}]},
		AppNeeds[app,Automatic]
		];


(* ::Subsubsection::Closed:: *)
(*AppFromFile*)



AppFromFile[f_String]:=
	With[{
		splitPath=FileNameSplit[DirectoryName[ExpandFileName@f]]
		},
		Replace[
			SelectFirst[Range[Length@splitPath,1,-1],
				FileExistsQ@FileNameJoin@Append[Take[splitPath,#], "PacletInfo.m"]&,
				Which[
					StringMatchQ[ExpandFileName@f,$AppDirectory~~__],
						FileNameTake[
							FileNameDrop[f,FileNameDepth@$AppDirectory],
							1
							],
					StringMatchQ[f,"http*"~~"/"~~WordCharacter..],
						URLParse[f]["Path"]//Last,
					MemberQ[FileNameTake/@AppNames["*", False], f],
						f,
					Length@PacletManager`PacletFind[f]>0,	
						PacletManager`PacletFind[f][[1]]["Location"]//FileBaseName,
					True,
						$Failed
					]
				],
			i_Integer:>
				splitPath[[i]]
			]
		];
AppFromFile[nb_NotebookObject]:=
	Replace[Quiet@NotebookFileName[nb],
		s_String:>
			AppFromFile[s]
		];
AppFromFile[Optional[Automatic,Automatic]]:=
	AppFromFile@InputNotebook[];


(* ::Subsubsection::Closed:: *)
(*AppPackageOpen*)



AppPackageOpen[app_:Automatic,pkg_]:=
	Replace[AppPackage[app,pkg<>".m"],{
		f_String?FileExistsQ:>
			SystemOpen@f,
		_->$Failed
		}];
AppPackageOpen[Optional[Automatic,Automatic]]:=
	Replace[Quiet@NotebookFileName[],
		f_String:>
			AppPackageOpen[Automatic,
				FileBaseName@f
				]
		]


(* ::Subsubsection::Closed:: *)
(*AppPackagePullDeclarationsAction*)



AppPackagePullDeclarationsAction//Clear
AppPackagePullDeclarationsAction[
	Hold[
		_Begin|_BeginPackage|
			CompoundExpression[_Begin|_BeginPackage,___]
		]
	]:=
	Throw[Begin];
AppPackagePullDeclarationsAction[e:Except[Hold[Expression]]]:=
	Sow@e;


AppPackagePackagePullDeclarations[
	pkgFile_,
	casePattern_
	]:=
		Cases[
			Reap[
				With[{f=OpenRead[pkgFile]},
					CheckAbort[
						Catch@
							Do[
								If[
									Length[
										ReadList[
											f,
											AppPackagePullDeclarationsAction@Hold[Expression],
											1
											]
										]===0,
										Throw[EndOfFile]
									],
								Infinity
								];
						Close[f],
						Close[f]
						]
					]
				][[2,1]],
			casePattern,
			Infinity
			]


(* ::Subsubsection::Closed:: *)
(*AppPackageFunctions*)



AppPackageFunctions[app:_String, pkgFile_String?FileExistsQ]:=
	With[{
		cont=
			StringTrim[app, "`"]<>"`"
		},
		Block[{
			pkgFuncCheckedCache=<||>,
			$Context=
				cont<>"Private`",
			$ContextPath=
				Join[
					Replace[
						ToExpression[cont<>"PackageScope`Private`$PackageContexts"],
						Except[{__String}]->{}
						],
					{
						cont,
						"System`"
						}
					]
			},
			AppPackagePackagePullDeclarations[
				pkgFile,
				s_Symbol?(
					Function[sym,
						Not@KeyMemberQ[pkgFuncCheckedCache,Hold[sym]]&&
							With[
								{
									v=
										If[cont===None,
											!StringMatchQ[
												Quiet[Context[sym]],
												"System`"|("*`*Private*")
												],
											With[{pcont=Quiet[Context[sym]]},
												StringMatchQ[pcont, cont<>"*"]&&
													!StringContainsQ[pcont,"Private`"]	
												]
											]
									},
								pkgFuncCheckedCache[Hold[sym]]=v
								],
						HoldFirst
						]
						):>
						ToString[Unevaluated[s]]
				]
			]
		];
AppPackageFunctions[
	app_String,
	path_String
	]:=
	With[{pkg=AppPackage[app, StringTrim[path,".m"]<>".m"]},
		AppPackageFunctions[app, pkg]/;FileExistsQ[pkg]
		];
AppPackageFunctions[app_, paths:{__String}]:=
	AssociationMap[
		AppPackageFunctions[app,#]&,
		paths
		];
AppPackageFunctions[app_String]:=
	AppPackageFunctions[app, AppPackages[app]]


(* ::Subsubsection::Closed:: *)
(*AppFunctionPackage*)



AppFunctionPackage//Clear


AppFunctionPackage[app_:Automatic,f:{__String}]:=
	With[{funcs=AppPackageFunctions[app]},
		AssociationMap[
			Replace[Keys@Select[funcs,MemberQ[#]],{
				{}->None,
				{p_}:>p
				}]&,
			f
			]
		];
AppFunctionPackage[app_:Automatic,f_String]:=
	First@AppFunctionPackage[{f}];
AppFunctionPackage[app_:Automatic,f:{(_Symbol|_String)..}]:=
	AppFunctionPackage[
		Replace[app,
			Automatic:>
				FirstCase[Hold@f,s_Symbol:>StringTrim[Context[s],"`"],"System`",{2}]
			],
		First/@
			Replace[
				Thread[Hold[f]],
				Hold[s_Symbol]:>Hold[SymbolName[Unevaluated@s]],
				1]//Evaluate
		];
AppFunctionPackage[app_:Automatic,f_Symbol]:=
	AppFunctionPackage[
		Replace[app,
			Automatic:>StringTrim[Context[f],"`"]
			],
		SymbolName[Unevaluated@f]
		];
AppFunctionPackage[app_:Automatic,f:{__HoldPattern}]:=
	Replace[Thread[f,HoldPattern],
		Verbatim[HoldPattern][s_]:>
			AppFunctionPackage[app,s]
		];
AppFunctionPackage[app_:Automatic,e_]/;!TrueQ[AppFunctionPackage$recurseProtect]:=
	Block[{AppFunctionPackage$recurseProtect=True},
		AppFunctionPackage[app,Evaluate[e]]
		];
AppFunctionPackage~SetAttributes~HoldAll


(* ::Subsubsection::Closed:: *)
(*AppFunctionDependencies*)



functionCallChain[conts_,function_]:=
	With[{cpats=Alternatives@@Map[#<>"*"&,conts]},
		HoldPattern@@@
			FixedPoint[
				Union[#,
					Cases[
						Flatten@
							(Through[
								Map[Apply, {DownValues,UpValues,OwnValues,SubValues}]@#
								]&/@#),
						s_Symbol?(
							Function[Null,
								Quiet[
									StringMatchQ[Context[#],cpats]&&
									Length[
										Flatten@
											Through[
												Map[Apply,
													{DownValues, UpValues, OwnValues, SubValues}
													]@Hold[#]
												]
										]>0
									],
								HoldFirst
								]
							):>Hold[s],
						\[Infinity],
						Heads->True
						]
					]&,
				Flatten@List@Thread@Hold[function],
				50
				]
		];
functionCallChain~SetAttributes~HoldRest


AppFunctionDependencies//ClearAll


AppFunctionDependencies[app_, function:_Symbol|{__Symbol}]:=
	With[{conts=
		{# ,#<>"Private`"}&@
			Quiet@
				Extract[Flatten@List@Thread@Hold[function], {1,1}, Context]
		},
		Replace[
			AppFunctionPackage[
				app,
				Select[
					functionCallChain[conts, function],
					With[{c=Alternatives@@conts},
						Quiet[
							With[{cont=Context@@#},
								StringStartsQ[cont, c]&&
									StringFreeQ[cont, "`Private`"|"`PackagePrivate`"]
								]
							]&
						]
					]
				],
		{
			a_Association:>
				GroupBy[First->Last]@
					KeyValueMap[Thread[#2->#]&,a],
			_:>
				<||>
			}]
		];
AppFunctionDependencies[app_:Automatic,f_]/;
	!TrueQ[AppFunctionDependencies$recurseProtect]:=
	Block[{AppFunctionDependencies$recurseProtect=True},
		AppFunctionDependencies[app,Evaluate[f]]
		];
AppFunctionDependencies~SetAttributes~HoldAll


(* ::Subsubsection::Closed:: *)
(*AppPackageDependencies*)



(* ::Text:: *)
(*Need better dependency loading*)



AppPackageDependencies[app_, pkg:_String|{__String}]:=
	(
		AppNeeds[app, #]&/@AppPackages[app];
		AppFunctionDependencies[
			app,
			ToExpression[
				Names[
					app<>"`*`"<>#&/@
						Flatten@Apply[List, AppPackageFunctions[app, pkg]]
					],
				StandardForm,
				Function[
					Null,
					If[Length@Flatten@
								Through[
									Map[Apply, {DownValues,UpValues,OwnValues,SubValues}]@
										Hold[#]
									]==0,
						Nothing,
						#
						],
					HoldFirst
					]
				]
			]
		);
AppPackageDependencies[app_:Automatic, f_Symbol]:=
	AppPackageDependencies[
		Replace[app,
			Automatic:>
				StringSplit[Context[f], "`"][[1]]
			],
		AppFunctionPackage[app, f]
		];
AppPackageDependencies[app_]:=
	AppPackageDependencies[app, AppPackages[app]]


(* ::Subsubsection::Closed:: *)
(*AppGenerateTestingNotebook*)



AppGenerateTestingNotebook[app_]:=
	Notebook[{
		Cell[app<>" Testing","CodeChapter"],
		Cell[BoxData@RowBox@{"<<",app<>"`"},"CodeInput"],
		MapIndexed[
			Cell[
				CellGroupData[Flatten@{
					Cell[First@#,"Section"],
					Cell[BoxData@RowBox@{
							"AppGet","[","\""<>app<>"\"",",",
							"\""<>First@#<>"\"","]"
							},
						"CodeInput"
						]
					},
					If[First@#2==1,Open,Closed]
					]
				]&,
			Normal@AppPackageFunctions[app]
			]
		},
		StyleDefinitions->
			FrontEnd`FileName[Evaluate@{$PackageName},"CodeNotebook.nb"]
		];
AppGenerateTestingNotebook[Optional[Automatic,Automatic]]:=
	AppGenerateTestingNotebook[AppFromFile[]]


(* ::Subsection:: *)
(*ZIP dist*)



$AppCloudExtension="applications";
$AppBackupDirectoryName="_appcache"


(* ::Subsubsection::Closed:: *)
(*AppInstall*)



AppInstall[
		name_String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..]),
		loadFE_:Automatic]:=
	With[{},
		If[!DirectoryQ@AppDirectory@name,AppDownload@name];
		If[Replace[loadFE,
			Automatic:>(FileNames["*",{
				AppDirectory[name,"Palettes"],
				AppDirectory[name,"StyleSheets"]}
				]=!={})
			],
			DialogInput[Column@{
"Front end must quit to complete installation. 
Would you like to do that now?",
				Row@{
					DefaultButton["Quit Now",
						FrontEndTokenExecute@"FrontEndQuit"],
					Button["Wait",
						DialogReturn[]]
					}
				},
				WindowTitle->"Quit Mathematica"
				];
			];
		Get@FileNameJoin@{$UserBaseDirectory,"Applications",name,"Kernel","init.m"};
	];


AppInstall[try___]:=
	With[{result=AppDownload[try]},
		Replace[result,{
			_AppDownload:>$Failed,
			f_:>If[DirectoryQ@AppDirectory@FileNameTake@f,
					AppInstall@f
					];
			}]
		]


(* ::Subsubsection::Closed:: *)
(*AppDownload*)



Options[AppDownload]:=
	Options@DownloadFile;
AppDownload[
		file:File[_String?DirectoryQ]|_String?DirectoryQ,
		name:(
				_String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..])|
				Automatic
				):Automatic,
		root:File[_String?DirectoryQ]|_String?DirectoryQ|Automatic:Automatic,
		ops:OptionsPattern[]
		]:=
	With[{appName=StringReplace[
		FileBaseName@file,{
			Whitespace->"",
			Except[WordCharacter|DigitCharacter]->"$"
			}]},
			Block[{$BackupDirectoryName=$AppBackupDirectoryName},
				BackupCopyFile[file,name,Replace[root,Automatic:>$AppDirectory],ops]
				]
			];


AppDownload[
		file:(
				File[_String?(FileExtension@#==="zip"&)]|
				_String?(FileExtension@#==="zip"&)
				),
		name:(
				_String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..])|
				Automatic
				):Automatic,
		root:File[_String?DirectoryQ]|_String?DirectoryQ|Automatic:Automatic,
		ops:OptionsPattern[]
		]:=
	Block[{$BackupDirectoryName=$AppBackupDirectoryName},
		DownloadFile[file,name,Replace[root,Automatic:>$AppDirectory],ops]
		];


AppDownload[
		file:(_CloudObject|_URL|_String),
		name:(
				_String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..])|
				Automatic
				):Automatic,
		root:File[_String?DirectoryQ]|_String?DirectoryQ|Automatic:Automatic,
		ops:OptionsPattern[]
		]:=
	Block[{$BackupDirectoryName=$AppBackupDirectoryName},
		DownloadFile[
			Replace[file,_String:>
				Switch[
					OptionValue@"DownloadFrom",
					CloudObject,
						URLBuild@{$AppCloudExtension,file},
					"Google Drive",
						FileNameJoin@{$AppDirectoryName,file}
					]
				],
			name,
			Replace[root,Automatic:>$AppDirectory],
			ops]
		];


AppDownload[
	file_,
	name:(
				_String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..])|
				Automatic
				):Automatic,
	root:File[_String?DirectoryQ]|_String?DirectoryQ,
	source:Except[_Rule],
	ops:OptionsPattern[]
	]:=
	AppDownload[file,name,root,"DownloadFrom"->source,ops];


(* ::Subsubsection::Closed:: *)
(*AppBundle*)



Options[AppBundle]:=
	Join[
		Options@CreateSyncBundle,{
		"BundleInfo"->Automatic
		}];
AppBundle[
	paths:_String|{__String},
	exportDir:_String?DirectoryQ|Automatic:Automatic,
	metadata:{(_Rule|_RuleDelayed)..}|_Assocation:{},
	ops:OptionsPattern[]]:=
	Replace[OptionValue["BundleInfo"],{
		Automatic:>
			AppBundle[paths,exportDir,metadata,
				"BundleInfo"->
					Replace[
						AppPath[First@Flatten@{paths},
							"Config","BundleInfo.m"],
						Except[_String?FileExistsQ]:>
							AppPath[First@Flatten@{paths},
								"Config","BundleInfo.wl"]
						],
				ops
				],
		f:(_String|_File)?FileExistsQ|_URL:>
			AppBundle[paths,exportDir,metadata,
				"BundleInfo"->None,
				Replace[Import[f],{
					o:{__?OptionQ}:>
						(Sequence@@FilterRules[o,Options@AppBundle]),
					_:>(Sequence@@{})
					}],
				ops
				],
		_:>
			bundleApp[paths,exportDir,metadata,ops]
		}];
Options[bundleApp]=
	Options@AppBundle;
bundleApp[paths_,
	exportDir:_String?DirectoryQ|Automatic:Automatic,
	metadata:{(_Rule|_RuleDelayed)..}|_Assocation:{},
	ops:OptionsPattern[]]:=
	With[{bundle=
		CreateSyncBundle[
			Table[If[!FileExistsQ@app,AppDirectory@app,app],{app,Flatten@{paths}}],
			metadata,
			FilterRules[{
				ops,
				Directory->
					Automatic,
				Root->
					If[!FileExistsQ@First@Flatten@{paths},
						AppDirectory@First@Flatten@{paths},
						$AppDirectory
						]
				},
				Options@CreateSyncBundle
				]
			]},
		If[exportDir=!=Automatic,
			RenameFile[bundle,FileNameJoin@{exportDir,FileNameTake@bundle}],
			bundle
			]
		];


(* ::Subsubsection::Closed:: *)
(*AppUpload*)



(* ::CodeInput::Plain:: *)
Options[AppUpload]:=
	Join[
		Options@AppBundle,
		Options@UploadFile,
		{
			Directory->Automatic
			}
		];
AppUpload[
	appName_String,
	ops:OptionsPattern[]]:=
	With[{dir=
		Block[{
			$AppDirectoryRoot=
				Replace[
					OptionValue@Directory,
					Except[_String?DirectoryQ]:>
						$AppDirectoryRoot
					]},
			If[!FileExistsQ@appName,AppDirectory@appName,appName]
			]},
		UploadFile[
			If[FileExistsQ@appName,
				appName,
				AppBundle[appName,
					FilterRules[{ops},Options@AppBundle]]
				],
			$AppCloudExtension,
			ops
			]
		];


AppUpload[
	appName_,
	sourceLink:"Google Drive"|CloudObject|Automatic,
	ops:OptionsPattern[]
	]:=
	AppUpload[appName,
		"UploadTo"->sourceLink,
		ops]


(* ::Subsubsection::Closed:: *)
(*AppBackup*)



AppBackup[appName_]:=
	With[{
		appDir=AppDirectory[appName]
		},
		BackupFile[appDir,$AppDirectory,$AppBackupDirectoryName]
		];	


(* ::Subsubsection::Closed:: *)
(*AppIndex*)



AppIndex[]:=Table[
{"Name","LastModified"}/.First@CloudObjectInformation@o,
{o,CloudObjects@CloudObject["applications"]}
];


(* ::Subsubsection::Closed:: *)
(*AppBackups*)



AppBackups[appName_:""]:=
	FileBackups[appName,AppDirectory@$AppBackupDirectoryName];


(* ::Subsubsection::Closed:: *)
(*AppRestore*)



AppRestore[appName_]:=
	RestoreFile[
		appName,
		AppDirectory@$AppBackupDirectoryName,
		$AppDirectory
		];


(* ::Subsection:: *)
(*Project Dist*)



$AppProjectExtension="project";
$AppProjectImages="img";
$AppProjectCSS="css";


(* ::Subsubsection::Closed:: *)
(*Readme*)



Options[AppDeployReadme]=
	{
		"UploadTo"->"Paclet"
		};
AppDeployReadme[appName_,ops:OptionsPattern[]]:=
	With[{app=AppFromFile[appName]},
		If[FileExistsQ@AppPath[app,"README.md"],
			Replace[OptionValue["UploadTo"],{
				"Paclet":>
					XMLDeploy[
						MarkdownGenerate[AppPath[app,"README.md"]],
						URLBuild@{AppPacletSiteURL[app],"README"},
						Permissions->"Public"
						],
				CloudObject[o_,___]:>
					XMLDeploy[
						MarkdownGenerate[AppPath[app,"README.md"]],
						URLBuild@{o,"README"},
						Permissions->"Public"
						],
				d_String?DirectoryQ:>
					XMLExport[
						MarkdownGenerate[AppPath[app,"README.md"]],
						FileNameJoin@{d,"README.html"}
						],
				d_String?SyncPathQ:>
					XMLExport[
						MarkdownGenerate[AppPath[app,"README.md"]],
						FileNameJoin@{SyncPath[d],"README.html"}
						]
				}
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*Imgs*)



Options[AppDeployImages]=
	{
		"UploadTo"->"Paclet"
		};
AppDeployImages[appName_,ops:OptionsPattern[]]:=
	With[{app=AppFromFile[appName]},
		With[{imgFiles=
			FileNames["*."~~
				Alternatives@@ToLowerCase@Image`$ExportImageFormats,
				AppPath[app,$AppProjectExtension,$AppProjectImages]
				]
			},
			If[Length@imgFiles>0,
				Replace[OptionValue["UploadTo"],{
					"Paclet":>
						Map[
							CopyFile[File[#],
								CloudObject[
									URLBuild@{
										AppPacletSiteURL[app],
										$AppProjectExtension,$AppProjectImages,
										FileNameTake[#]
										},
									Permissions->"Public"
									]
								]&,
							imgFiles
							],
					CloudObject[o_,___]:>
						Map[
							CopyFile[File[#],
								CloudObject[
									URLBuild@{
										o,
										$AppProjectExtension,$AppProjectImages,
										FileNameTake[#]
										},
									Permissions->"Public"
									]
								]&,
							imgFiles
							],
					d_String?DirectoryQ:>
						Map[
							CopyFile[
								#,
								FileNameJoin@{
									d,
									$AppProjectExtension,$AppProjectImages,
									FileNameTake[#]
									}
								]&,
							imgFiles
							],
					d_String?SyncPathQ:>
						Map[
							CopyFile[
								#,
								FileNameJoin@{
									SyncPath[d],
									$AppProjectExtension,
									$AppProjectImages,
									FileNameTake[#]
									}
								]&,
							imgFiles
							]
					}
					]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*CSS*)



Options[AppDeployCSS]=
	{
		"UploadTo"->"Paclet"
		};
AppDeployCSS[appName_,ops:OptionsPattern[]]:=
	With[{app=AppFromFile[appName]},
		With[{cssFiles=
			FileNames["*.css",
				AppPath[app,$AppProjectExtension,$AppProjectCSS]
				]
			},
			If[Length@cssFiles>0,
				Replace[OptionValue["UploadTo"],{
					"Paclet":>
						Map[
							CopyFile[File[#],
								CloudObject[
									URLBuild@{
										AppPacletSiteURL[app],
										$AppProjectExtension,$AppProjectCSS,
										FileNameTake[#]
										},
									Permissions->"Public"
									]
								]&,
							cssFiles
							],
					CloudObject[o_,___]:>
						Map[
							CopyFile[File[#],
								CloudObject[
									URLBuild@{
										o,
										$AppProjectExtension,$AppProjectCSS,
										FileNameTake[#]
										},
									Permissions->"Public"
									]
								]&,
							cssFiles
							],
					d_String?DirectoryQ:>
						Map[
							CopyFile[
								#,
								FileNameJoin@{
									d,
									$AppProjectExtension,$AppProjectCSS,
									FileNameTake[#]
									}
								]&,
							cssFiles
							],
					d_String?SyncPathQ:>
						Map[
							CopyFile[
								#,
								FileNameJoin@{
									SyncPath[d],
									$AppProjectExtension,
									$AppProjectCSS,
									FileNameTake[#]
									}
								]&,
							cssFiles
							]
					}
					]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*HTML*)



Options[AppDeployHTML]=
	{
		"UploadTo"->"Paclet"
		};
AppDeployHTML[appName_,ops:OptionsPattern[]]:=
	With[{app=AppFromFile[appName]},
		With[{htmlFiles=
			FileNames["*.html",
				AppPath[app,$AppProjectExtension]
				]
			},
			If[Length@htmlFiles>0,
				Replace[OptionValue["UploadTo"],{
					"Paclet":>
						Map[
							CopyFile[File[#],
								CloudObject[
									URLBuild@{
										AppPacletSiteURL[app],
										$AppProjectExtension,
										FileNameTake[#]
										},
									Permissions->"Public"
									]
								]&,
							htmlFiles
							],
					CloudObject[o_,___]:>
						Map[
							CopyFile[File[#],
								CloudObject[
									URLBuild@{
										o,
										$AppProjectExtension,
										FileNameTake[#]
										},
									Permissions->"Public"
									]
								]&,
							htmlFiles
							],
					d_String?DirectoryQ:>
						Map[
							CopyFile[
								#,
								FileNameJoin@{
									d,
									$AppProjectExtension,
									FileNameTake[#]
									}
								]&,
							htmlFiles
							],
					d_String?SyncPathQ:>
						Map[
							CopyFile[
								#,
								FileNameJoin@{
									SyncPath[d],
									$AppProjectExtension,
									FileNameTake[#]
									}
								]&,
							htmlFiles
							]
					}
					]
				]
			]
		];


(* ::Subsection:: *)
(*Paclet Dist*)



(* ::Subsubsection::Closed:: *)
(*AppRegenerateUploadInfo*)



Options[AppRegenerateUploadInfo]=
	Join[
		Options@AppPacletSiteURL,
		Options@AppPacletSiteMZ
		];
AppRegenerateUploadInfo[app_String,ops:OptionsPattern[]]:=
	Export[AppPath[app,"Config","UploadInfo.m"],
		Flatten@{
			ops,
			"ServerName"->
				Automatic,
			CloudConnect->
				False
			}];


(* ::Subsubsection::Closed:: *)
(*AppPacletSiteURL*)



Options[AppPacletSiteURL]=
	Options[PacletSiteURL];
AppPacletSiteURL[ops:OptionsPattern[]]:=
	PacletSiteURL[ops];
AppPacletSiteURL[app_String,ops:OptionsPattern[]]:=
	AppPacletSiteURL[ops,"ServerName"->app];


(* ::Subsubsection::Closed:: *)
(*AppPacletSiteInfo*)



Options[AppPacletSiteInfo]=
	Options@AppPacletSiteURL;
AppPacletSiteInfo[app_String,o:OptionsPattern[]]:=
	PacletSiteInfo@
		StringReplace[
			URLBuild@{
				AppPacletSiteURL[app,o],
				"PacletSite.mz"
				},
			StartOfString~~"file:":>"file://"
			];


(* ::Subsubsection::Closed:: *)
(*AppPacletSiteBundle*)



Options[AppPacletSiteBundle]=
	DeleteDuplicatesBy[First]@
		Join[{
			"BuildRoot":>$AppDirectory,
			"FilePrefix"->Automatic
			},
			Options[PacletSiteBundle]
			];
AppPacletSiteBundle[apps__String,ops:OptionsPattern[]]:=
	PacletSiteBundle[Sequence@@Map[AppDirectory,{apps}],
		FilterRules[{
			ops,
			If[OptionValue["FilePrefix"]===Automatic,
				"FilePrefix"->First@{apps},
				Nothing
				],
			Options[AppPacletSiteBundle]
			},
			Options[PacletSiteBundle]
			]
		]


(* ::Subsubsection::Closed:: *)
(*AppPacletBundle*)



Options[AppPacletBundle]=
	DeleteDuplicatesBy[First]@
		Join[
			{
				"BuildRoot":>$AppDirectory,
				"BundleInfo"->Automatic,
				"AppRegeneratePacletInfo"->False
				},
			Options[PacletBundle]
			];
AppPacletBundle[app_String?(FileExistsQ[AppDirectory[#]]&),
	ops:OptionsPattern[]]:=
	Replace[OptionValue["BundleInfo"],{
		Automatic:>
			AppPacletBundle[app,
				"BundleInfo"->
					Replace[AppPath[First@{app},"Config","BundleInfo.m"],
						Except[_String?FileExistsQ]:>
							AppPath[First@{app},"BundleInfo.wl"]
						],
				ops
				],
		f:(_String|_File)?FileExistsQ|_URL:>
			AppPacletBundle[app,
				"BundleInfo"->None,
				ops,
				Replace[Import[f],{
					o:{__?OptionQ}:>
						(Sequence@@FilterRules[o,Options@AppPacletBundle]),
					_:>(Sequence@@{})
					}]
				],
		_:>
			PacletBundle[
				AppDirectory[app],
				FilterRules[{ops,Options[AppPacletBundle]},
					Options[PacletBundle]
					]
				]
		}];


(* ::Subsubsection::Closed:: *)
(*AppPacletInstallerURL*)



Options[AppPacletInstallerURL]=
	Options@PacletInstallerURL;
AppPacletInstallerURL[ops:OptionsPattern[]]:=
	PacletInstallerURL[ops];
AppPacletInstallerURL[app_String,ops:OptionsPattern[]]:=
	PacletInstallerURL[ops,"ServerName"->app];


(* ::Subsubsection::Closed:: *)
(*AppPacletInstaller*)



Options[AppPacletUploadInstaller]:=
	Options[PacletUploadInstaller];
AppPacletUploadInstaller[ops:OptionsPattern[]]:=
	PacletUploadInstaller[ops];
AppPacletUploadInstaller[app_,ops:OptionsPattern[]]:=
	PacletUploadInstaller[ops,"ServerName"->app]


(* ::Subsubsection::Closed:: *)
(*AppPacletUninstallerURL*)



Options[AppPacletUninstallerURL]=
	Options@PacletUninstallerURL;
AppPacletUninstallerURL[ops:OptionsPattern[]]:=
	PacletUninstallerURL[ops];
AppPacletUninstallerURL[app_String,ops:OptionsPattern[]]:=
	PacletUninstallerURL[ops,"ServerName"->app];


(* ::Subsubsection::Closed:: *)
(*AppPacletUninstaller*)



Options[AppPacletUploadUninstaller]:=
	Options[PacletUploadUninstaller];
AppPacletUploadUninstaller[ops:OptionsPattern[]]:=
	PacletUploadUninstaller[ops];
AppPacletUploadUninstaller[app_,ops:OptionsPattern[]]:=
	PacletUploadUninstaller[ops,"ServerName"->app]


(* ::Subsubsection::Closed:: *)
(*AppPacletUpload*)



(* ::Text:: *)
(*
	This is pretty much deprecated now, but it shows up in too many spots to kill just yet
*)



Options[AppPacletUpload]=
	DeleteDuplicatesBy[First]@
		Join[
			{
				"PacletFiles"->Automatic,
				"UploadInfo"->Automatic,
				"RebundlePaclets"->True,
				"UploadSiteFile"->True,
				"UploadInstaller"->False,
				"UploadInstallLink"->False,
				"UploadUninstaller"->False
				},
			Options[PacletUpload],
			Options[AppPacletBundle]
			];
AppPacletUpload[apps__String, ops:OptionsPattern[]]:=
	Replace[OptionValue["UploadInfo"], {
			Automatic:>
				AppPacletUpload[apps,
					"UploadInfo"->
						With[{app=
							If[Length@{apps}>0,
								First@{apps},
								OptionValue@"ServerName"]
							},
							If[StringQ@app,
								Replace[AppPath[app,"Config","UploadInfo.m"],
									Except[_String?FileExistsQ]:>
										AppPath[app,"UploadInfo.wl"]
									],
								None
								]
							],
					ops
					],
			f:(_String|_File)?FileExistsQ|_URL:>
				AppPacletUpload[apps,
					Sequence@@FilterRules[{ops},
						Except["UploadInfo"]
						],
					"UploadInfo"->None,
					Replace[Import[f],{
						o:{__?OptionQ}:>
							(Sequence@@
								FilterRules[
									DeleteCases[o,Alternatives@@Options@AppPacletUpload],
									Options@AppPacletUpload]),
						_:>(Sequence@@{})
						}]
					],
			_:>
				With[{
					pacletFiles=
						Replace[OptionValue["PacletFiles"],
							Automatic:>
								If[OptionValue["RebundlePaclets"]//TrueQ,
									AppPacletBundle[#,
										FilterRules[{ops},Options@AppPacletBundle]
										]&/@{apps},
									If[FileExistsQ@
											AppPath[$PacletBuildExtension,#<>".paclet"],
										AppPath[$PacletBuildExtension,#<>".paclet"],
										AppPacletBundle[#,
											FilterRules[{ops},
												Options@AppPacletBundle
												]]
										]&/@{apps}
									]
							],
					site=
						Replace[OptionValue["SiteFile"],
							Except[_String?FileExistsQ]:>
								If[Not@FileExistsQ@
									AppPath[$PacletBuildExtension,
										First@{apps}<>"-PacletSite.mz"],
									AppPacletSiteBundle[apps],
									AppPath[$PacletBuildExtension,
										First@{apps}<>"-PacletSite.mz"]
									]
							]
					},
					PacletUpload[pacletFiles,
						FilterRules[
							Flatten@{
								"ServerName"->
									Replace[OptionValue["ServerName"],{
										Automatic:>First@{apps}
										}],
								ops,
								"ServerBase"->
									Replace[OptionValue["ServerBase"],
										Automatic:>$AppUploadDefault
										],
								Options[AppPacletUpload],
								"SiteFile"->site
								},
							Options@PacletUpload
							]]
					]
			}];


(* ::Subsubsection::Closed:: *)
(*AppPacletBackup*)



Options[AppPacletBackup]=
	Options[AppPacletUpload];
AppPacletBackup[
	app_,
	server:Automatic|"Cloud"|"GoogleDrive"|"DropBox"|"OneDrive":Automatic,
	ops:OptionsPattern[]
	]:=
	AppPacletUpload[
		app,
		"ServerBase"->
			Replace[server,
				Automatic:>$AppBackupDefault
				],
		ops,
		"ServerExtension"->"backups",
		"RemovePaths"->{},
		"RemovePatterns"->".DS_Store",
		"UploadSiteFile"->False,
		"UploadInstaller"->False,
		"UploadUninstaller"->False,
		"UploadInstallLink"->False
		]


(* ::Subsubsection::Closed:: *)
(*AppPacletDirectoryAdd*)



AppPacletDirectoryAdd[app_]:=
	If[DirectoryQ@AppDirectory[app],	
		PacletDirectoryAdd@AppDirectory[app]
		];


(* ::Subsubsection::Closed:: *)
(*AppSubpacletUpload*)



Options[AppSubpacletUpload]=
	Join[
		Options@AppPacletUpload,
		Options@AppConfigureSubapp
		];
AppSubpacletUpload[
	app_:Automatic,
	name:_String|{__String},
	ops:OptionsPattern[]
	]:=
	With[{
		dir=
			AppConfigureSubapp[app,name,
				FilterRules[{
					ops,
					"PacletInfo"->{
						"Description"->
							TemplateApply["A subpaclet of ``",AppFromFile[app]]
						}
					},
					Options@AppConfigureSubapp
					]
				]
		},
		Block[{
			$AppDirectoryRoot=DirectoryName@dir,
			$AppDirectoryName=Nothing,
			appName=FileBaseName@dir
			},
			AppPacletBundle[appName];
			AppPacletUpload[appName,
				FilterRules[{
					ops
					},
					Options@AppPacletUpload
					]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*AppPacletServerPage*)



Options[AppPacletServerPage]=
	Options[PacletServerPage];
AppPacletServerPage[ops:OptionsPattern[]]:=
	PacletServerPage[ops];
AppPacletServerPage[app:Except[_?OptionQ],ops:OptionsPattern[]]:=
	AppPacletServerPage[
		"ServerName"->
			Lookup[
				Association@Flatten@{ops},
				"ServerName",
				AppFromFile@app
				],
		ops
		];


End[];



