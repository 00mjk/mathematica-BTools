(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Section:: *)
(*PackageIndex*)



(* ::Subsection:: *)
(*Index*)



PackageIndexRefresh::usage=
	"Pulls syncs down the PackageIndex";
PackageIndex::usage=
	"Symbolic wrapper for a package index";
$PackageIndexes::usage=
	"A listing of available package indexes";
$DefaultPackageIndex::usage=
	"The default package index name";
$PackageIndex::usage=
	"The current package index";
PackageIndexLoad::usage=
	"Adds the index to the $EntityStores";
PackageIndexData::usage=
	"A data function layered on top of the paclet data";
PackageAuthorData::usage=
	"A data function layered on top of the paclet author data";


(* ::Subsection:: *)
(*Edit*)



PackageIndexEdit::usage=
	"Edits the index";
PackageIndexNew::usage=
	"Adds a new Entity to the index";
PackageIndexExport::usage=
	"Exports the package index to a site";


(* ::Subsection:: *)
(*API*)



PackageIndexAPI::usage=
	"A web api for submitting new packages to the index";
PackageSubmitForm::usage=
	"A web interface for submitting new packages to the index";


(* ::Subsection:: *)
(*Install*)



PackageIndexInstallPaclet::usage=
	"Installs a package from the index";
PackageIndexUninstallPaclet::usage=
	"Uninstalls a package from the index";


(* ::Subsection:: *)
(*Interface*)



Begin["`Private`"];


(* ::Subsection:: *)
(*PackageIndex Setup*)



(* ::Subsubsection::Closed:: *)
(*Defaults*)



If[!AssociationQ@$PackageIndexes,
	$PackageIndexes=
		<|
			"Default"->
				<|
					"URLBase"->
						"mpmindex",
					"CloudObject"->
						True,
					"Root"->
						"PackageIndex",
					"EntityTypes"->
						{
							"PackageIndexPackage",
							"PackageIndexAuthor"
							},
					"Extensions"->
						<|
							"EntityStore"->
								"EntityStore.mx",
							"SubmissionForm"->
								"submit",
							"API"->
								"api",
							"Log"->
								"log"
							|>
					|>
			|>
		];
If[!ValueQ@$DefaultPackageIndex,
	$DefaultPackageIndex="Default"
	];
If[Length@OwnValues[$PackageIndex]==0,
	$PackageIndex:=
		PackageIndex@$DefaultPackageIndex
	]


(* ::Subsubsection::Closed:: *)
(*PackageIndex*)



validPackageIndex[PackageIndex[a_Association]]:=
	AllTrue[
		{
			"URLBase",
			"Root",
			"EntityTypes",
			"Extensions"
			}, 
		KeyMemberQ[a, #]&
		]


PackageIndex[index:_String|Automatic]:=
	PackageIndex@
		Replace[
			Replace[
				Replace[index, Automatic:>$PackageIndex],{
				s_String:>
					Lookup[$PackageIndexes, s]
				}],
			Except[_Association]:>First@$PackageIndexes
			];
(p:PackageIndex[a_Association]?validPackageIndex)[k__]:=
	a[k];
(p:PackageIndex[a_Association]?validPackageIndex)["Load"]:=
	PackageIndexLoad[p];
(p:PackageIndex[a_Association]?validPackageIndex)["Refresh"]:=
	PackageIndexLoad[p, True];
Format[PackageIndex[a_Association]]:=
	RawBoxes@
		BoxForm`ArrangeSummaryBox[
			"PackageIndex",
			PackageIndex[a],
			None,
			{
				BoxForm`MakeSummaryItem[
					{"URL: ", PackageIndexURL@PackageIndex[a]},
					StandardForm
					]
				},
			KeyValueMap[
				BoxForm`MakeSummaryItem[
					{Row@{#, ": "}, #2},
					StandardForm
					]&,
				a
				],
			StandardForm
			]


(* ::Subsubsection::Closed:: *)
(*PackageIndexURL*)



PackageIndexURI[PackageIndex[a_Association], parts:{__String}]:=
	URLBuild@Lookup[a,parts];
PackageIndexURI[index:_String|Automatic, parts:{__String}]:=
	PackageIndexURI[PackageIndex[index], parts];
PackageIndexURI[PackageIndex[a_Association], parts:{__String}, ext_]:=
	URLBuild@
		{
			PackageIndexURI[PackageIndex[a], parts],
			a["Extensions", ext]
			}


PackageIndexURL[PackageIndex[a_Association]]:=
	If[a["CloudObject"]//TrueQ,
		PackageIndexCloudObject[PackageIndex@a],
		PackageIndexURI[
			PackageIndex[a],
			{"URLBase","Root"}
			]
		]


PackageIndexCloudObject[PackageIndex[a_Association]]:=
	First@CloudObject[
		URLBuild[
			<|
				"Scheme"->"user",
				"Path"->
					Lookup[a,
						{"URLBase","Root"}
						]
				|>
			]
		];


(* ::Subsubsection::Closed:: *)
(*EntityStore*)



If[!AssociationQ@$PackageIndexEntityStores,
	$PackageIndexEntityStores=<||>
	]


PackageIndexEntityStoreURL[PackageIndex[a_Association]]:=
	Replace[PackageIndexURL[PackageIndex[a]],
		{
			CloudObject[l_,___]:>
				URLBuild@{l, a["Extensions", "EntityStore"]},
			s_String:>
				URLBuild@{s, a["Extensions", "EntityStore"]}
			}
		];
PackageIndexEntityStoreLocalURI[u_String]:=
	URLBuild@ReplacePart[URLParse[u], "Scheme"->"file"];
PackageIndexEntityStoreLocalURI[p:PackageIndex[a_Association]]:=
	PackageIndexEntityStoreLocalURI[
		URLBuild@
			{
				PackageIndexURI[p, 
					{"URLBase", "Root"}
					],
				a["Extensions", "EntityStore"]
				}
		];


PackageIndexEntityStore[PackageIndex[a_Association]]:=
	With[{u=PackageIndexEntityStoreURL[PackageIndex[a]]},
		If[!KeyMemberQ[$PackageIndexEntityStores, u],
			AppendTo[$PackageIndexEntityStores,
				u->PackageIndexEntityStoreLoad[PackageIndex[a]]
				],
			$PackageIndexEntityStores[u]
			]
		];


PackageIndexEntityStoreLoad[p:PackageIndex[a_]]:=
	With[{u=PackageIndexEntityStoreURL[p]},
		Replace[
			If[FileExistsQ@LocalObject[PackageIndexEntityStoreLocalURI[p]],
				Function[Null, 
					TimeConstrained[#, 5, 
						Get@LocalObject[PackageIndexEntityStoreLocalURI[p]]
						], 
					HoldAllComplete
					],
				Identity
				][
					If[TrueQ@a["CloudObject"],
						CloudImport[u],
						Import[u, "Package"]
						]
					],
			Except[_EntityStore]->
				$PackageIndexDefaultEntityStore
			]
		]


PackageIndexEntityStoreRefresh[p:PackageIndex[a_]]:=
	AppendTo[$PackageIndexEntityStores,
		PackageIndexEntityStoreURL[p]->
			PackageIndexEntityStoreLoad[p]
		]


(* ::Subsubsection::Closed:: *)
(*Default EntityStore*)



$PackageIndexDefaultEntityStore=
	EntityStore[{
		"Package"-><|
			"Entities"-><|
			
				|>,
			"Properties"-><|
				"Name"-><|
					"Label"->"name"
					|>,
				"Author"-><|
					"Label"->"author"
					|>,
				"Description"-><|
					"Label"->"description"
					|>,
				"HomePage"-><|
					"Label"->"home page"
					|>,
				"Location"-><|
					"Label"->"location"
					|>,
				"Keywords"-><|
					"Label"->"keywords"
					|>,
				"Label"-><|
					"Label"->"entity label",
					"DefaultFunction"->
						(#["Name"]&)
					|>
				|>,
			"Label"->
				"Mathematica package",
			"LabelPlural"->
				"Mathematica packages"
			|>,
		"PackageAuthor"-><|
			"Entities"-><|
				
				|>,
			"Properties"-><|
				"Name"-><|
					"Label"->"name"
					|>,
				"Bio"-><|
					"Label"->"bio"
					|>,
				"HomePage"-><|
					"Label"->"home page"
					|>,
				"Links"-><|
					"Label"->"links"
					|>,
				"Label"-><|
					"Label"->"entity label",
					"DefaultFunction"->
						(#["Name"]&)
					|>
				|>,
			"Label"->
				"package author",
			"LabelPlural"->
				"package authors"
				|>
			}
		];


(* ::Subsection:: *)
(*Basics*)



(* ::Subsubsection::Closed:: *)
(*PackageIndexLoad*)



PackageIndexSetEntityStores[PackageIndex[a_], es_]:=
	With[
		{
			valid=
				Select[$EntityStores,
					#==es||
					Intersection[
						Keys@Flatten@List@#[[1, "Types"]],
						a["EntityTypes"]
						]=={}&
					]
			},
			If[valid!=$EntityStores,
				$EntityStores=Prepend[valid, es];
					With[{types=es[[1, "Types"]]},
						With[
							{
								comps=
									{
										None,
										Keys@types,
										Join[
											Keys@types[[All, "Entities"]],
											Keys@types[[All, "Properties"]]
											],
										Keys@types[[All, "Properties"]],
										{"Association", "Dataset"}
										}
								},
							MapIndexed[
								PackageAddAutocompletions[
									#,
									If[#2[[1]]==1, 
										comps,
										Take[comps, 2]
										]
									]&,
									{
										PackageIndexData, 
										PackageIndexEdit, 
										PackageIndexNew
										}
								]
							]
						]
				]
		]


PackageIndexLoad[
	p:PackageIndex[a_]?validPackageIndex,
	refresh:True|False:False
	]:=
	Module[{
		u=PackageIndexEntityStoreURL[p],
		es,
		valid},
		es=
			If[refresh,
				PackageIndexEntityStoreRefresh,
				PackageIndexEntityStoreLoad
				][p];
		PackageIndexSetEntityStores[p, es]
		]


PackageIndexLoaded[PackageIndex[a_]?validPackageIndex]:=
	AnyTrue[$EntityStores,
		Keys@Flatten@List@#[[1, "Types"]]==
			a["EntityTypes"]&
		]


(* ::Subsubsection::Closed:: *)
(*Data*)



PackageIndexData::badtype="PackageIndex `` doesn't support type ``";
PackageIndexData[
	p:PackageIndex[a_]?validPackageIndex,
	type_String,
	selectors:_?OptionQ
	]:=
	With[{types=a["EntityTypes"]},
		If[!PackageIndexLoaded[p],PackageIndexLoad[p]];
		EntityList@
			EntityClass[
				type,
				selectors
				]/;If[!MemberQ[types, type], 
					Message[PackageIndexData::badtype, p, type];False, 
					True
					]
		];
PackageIndexData[
	p:PackageIndex[a_]?validPackageIndex,
	type_String,
	name_String
	]:=
	PackageIndexData[p, type, "Name"->StringMatchQ[name]];
PackageIndexData[
	p:PackageIndex[a_]?validPackageIndex,
	type_String,
	name_String|selectors:_?OptionQ, 
	properties:Repeated[(_String|{__String}), {1, 2}]
	]:=
	With[{r=PackageIndexData[p, type, name]},
		EntityValue[r,properties]/;Head[r]=!=PackageIndexData
		];


(* ::Subsection:: *)
(*Edits*)



(* ::Subsubsection::Closed:: *)
(*PackageIndexEdit*)



(PackageIndexEdit[
	p:PackageIndex[a_]?validPackageIndex,
	ent_String,
	data_Association,
	property:"Entities"|"Properties":"Entities"
	]/;If[property==="Entities",
			AllTrue[Keys@data,StringQ]&&
			StringContainsQ[First@Keys@data,"::"],
			AllTrue[Keys@data,StringQ]
			]
	):=
	Module[
		{
			types=a["EntityTypes"],
			es,
			u
			},
		CompoundExpression[
			u=PackageIndexEntityStoreURL[p];
			es=PackageIndexEntityStoreLoad[p];
			es=
				ReplacePart[es,
					{1,"Types",ent,property}->
						Merge[{
							es[ent,property],
							If[property==="Entities",
								KeySelect[
									MatchQ[
										Alternatives@@
											Keys@es[ent,"Properties"]
										]
									],
								KeySelect[
									MatchQ["Label"|"DefaultFunction"]
									]
								]/@data
							},
							Apply@Join
							]
					];
				$PackageIndexEntityStores[u]=
					es;
				If[PackageIndexLoaded[p], 
					PackageIndexSetEntityStores[p, es]
					];
				es
				]/;If[!MemberQ[types, ent], 
					Message[PackageIndexData::badtype, p, ent];False, 
					True
					];
		];
PackageIndexEdit[
	p:PackageIndex[a_]?validPackageIndex,
	ent_String,
	data:{__Association?(KeyMemberQ[#,"CanonicalName"]&)},
	property:"Entities"|"Properties":"Entities"
	]:=
	PackageIndexEdit[
		p,
		ent,
		Association[
			#["CanonicalName"]->
				KeyDrop[#,"CanonicalName"]
			&/@data
			],
		property
		];
PackageIndexEdit[
	p:PackageIndex[a_]?validPackageIndex,
	ent_String,
	data:_Association?(KeyMemberQ[#,"CanonicalName"]&),
	property:"Entities"|"Properties":"Entities"
	]:=
	PackageIndexEdit[p, ent,{data},property];
PackageIndexEdit[
	p:PackageIndex[a_]?validPackageIndex,
	ent_String,
	data:{__Association?(KeyMemberQ[#,"Name"]&&KeyMemberQ[#,"Author"]&)},
	Optional["Entities","Entities"]
	]:=
	With[
		{
			types=a["EntityTypes"]
			},
		With[{
			ents=
				Map[
					With[{d=#},
						Replace[
							Select[
								PackageIndexEntityStoreLoad[p][ent,"Entities"],
								#["Name"]==d["Name"]&&
									(
										MissingQ@d["Author"]||
											#["Author"]==d["Author"]
										)&
								],{
								assoc_Association:>
									First@Keys@assoc,
								_->None	
							}]
						]->#&,
					data
					]
			},
			With[{
				edits=
					GroupBy[Normal@ents,
						First@#===None&->(If[First@#===None,Last@#,#]&),
						Map[Association]
						]
				},
				PackageIndexNew[
					p,
					ent,
					edits[True]
					];
				PackageIndexEdit[
					p,
					ent,
					Join@@
						edits[False]
					];
				PackageIndexEntityStoreLoad[p]
				]
			]/;If[!MemberQ[types, ent], 
					Message[PackageIndexData::badtype, p, ent];False, 
					True
					];
		];
PackageIndexEdit[
	p:PackageIndex[a_]?validPackageIndex,
	ent_String,
	data:_Association?(KeyMemberQ[#,"Name"]&&KeyMemberQ[#,"Author"]&),
	Optional["Entities","Entities"]
	]:=
	PackageIndexEdit[ent,{data},"Entities"];


PackageIndexEdit[
	p:PackageIndex[a_]?validPackageIndex,
	ent:Entity[t_String,_],
	data_Association
	]:=
	PackageIndexEdit[
		EntityTypeName@ent,
		<|
			CanonicalName[ent]->data
			|>,
		"Entities"
		];


PackageIndexEdit::somany=
	"Multiple entities found for name ``. Choose one of ``";
PackageIndexEdit::nope=
	"No entities found for name ``";
(*PackageIndexEdit[
	p:PackageIndex[a_]?validPackageIndex,
	name_String,
	data_Association
	]:=
	Replace[PackageIndexData[p, name],{
		{e_}:>
			PackageIndexEdit[p, e,data],
		e:{_,__}:>
			(Message[PackageIndexEdit::ambig, name, e];$Failed),
		{}:>
			(Message[PackageIndexEdit::nope, name];$Failed)
		}];*)


(* ::Subsubsection::Closed:: *)
(*PackageIndexNew*)



PackageIndexNew[
	p:PackageIndex[a_]?validPackageIndex,
	ent_String,
	props:{__Association}
	]:=
	PackageIndexEdit[
		p,
		ent,
		Association@
			Map[
				StringJoin@{
					StringReplace[#["Name"],
						Except[WordCharacter]->""
						],
					"::",
					RandomSample[
						Join[Alphabet[],ToString/@Range[0,9]],
						5
						]
					}->#&,
				props
				],
	"Entities"
	];
PackageIndexNew[
	p:PackageIndex[a_]?validPackageIndex,
	ent_String,
	name_String,
	props___?OptionQ
	]:=
	PackageIndexNew[p,
		ent,
		{
			Association@
				Flatten@{
					"Name"->name,
					props
					}
			}
		]


(* ::Subsection:: *)
(*Web Interface*)



(* ::Subsubsection::Closed:: *)
(*PackageIndexExport*)



Options[PackageIndexExport]=
	Join[
		{
			Permissions->"Public"
			},
		Options[CloudExport]
		];
PackageIndexExport[
	p:PackageIndex[a_Association]?validPackageIndex,
	file:(_String|_File)?(DirectoryQ@DirectoryName@#&)
	]:=
	Export[file,
		PackageIndexEntityStore[p],
		"MX"
		];
PackageIndexExport[
	p:PackageIndex[a_Association]?validPackageIndex,
	uriBasic:(_String|_URL|_CloudObject|Automatic):Automatic,
	ops:OptionsPattern[]
	]:=
	With[
		{
			uri=
				Replace[uriBasic, 
					Automatic:>PackageIndexURI[p, {"Root"}, "EntityStore"]
					]
			},
		CloudExport[
			PackageIndexEntityStore[p],
			"MX",
			uri,
			ops,
			Options[PackageIndexExport]
			]
		]


(* ::Subsubsection::Closed:: *)
(*PackageIndexEntityStoreMerge*)



PackageIndexEntityStoreMerge[{e1_EntityStore, e2_EntityStore}]:=
	EntityStore@
		Merge[{ e1[[1]], e2[[1]]},
			PackageIndexEntityStoreMerge
			];
PackageIndexEntityStoreMerge[{a_Association, b_Association}]:=
	Merge[{a,b}, PackageIndexEntityStoreMerge];
PackageIndexEntityStoreMerge[{___,e_}]:=e


(* ::Subsubsection::Closed:: *)
(*PackageIndexSync*)



PackageIndexSync::usage="Sync is in progress. Try in a moment";


Options[PackageIndexSync]=
	Options[PackageIndexExport];
PackageIndexSync[
	p:PackageIndex[a_Association]?validPackageIndex,
	file:(_String|_File)?(DirectoryQ@DirectoryName@#&)
	]:=
	If[!FileExistsQ[file<>".lock"],
		If[FileExistsQ@file,
			CheckAbort[
				CreateFile[file<>".lock"];
				With[{imp=Import[file]},
					(DeleteFile[file<>".lock"];#)&@
						Export[file,
							PackageIndexEntityStore[p],
							"MX"
							]
					],
				DeleteFile[file<>".lock"]
				],
			PackageIndexExport[p, file]
			],
		$Failed
		];
PackageIndexExport[
	p:PackageIndex[a_Association]?validPackageIndex,
	uriBasic:(_String|_URL|_CloudObject|Automatic):Automatic,
	ops:OptionsPattern[]
	]:=
	With[
		{
			uri=
				Replace[uriBasic, 
					Automatic:>PackageIndexURI[p, {"Root"}, "EntityStore"]
					]
			},
		CloudExport[
			PackageIndexEntityStore[p],
			"MX",
			uri,
			ops,
			Options[PackageIndexExport]
			]
		]


(* ::Subsubsection::Closed:: *)
(*PackageIndexAPI*)



Options[PackageIndexAPI]=
	Join[{
		Permissions->"Public"
		},
		Options[CloudDeploy]
		];
PackageIndexAPI[
	p:PackageIndex[a_Association]?validPackageIndex,
	uriBase:(_String|_URL|_CloudObject|Automatic):Automatic,
	indexBase:(_String|_URL|_CloudObject|Automatic):Automatic,
	ops:OptionsPattern[]
	]:=
	With[
		{
			uri=
				PackageIndexURI[p, {"Root"},"API"],
			index=
				PackageIndexURI[p, {"Root"},"EntityStore"]
			},
		With[{$PackageIndexObject=CloudObject[index]},
			CloudDeploy[
				APIFunction[{
					"Action"->
						Restricted["String",{{"Edit","View"}}]->
							"View",
					"Type"->
						Restricted["String",{{"Package","PackageAuthor"}}]->
							"Package",
					"Data"->"Expression"-><||>
					},
					(
						$PackageIndex=
							CloudImport@$PackageIndexObject;
						If[#Action=="Edit",
							PackageIndexEdit[#Type,#Data];
							PackageIndexExport[index,ops]
							];
						Switch[#Action,
							"View",
								ExportForm[
									Flatten@{
										"Credits left:",
											$CloudCreditsAvailable,
										Style["Packages:","Subsubsection"],
										Map[
											If[!MissingQ@#["HomePage"],
												Hyperlink[#["Name"],#["HomePage"]],
												#["Name"]
												]&,
											SortBy[
												KeyMap[CanonicalName]/@
													PackageIndexData["*",
														"PropertyAssociation"],
												#Name&
												]
											]
										}//Column,
									"HTML"
									],
							"Edit",
								Length@PackageIndexData["*"]
							]
						)&
					],
				uri,
				ops,
				Options[PackageSubmitAPI]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*PackageSubmitForm*)



Options[PackageSubmitForm]=
	Join[{
		Permissions->"Public"
		},
		Options[CloudDeploy]
		];
PackageSubmitForm[
	uri:(_String|_URL|_CloudObject):PackageIndexURI["Root","SubmissionForm"],
	index:(_String|_URL|_CloudObject):PackageIndexURI["Root","EntityStore"],
	ops:OptionsPattern[]
	]:=
	With[{$PackageIndexObject=CloudObject[index]},
		CloudDeploy[
			FormFunction[{
				Style["Package Index: Submit",
					"Title"
					],
				Style["This will submit your package to the package index",
					"Text"
					],
				Style["The only required fields are the name, author and location, but a description is nice and a home page provide easy linking",
					"Text"
					],
				Style["This deployment is from a free account and so may disappear or run out of credits at any time, so try not to over-use it.",
					"Text"
					],
				Style[
					Row@{
						"If a new deployment needs to be created email",
						Spacer[2],
						Hyperlink[
							"mpmindex@gmail.com",
							"mailto:mpmindex@gmail.com?subject=New%20package%20deployment"
							]
						},
					"Text"
					],
				"Name"->"String",
				"Author"->"String",
				"Location"->"String",
				{"HomePage","Home Page"}->""->"",
				"Description"->"TextArea"->""
				},
				(
					$PackageIndex=
						CloudImport@$PackageIndexObject;
					PackageIndexEdit["Package",#];
					PackageIndexExport[index,ops];
					Flatten@{
						"Credits left:",
							$CloudCreditsAvailable,
						Style["Packages:","Subsubsection"],
						Map[
							If[!MissingQ@#["HomePage"],
								Hyperlink[#["Name"],#["HomePage"]],
								#["Name"]
								]&,
							SortBy[
								KeyMap[CanonicalName]/@
									PackageIndexData["*",
										"PropertyAssociation"],
								#Name&
								]
							]
						}//Column
					)&
				],
			uri,
			ops,
			Options[PackageSubmitForm]
			]
		];


 


(* ::Subsection:: *)
(*Log*)



PackageIndexLogFileLocalURI[u_String]:=
	URLBuild@ReplacePart[URLParse[u], "Scheme"->"file"];
PackageIndexLogFileLocalURI[p:PackageIndex[a_Association]]:=
	PackageIndexLogFileLocalURI[
		URLBuild@
			{
				PackageIndexURI[p, 
					{"URLBase", "Root"}
					],
				a["Extensions", "Log"]
				}
		];
PackageIndexLogFile[p_PackageIndex?validPackageIndex]:=
	LocalObject[
		PackageIndexLogFileLocalURI[p]
		];


PackageIndexLogGet[p_PackageIndex?validPackageIndex]:=
	Replace[
		Quiet[Get@$PackageIndexLogFile,LocalObject::nso],
		$Failed->{}
		];


PackageIndexLogEvent[
	p_PackageIndex?validPackageIndex,
	eventType_,
	args_,
	dateStamp_:Automatic,
	result_
	]:=
	(
		Put[
			Append[
				PackageIndexLogGet[p],
				{Replace[dateStamp,Automatic->Now],eventType,args}->result
				],
			PackageIndexLogFile[p]
			];
		result
		);
PackageIndexPurgeEvent[
	p_PackageIndex?validPackageIndex,
	timeStampPattern_:_,
	eventType_,
	args_
	]:=
	Put[
		DeleteCases[
			PackageIndexLogGet[p],
			{timeStampPattern,eventType,args}->_
			],
		PackageIndexLogFile[p]
		];
PackageIndexGetEvents[
	p_PackageIndex?validPackageIndex,
	eventType_,
	args_,
	timeStampPattern_:_
	]:=
	Reverse@
		SortBy[
			Select[
				PackageIndexLogFile[p],
				MatchQ[First@#,{timeStampPattern,eventType,args}]&
				],
			#[[1,1]]&
			];


PackageIndexClearLog[p_PackageIndex?validPackageIndex]:=
	Put[{}, PackageIndexLogFile[p]];


(* ::Subsection:: *)
(*PackageIndexUninstallPaclet*)



(* ::Subsubsection::Closed:: *)
(*Primary*)



Options[PackageIndexUninstallPaclet]=
	{
		"UninstallDependencies"->
			False
		};
PackageIndexUninstallPaclet[
	loc:(_String|_File)?FileExistsQ
	]:=
	PacletManager`PacletUninstall@loc;
PackageIndexUninstallPaclet::noinst=
	"Couldn't find installation for location ``";
PackageIndexUninstallPaclet[
	loc:(_String?(URLParse[#,"Scheme"]=!=None&)|_URL)
	]:=
	Replace[
		PackageIndexGetEvents[
			"Install",
			loc,
			_
			],{
		{l1_->pacs_,___}:>
			If[OptionValue["UninstallDependencies"]//TrueQ,
				PacletManager`PacletUninstall/@Flatten@{pacs};
				PackageIndexPurgeEvent@@l1;,
				PacletManager`PacletUninstall@First@Flatten@{pacs};
				PackageIndexPurgeEvent@@l1;
				If[Length@Flatten@{pacs}>1,
					PackageIndexLogEvent@@
						Append[l1,Rest@Flatten@{pacs}]
					];
				],
		{}:>
			Message[PackageIndexUninstallPaclet::noinst,loc]
		}];


(* ::Subsubsection::Closed:: *)
(*Entity*)



PackageIndexUninstallPaclet[e:Entity["Package",_],
	ops:OptionsPattern[]
	]:=
	PackageIndexUninstallPaclet[e["Location"]];


(* ::Subsubsection::Closed:: *)
(*Name*)



PackageIndexUninstallPaclet::dunno=
	"Multiple matches for name ``. Select one and uninstall with PackageIndexUninstallPaclet.";
PackageIndexUninstallPaclet::noent=
	"No matches for name ``. Find one with PackageIndexData.";
PackageIndexUninstallPaclet[
	name_String,
	ops:OptionsPattern[]
	]:=
	Replace[PackageIndexData[name],{
		{e:Entity["Package",_]}|e:Entity["Package",_]:>
			PackageIndexUninstallPaclet@e,
		e:{Entity["Package",_],___}:>(
			Message[PackageIndexUninstallPaclet::dunno,name];
			e
			),
		{}:>
			(
				Message[PackageIndexUninstallPaclet::noent,name];
				$Failed
				)
		}];


(* ::Subsection:: *)
(*PackageIndexInstallPaclet*)



PackageIndexInstallPaclet::hiauth=
	"Couldn't install package `` from ``. Try contacting `` for more info";
PackageIndexInstallPaclet::noinst=
	"Couldn't install package `` from ``";


PackageIndexInstallPaclet[
	p_PackageIndex?validPackageIndex,
	e:Entity[_,_],
	ops:OptionsPattern[]
	]:=
	Replace[{
		pac:_PacletManager`Paclet|{_PacletManager`Paclet,($Failed|PacletManager`Paclet)...}:>
		If[OptionValue["Log"],
			PackageIndexLogEvent[
				p,
				"Install",
				e["Location"],
				Flatten@{pac}
				];
			First@Flatten@{pac},
			First@pac
			]
	}]@
	Replace[
		PacletInstallPaclet[e["Location"]],{
		h:Except[
			_PacletManager`Paclet|
			{_PacletManager`Paclet,($Failed|PacletManager`Paclet)...}
			]:>
			If[MissingQ@e["Author"],
				Message[
					PackageIndexInstallPaclet::noinst,
					e["Name"],
					e["Location"]
					];
				$Failed,
				Message[
					PackageIndexInstallPaclet::hiauth,
					e["Name"],
					e["Location"],
					e["Author"]
					];
				$Failed
				]
		}];


PackageIndexInstallPaclet::dunno=
	"Multiple matches for name ``. Select one and install with PackageIndexInstallPaclet.";


PackageIndexInstallPaclet::noent=
	"No matches for name ``. Find one with PackageIndexData.";
PackageIndexInstallPaclet[
	p_PackageIndex?validPackageIndex,
	name_String,
	ops:OptionsPattern[]
	]:=
	Replace[PackageIndexData[p, name],{
		{e:Entity["Package",_]}|e:Entity["Package",_]:>
			PackageIndexInstallPaclet[p, e],
		e:{Entity["Package",_],___}:>(
			Message[PackageIndexInstallPaclet::dunno,name];
			e
			),
		{}:>
			(
				Message[PackageIndexInstallPaclet::noent,name];
				$Failed
				)
		}];


End[];



