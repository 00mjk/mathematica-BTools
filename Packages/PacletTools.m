(* ::Package:: *)


(* ::Title:: *)
(*AppBuilder Package*)

(* ::Text::GrayLevel[.5]:: *)
(*Autogenerated BTools package*)

(* ::Section:: *)
(*PacletTools*)



(* ::Subsubsection::Closed:: *)
(*Paclets*)



PacletInfo::usage=
	"Extracts the Paclet from a PacletInfo.m file";
PacletInfoAssociation::usage=
	"Converts a Paclet into an Association";
PacletExpression::usage=
	"Generates a Paclet expression for a directory";
PacletExpressionBundle::usage=
	"Bundles a PacletExpression into a PacletInfo.m file";
PacletBundle::usage=
	"Bundles a paclet site from a directory in a standard build directory";


(* ::Subsubsection::Closed:: *)
(*Paclet Sites*)



PacletSiteURL::usage=
	"Provides the default URL for a paclet site";
PacletSiteInfo::usage=
	"Extracts a PacletSite from a .paclet or PacletSite.mz file";
PacletSiteInfoDataset::usage=
	"Formats a PacletSite into a Dataset";
PacletSiteBundle::usage=
	"Bundles a PacletSite.mz from a collection of PacletInfo specs";


(* ::Subsubsection::Closed:: *)
(*Installers*)



PacletInstallerURL::usage=
	"Provides the default URL for a paclet installer";
PacletUploadInstaller::usage=
	"Uploads the paclet installer script";
PacletUninstallerURL::usage=
	"Provides the default URL for a paclet installer";
PacletUploadUninstaller::usage=
	"Uploads the paclet installer script";


(* ::Subsubsection::Closed:: *)
(*Uploads*)



PacletUpload::usage=
	"Uploads a paclet to a server";
PacletSiteInstall::usage=
	"Installs from the Installer.m file if possible";
PacletSiteUninstall::usage=
	"Uninstalls from the Uninstaller.m file if possible";


Begin["`Private`"];


$PacletBuildExtension=
	"_paclets";
$PacletExtension="paclets";


(* ::Subsection:: *)
(*Paclets*)



PacletInfoAssociation[PacletManager`Paclet[k__]]:=
	With[{o=Options[PacletExpression]},
		KeySortBy[First@FirstPosition[o,#]&]
		]@
		With[{base=
			KeyMap[Replace[s_Symbol:>SymbolName[s]],<|k|>]
			},
			ReplacePart[base,
				"Extensions"->
					AssociationThread[
						First/@base["Extensions"],
						Association@*Rest/@base["Extensions"]
						]
				]
			];
PacletInfoAssociation[infoFile_]:=
	Replace[PacletInfo[infoFile],{
		p:PacletManager`Paclet[__]:>
			PacletInfoAssociation@p,
		_-><||>
		}];
PacletInfo[infoFile_]:=
	With[{pacletInfo=
		Replace[infoFile,
			d_String?DirectoryQ:>
				FileNameJoin@{d,"PacletInfo.m"}
			]
		},
		If[FileExistsQ@pacletInfo,
			Begin["pacletInfoDump`"];
			(End[];Map[SymbolName@First@#->Last@#&,#])&@Import[pacletInfo],
			PacletManager`Paclet[]
			]
		];


Options[PacletDocsInfo]={
	"Language"->"English",
	"Root"->None,
	"LinkBase"->None,
	"MainPage"->None(*,
	"Resources"\[Rule]None*)
	};
PacletDocsInfo[ops:OptionsPattern[]]:=
	SortBy[DeleteCases[DeleteDuplicatesBy[{ops},First],_->None],
		With[{o=Options@PacletDocsInfo},Position[o,First@#]&]];
PacletDocsInfo[dest_String?DirectoryQ,ops:OptionsPattern[]]:=
	With[{lang=
		FileBaseName@
			SelectFirst[
				FileNames["*",FileNameJoin@{dest,"Documentation"}],
				DirectoryQ]},
		If[MissingQ@lang,
			{},
			PacletDocsInfo[ops,
				"Language"->
					lang,
				"MainPage"->
					Replace[
						Map[
							FileNameTake[#,-2]&,
							Replace[
								FileNames["*.nb",
									FileNameJoin@{dest,"Documentation",lang,"Guides"}],{
									{}:>
										FileNames["*.nb",
											FileNameJoin@{dest,"Documentation",lang},
											2]
								}]
							],{
						{}->None,
						p:{__}:>
							First@
								SortBy[StringTrim[p,".nb"],
									EditDistance[FileBaseName@dest,FileBaseName@#]&]
						}]
				]
			]
		];


Options[PacletExtensionData]={
	"Documentation"->Automatic,
	"Kernel"->Automatic,
	"FrontEnd"->Automatic,
	"Resource"->Automatic
	};
PacletExtensionData[pacletInfo_Association,dest_,ops:OptionsPattern[]]:=
	Merge[Merge[Last]]@{
		Replace[Lookup[pacletInfo,"Extensions"],
			Except[_Association?AssociationQ]:>
				<||>
			],
		{
			Replace[OptionValue["Documentation"],{
				Automatic:>
					If[Length@
							FileNames["*.nb",
									FileNameJoin@{dest,"Documentation"},
									\[Infinity]]>0,
						"Documentation"->
							PacletDocsInfo[dest],
						Nothing
						],
				r:_Rule|{___Rule}:>
					"Documentation"->Association@Flatten@{r},
				Except[_Association]->Nothing
				}],
			Replace[OptionValue["Kernel"],{
				Automatic:>
					"Kernel"->
						<|
								Root -> ".", 
								Context -> FileBaseName@dest<>"`"
								|>,
				r:_Rule|{___Rule}:>
					"Kernel"->Association@Flatten@{r},
				Except[_Association]->Nothing
				}],
			Replace[OptionValue["FrontEnd"],{
				Automatic:>
					If[Length@
							FileNames["*.nb",
									FileNameJoin@{dest,"FrontEnd"},
									\[Infinity]]>0,
							"FrontEnd"->
								If[
									DirectoryQ@
										FileNameJoin@{dest,
											"FrontEnd",
											"TextResources"
											}||
									DirectoryQ@
										FileNameJoin@{dest,
											"FrontEnd",
											"SystemResources"
											},
									<|Prepend->True|>,
									<||>
									],
							Nothing
							],
				r:_Rule|{___Rule}:>
					"FrontEnd"->Association@Flatten@{r},
				Except[_Association]->Nothing
				}],
			Replace[OptionValue["Resource"],{
				Automatic:>
					If[Length@
							Select[
								FileNames["*",
									FileNameJoin@{dest,"Data"},
									\[Infinity]],
								Not@*DirectoryQ
								]>0,
							"Resource"->
								<|
									"Root" -> "Data",
									"Resources" -> 
										Map[
											FileNameDrop[#,
												FileNameDepth[dest]+1
												]&,
											Select[
												FileNames["*",
													FileNameJoin@{dest,"Data"},
													\[Infinity]]>0,
												Not@*DirectoryQ
												]
											]
									|>,
							Nothing
							],
				r:_Rule|{___Rule}:>
					"Resource"->Association@Flatten@{r},
				Except[_Association]->Nothing
				}]
			}
		};


Options[PacletExpression]=
	Join[
		{
			"Name"->"MyPaclet",
			"Version"->Automatic,
			"Creator"->Automatic,
			"Description"->Automatic,
			"Root"->Automatic,
			"WolframVersion"->Automatic,
			"Internal"->Automatic,
			"Loading"->Automatic,
			"Qualifier"->Automatic,
			"BuildNumber"->Automatic,
			"Extensions"->Automatic
			},
		Options@PacletExtensionData
		];
PacletExpression[ops:OptionsPattern[]]:=
	PacletManager`Paclet@@
		SortBy[DeleteCases[DeleteDuplicatesBy[{ops},First],_->None],
			With[{o=Options@PacletExpression},Position[o,First@#]&]
			];


PacletExpression[dir]~~`Package`addUsage~~
	"generates a Paclet expression from dir";
PacletExpression[
	dest_String?DirectoryQ,
	ops:OptionsPattern[]]:=
	With[{pacletInfo=PacletInfoAssociation[dest]},
		PacletExpression[
			Sequence@@FilterRules[{ops},
				Except["Kernel"|"Documentation"|"Extensions"|"FrontEnd"]],
			"Name"->FileBaseName@dest,
			"Extensions"->
				Replace[OptionValue["Extensions"],{
					Automatic:>
						KeyValueMap[Prepend[Normal@#2,#]&,
							PacletExtensionData[pacletInfo,
								dest,
								FilterRules[{ops},
									Options@PacletExtensionData
									]
								]
							],
					Except[_List]:>
						With[{baseData=
							PacletExtensionData[pacletInfo,
								dest,
								FilterRules[{ops},
									Options@PacletExtensionData
									]
								]},
							Map[
								Replace[OptionValue[#],{
									Automatic:>
										Replace[Lookup[baseData,#],{
											a_Association:>
												Flatten@{#,Normal@a},
											_->Nothing
											}],
									r:_Rule|{___Rule}|_Association:>
										Flatten@{
											#,
											Normal@r
											},
									_->Nothing
									}]&,
								Keys@Options[PacletExtensionData]
								]
						]
					}],
			"Version"->
				Replace[OptionValue@"Version",
					Automatic:>
						With[{pointVersions=
							StringSplit[
								ToString[Lookup[pacletInfo,"Version","1.0.-1"]],
								"."
								]
							},
							StringJoin@Riffle[
								If[Length@pointVersions>1,
									Append[Most@pointVersions,
										ToString[ToExpression[Last@pointVersions]+1]
										],
									{pointVersions,"1"}],
								"."]
							]
					],
				Sequence@@Normal@pacletInfo
			]
		];


Options[PacletExpressionBundle]=
	Options[PacletExpression];
PacletExpressionBundle[paclet,dest]~~`Package`addUsage~~
	"bundles paclet into a PacletInfo.m file in dest";
PacletExpressionBundle[
	paclet_PacletManager`Paclet,
	dest_String?DirectoryQ]:=
	With[{pacletFile=FileNameJoin@{dest,"PacletInfo.m"}},
		Begin["pacletInfoDump`"];
		Block[{$ContextPath={"System`","pacletInfoDump`","PacletManager`"}},
			With[{pac=
				Replace[paclet,
					(n_->v_):>(ToExpression[n]->v),
					1]},
				Export[pacletFile,pac]
				]
			];
		End[];
		pacletFile
		];
PacletExpressionBundle[
	dest_String?DirectoryQ,
	ops:OptionsPattern[]
	]:=
	PacletExpressionBundle[
		PacletExpression[dest,ops],
		dest
		];


(* ::Subsection:: *)
(*Sites*)



Options[PacletSiteURL]={
	"ServerBase"->CloudDirectory,
	"ServerName"->Automatic,
	"ServerExtension"->Automatic,
	"Username"->Automatic,
	CloudConnect->False
	};
PacletSiteURL[ops:OptionsPattern[]]:=
	With[{ext=
		Replace[OptionValue["ServerExtension"],{
			Automatic->
				$PacletExtension,
			None->
				Nothing
			}]
		},
		Switch[OptionValue["ServerBase"],
			CloudObject|CloudDirectory,
				Replace[OptionValue@CloudConnect,{
					s_String:>(
						CloudConnect[s]
						),
					l_List:>
						CloudConnect@@l
					}];
				URLBuild@
					<|
						"Scheme"->"http",
						"Domain"->"www.wolframcloud.com",
						"Path"->{
							"objects",
							Replace[OptionValue["Username"],
								Automatic->("user-"<>$WolframUUID)
								],
							ext,
							Replace[OptionValue["ServerName"],{
								e:Except[_String]:>(Nothing)
								}]
							}
						|>,
			_CloudObject|_CloudDirectory,
				With[{o=First@OptionValue["ServerBase"]},
					URLBuild@{
						o,
						ext,
							Replace[OptionValue["ServerName"],{
								e:Except[_String]:>(Nothing)
								}]
						}
					],
			_String?(StringMatchQ[FileNameJoin@{$RootDirectory,"*"}]),
				"file://"<>
					URLBuild@Key["Path"]@URLParse@
						URLBuild@
							{
								OptionValue["ServerBase"],
								ext,
								Replace[OptionValue["ServerName"],{
									Except[_String]->Nothing
									}]
								}//StringReplace[URLDecode[#]," "->"%20"]&,
			_?SyncPathQ,
				"file://"<>
					URLBuild@Key["Path"]@URLParse@
						URLBuild@Join[{
							SyncPath[
								Replace[
									StringSplit[OptionValue["ServerBase"],
										":",2],{
									{r_,p_}:>
										StringJoin@{r,":",
											URLBuild@{
												$SyncPathExtension,
												ext,
												p}
											},
									{r_}:>
										StringJoin@{r,":",
											URLBuild@{
												$SyncPathExtension,
												ext
												}
											}
									}]
								],
							Replace[OptionValue["ServerName"],{
								Except[_String]->Nothing
								}]
							}]//StringReplace[URLDecode[#]," "->"%20"]&,
			_,
				$Failed
			]
		];


Options[PacletSiteFiles]=
	Join[{
		"MergePacletInfo"->Automatic
		},
		Options@PacletSiteURL
		];
PacletSiteFiles[infoFiles__,ops:OptionsPattern[]]:=
	DeleteCases[Except[_String|_File|_URL]]@
		Replace[Flatten@{infoFiles,OptionValue["MergePacletInfo"]},{
			s_String?DirectoryQ:>
				Which[
					FileExistsQ@FileNameJoin@{s,"PacletSite.mz"},
						FileNameJoin@{s,"PacletSite.mz"},
					FileExistsQ@FileNameJoin@{s,"PacletInfo.m"},
						FileNameJoin@{s,"PacletInfo.m"},
					True,
						Replace[FileNames["*PacletSite.mz",s],{
							{}:>
								FileNames["*PacletInfo.m",s]
							}]
					],
			s_String?(
				MatchQ[Lookup[URLParse[#],{"Scheme","Domain","Path"}]&,
					{_String,None,{__,_?(StringMatchQ[Except["."]..])}}
					]
				):>
				StringReplace[URLBuild@{s,"PacletSite.mz"},
					StartOfString~~"file:"->
						"file://"
					],
			s_String?(
				MatchQ[Lookup[URLParse[#],{"Scheme","Domain","Path"}]&,
					{None,None,{_?(StringMatchQ[Except["."]..])}}
					]):>
				StringReplace[
					URLBuild@{
						PacletSiteURL[
							"ServerName"->s,
							FilterRules[{ops},Options@PacletSiteURL]
							],
						"PacletSite.mz"
						},{
					StartOfString~~"file:"->"file://",
					"%20"->" "
					}]
			},
			1];


pacletSiteMExtract[mzFile_,dirExt_:Automatic]:=
	ExtractArchive[mzFile,
		FileNameJoin@{
			$TemporaryDirectory,
			Replace[dirExt,
				Automatic:>StringJoin@RandomSample[Alphabet[],5]
				]
			},
		"PacletSite.m"
		]


Options[PacletSiteInfo]=
	Options[PacletSiteFiles];
PacletSiteInfo[specs]~~`Package`addUsage~~
	"extracts the PacletSite info stored in specs";
PacletSiteInfo[infoFiles__,ops:OptionsPattern[]]:=
	With[{
		pacletInfos=
			Which[
				StringMatchQ[#,"file://*"],
					With[{f=FileNameJoin@URLParse[#]["Path"]},
						Which[
							FileExtension[f]=="mz",
								pacletSiteMExtract[f],
							True,
								f
							]
						],
				FileExistsQ@#,
					Which[
						FileExtension[#]=="mz",
							pacletSiteMExtract[#],
						True,
							#
						],
				URLParse[#,"Scheme"]=!=None,
					If[
						StringMatchQ[Last@URLParse[#,"Path"],
							"PacletSite.m"|"PacletInfo.m"|"PacletSite.mz"],
						Replace[
							URLDownload[#,
								FileNameJoin@{
									$TemporaryDirectory,
									Last@URLParse[#,"Path"]
									}
								],{
							s:(_String|_File)?(
								StringMatchQ[FileExtension[#],"m"]&):>
								s,
							s:(_String|_File)?(
								StringMatchQ[FileExtension[#],"mz"]&):>
								pacletSiteMExtract[s],
							e_:>
								Nothing
							}],
						With[{ext=StringJoin@RandomSample[Alphabet[],5]},
							Quiet@CreateDirectory@
								FileNameJoin@{
									$TemporaryDirectory,
									ext
									};
							pacletSiteMExtract[
								URLDownload[
									URLBuild@{#,"PacletSite.mz"},
									FileNameJoin@{
										$TemporaryDirectory,
										ext,
										"PacletSite.mz"
										}
									],
								ext
								]
							]
						],
					True,
					Nothing
				]&/@PacletSiteFiles[infoFiles,ops]//Flatten
		},
		Begin["PacletManager`"];
		With[{pacletsite=
			PacletManager`PacletSite@@
				Flatten@
					Map[
						With[{imp=
							Replace[Import[#],
								{
									PacletManager`PacletSite[p___]:>p,
									e:Except[_PacletManager`Paclet|{__PacletManager`Paclet}]:>
										(Nothing)
									}]},
							Replace[#,
								(s_Symbol->v_):>(SymbolName[s]->v),
								1]&/@Flatten@{imp}
							]&,
						pacletInfos
						]//DeleteDuplicates
			},
			End[];
			DeleteCases[pacletsite,Except[_PacletManager`Paclet]]
			]
		];


PacletSiteInfoDataset::usages="";


PacletSiteInfoDataset[site]~`Package`addUsage~
	"formats a Dataset from the PacletInfo in site";
PacletSiteInfoDataset[files]~`Package`addUsage~
	"formats from the PacletSiteInfo in files";


Options[PacletSiteInfoDataset]=
	Options[PacletSiteInfo];
PacletSiteInfoDataset[PacletManager`PacletSite[p___]]:=
	Dataset@Map[PacletInfoAssociation,{p}];
PacletSiteInfoDataset[files__,ops:OptionsPattern[]]:=
	PacletSiteInfoDataset[PacletSiteInfo[files,ops]];


Options[PacletSiteBundle]=
	Join[{
		"BuildRoot":>$TemporaryDirectory,
		"FilePrefix"->None
		},
		Options@PacletSiteInfo
		];
PacletSiteBundle[infoFiles]~~`Package`addUsage~~
	"bundles the PacletInfo.m files found in infoFiles into a compressed PacletSite file";
PacletSiteBundle[infoFiles__String,ops:OptionsPattern[]]:=
	Export[
		FileNameJoin@{
			OptionValue["BuildRoot"],
			$PacletBuildExtension,
			Replace[OptionValue["FilePrefix"],{
				Automatic:>
					With[{f=First@{infoFiles}},
						If[StringMatchQ[FileNameTake[f],"*.*"],
							DirectoryName[f],
							FileBaseName[f]
							]
						]<>"-",
				s_String:>(s<>"-"),
				_->""
				}]<>"PacletSite.mz"
			},
		PacletSiteInfo[infoFiles,
			FilterRules[{ops},
				Options@PacletSiteInfo
				]
			],
		{"ZIP", "PacletSite.m"}
		];


PacletBundle[dir]~`Package`addUsage~
	"creates a .paclet file from dir and places it in the default build directory";
Options[PacletBundle]={
	"RemovePaths"->{},
	"RemovePatterns"->".DS_Store",
	"BuildRoot":>$TemporaryDirectory
	};
PacletBundle[dir:(_String|_File)?DirectoryQ,ops:OptionsPattern[]]:=
	With[{pacletDir=
			FileNameJoin@{
				OptionValue["BuildRoot"],
				$PacletBuildExtension,
				FileBaseName@dir
				}
			},
		If[!FileExistsQ@DirectoryName[pacletDir],
			CreateDirectory@DirectoryName[pacletDir]
			];
		If[FileExistsQ@pacletDir,
			DeleteDirectory[pacletDir,DeleteContents->True]
			];
		CopyDirectory[dir,pacletDir];
		Do[
			With[{p=If[Not@FileExistsQ@path,FileNameJoin@{pacletDir,path},path]},
				If[DirectoryQ@p,
					DeleteDirectory[p,
						DeleteContents->True],
					If[FileExistsQ@p,DeleteFile[p]]
					]
				],
			{path,
				Join[
					Flatten[{OptionValue["RemovePaths"]},1],
					FileNameDrop[#,FileNameDepth@pacletDir]&/@
						FileNames[OptionValue["RemovePatterns"],pacletDir,\[Infinity]]
					]}
			];
		With[{pacletFile=PacletManager`PackPaclet[pacletDir]},
			pacletFile
			]
		];


(* ::Subsection:: *)
(*Installers*)



Options[PacletInstallerURL]=
	Options@PacletSiteURL;
PacletInstallerURL[ops:OptionsPattern[]]:=
	StringReplace[
		URLBuild@{PacletSiteURL[ops],"Installer.m"},
		StartOfString~~"file:"->"file://"
		];


Options[PacletInstallerScript]:=
	DeleteDuplicatesBy[First]@
		Join[
			Options@PacletInstallerURL,{
			"PacletSite"->Automatic,
			"PacletNames"->Automatic
			}
			];
PacletInstallerScript[ops:OptionsPattern[]]:=
	With[{
		ps=
			Replace[OptionValue["PacletSite"],
				Automatic:>
					With[{p=
						PacletSiteURL@
							FilterRules[{ops},Options@PacletSiteURL]
						},
						If[URLParse[p,"Scheme"]==="file",
							FileNameJoin@URLParse[p,"Path"],
							p
							]
						]
				],
		names=
			Replace[OptionValue["PacletNames"],
				Automatic:>
					Flatten@{
						Replace["Name"->{}]@
						ReplaceAll["Name",
							DeleteCases[
								List@@(
									List@@@
										PacletSiteInfo@
											Replace[OptionValue["PacletSite"],
												Automatic:>
													StringReplace[
														URLBuild@{
															PacletSiteURL@
																FilterRules[{ops},
																	Options@PacletSiteURL],
															"PacletSite.mz"
															},
														StartOfString~~"file:"->"file://"
														]
												]
									),
								Except[_Rule|{__Rule}]
								]
							]
						}
				]
		},
			Which[StringMatchQ[ps,"http:*"|"https:*"|"file:*"],
				With[{desc=
					"Paclet Server for: "<>
						Riffle[names," "]
					},
					Hold[
						PacletManager`PacletSiteAdd[ps,
							desc,
							Prepend->True
							];
						PacletManager`PacletInstall[#,
							"Site"->ps
							]&/@names
						]
					],
				StringMatchQ[ps,
					($UserBaseDirectory|$HomeDirectory|
						$BaseDirectory|$InstallationDirectory|$RootDirectory)
						~~___],
					Replace[
						Replace[
							SelectFirst[
								Thread@Hold[{
									$UserBaseDirectory,$HomeDirectory,
										$BaseDirectory,$InstallationDirectory,
										$RootDirectory}],
								StringMatchQ[ps,ReleaseHold[#]~~__]&
								],
							Hold[p_]:>
								Replace[FileNameSplit[StringTrim[ps,p]],{
									{"",s__}:>
										Hold[{p,s}],
									{s__}:>
										Hold[p,s]
									}]
							],{
						Hold[fp_]:>
							With[{desc=
								"Paclet Server for: "<>
									Riffle[names," "]
								},
								Hold[
									PacletManager`PacletSiteAdd[
										"file://"<>URLBuild@fp,
										desc,
										Prepend->True
										];
									If[$VersionNumber<11.2,
									   PacletManager`Services`Private`finishPacletSiteUpdate[
									   	{
									   		PacletManager`Private`siteURL_, 
									   		PacletManager`Private`file_, 
									   		PacletManager`Private`interactive_, 
									   		PacletManager`Private`async_, 
									   		0}
									   	] := 
									   	PacletManager`Services`Private`finishPacletSiteUpdate[
									   		{
														PacletManager`Private`siteURL, 
														PacletManager`Private`file, 
														PacletManager`Private`interactive, 
														PacletManager`Private`async, 
														200}
									   		];
									   PacletManager`Package`getTaskData[task_] := 
									   	Block[{PacletManager`Private`$inTaskDataPatch = True}, 
									   		Replace[PacletManager`Package`getTaskData[task], 
									   			{
									   				PacletManager`Private`a_, 
									   				PacletManager`Private`b_, 
									   				PacletManager`Private`c_, 
									   				PacletManager`Private`d_, 
									   				PacletManager`Private`e_, 0, 
									   				PacletManager`Private`rest__} :> 
									   				{
									   					PacletManager`Private`a, 
									   					PacletManager`Private`b, 
									   					PacletManager`Private`c, 
									   					PacletManager`Private`d, 
									   					PacletManager`Private`e, 200, 
									   					PacletManager`Private`rest}]
									   		] /; ! TrueQ[PacletManager`Private`$inTaskDataPatch]
									   	];
								   PacletManager`PacletInstall[
										#,
										"Site"->("file://"<>URLBuild@fp),
										"Asynchronous"->False
										]&/@names
									]
								]
						}],
				True,
					$Failed
				]
		];
PacletInstallerScript[
	ps_,
	names:{__String}|Automatic:Automatic,
	ops:OptionsPattern[]]:=
	PacletInstallerScript[
		"PacletSite"->ps,
		"PacletNames"->names,
		ops
		]


Options[PacletUploadInstaller]:=
	DeleteDuplicatesBy[First]@
		Join[
			Options@PacletInstallerScript,{
			Permissions->"Public"
			},
			Options@CloudExport
			];
PacletUploadInstaller[ops:OptionsPattern[]]:=
	With[{
		installerLoc=
			With[{p=
				PacletInstallerURL@
					FilterRules[{ops},Options@PacletInstallerURL]
				},
				If[URLParse[p,"Scheme"]==="file",
					FileNameJoin@URLParse[p,"Path"],
					p
					]
				],
		script=
			PacletInstallerScript@
				FilterRules[{ops},
					Options@PacletInstallerScript
					]
		},
			Which[
				StringMatchQ[installerLoc,"http:*"|"https:*"],
					(SetOptions[
						CopyFile[#,#,
							"MIMEType"->"application/vnd.wolfram.mathematica.package"
							],
						FilterRules[{ops},
							Options@CloudExport
							]
						];#)&@
						Replace[script,
							Hold[s_]:>
								CloudPut[Unevaluated[s],
									installerLoc
									]
							],
					True,
						If[Not@FileExistsQ@installerLoc,
							CreateFile[installerLoc,
								CreateIntermediateDirectories->True
								]
							];
							Replace[script,
								Hold[s_]:>
									Put[Unevaluated[s],
										installerLoc
										]
								];
						installerLoc
				]
		]


Options[PacletUninstallerURL]=
	Options@PacletSiteURL;
PacletUninstallerURL[ops:OptionsPattern[]]:=
	StringReplace[
		URLBuild@{PacletSiteURL[ops],"Uninstaller.m"},
		StartOfString~~"file:"->"file://"
		];


Options[PacletUninstallerScript]:=
	DeleteDuplicatesBy[First]@
		Join[
			Options@PacletUninstallerURL,{
			"PacletSite"->Automatic,
			"PacletNames"->Automatic
			}
			];
PacletUninstallerScript[ops:OptionsPattern[]]:=
	With[{
		ps=
			Replace[OptionValue["PacletSite"],
				Automatic:>
					With[{p=
						PacletSiteURL@
							FilterRules[{ops},Options@PacletSiteURL]
						},
						If[URLParse[p,"Scheme"]==="file",
							FileNameJoin@URLParse[p,"Path"],
							p
							]
						]
				],
		names=
			Replace[OptionValue["PacletNames"],
				Automatic:>
					Flatten@{
						ReplaceAll["Name",
							DeleteCases[
								List@@(
									List@@@
										PacletSiteInfo@
											Replace[OptionValue["PacletSite"],
												Automatic:>
													StringReplace[
														URLBuild@{
															PacletSiteURL@
																FilterRules[{ops},
																	Options@PacletSiteURL],
															"PacletSite.mz"
															},
														StartOfString~~"file:"->"file://"
														]
												]
									),
								Except[_Rule|{__Rule}]
								]
							]
						}
				]
		},
			Which[StringMatchQ[ps,"http:*"|"https:*"|"file:*"],
				Hold[
					PacletManager`PacletSiteRemove[ps];
					PacletManager`PacletUninstall[#]&/@names
					],
				StringMatchQ[ps,
					($UserBaseDirectory|$HomeDirectory|
						$BaseDirectory|$InstallationDirectory|$RootDirectory)
						~~___],
					Replace[
						Replace[
							SelectFirst[
								Thread@Hold[{
									$UserBaseDirectory,$HomeDirectory,
										$BaseDirectory,$InstallationDirectory,
										$RootDirectory}],
								StringMatchQ[ps,ReleaseHold[#]~~__]&
								],
							Hold[p_]:>
								Replace[FileNameSplit[StringTrim[ps,p]],{
									{"",s__}:>
										Hold[{p,s}],
									{s__}:>
										Hold[p,s]
									}]
							],{
						Hold[fp_]:>
							Hold[
								PacletManager`PacletSiteRemove@
									("file://"<>URLBuild@fp);
								PacletManager`PacletUninstall[#]&/@names;
								names
								]
					}],
				True,
					$Failed
				]
		];
PacletUninstallerScript[
	ps_,
	names:{__String}|Automatic:Automatic,
	ops:OptionsPattern[]]:=
	PacletUninstallerScript[
		"PacletSite"->ps,
		"PacletNames"->names,
		ops
		]


Options[PacletUploadUninstaller]:=
	DeleteDuplicatesBy[First]@
		Join[
			Options@PacletUninstallerScript,{
			Permissions->"Public"
			},
			Options@CloudExport
			];
PacletUploadUninstaller[ops:OptionsPattern[]]:=
	With[{
		installerLoc=
			With[{p=
				PacletUninstallerURL@
					FilterRules[{ops},Options@PacletUninstallerURL]
				},
				If[URLParse[p,"Scheme"]==="file",
					FileNameJoin@URLParse[p,"Path"],
					p
					]
				],
		script=
			PacletUninstallerScript@
				FilterRules[{ops},
					Options@PacletUninstallerScript
					]
		},
			Which[
				StringMatchQ[installerLoc,"http:*"|"https:*"],
					(SetOptions[
						CopyFile[#,#,
							"MIMEType"->"application/vnd.wolfram.mathematica.package"
							],
						FilterRules[{ops},
							Options@CloudExport
							]
						];#)&@
						Replace[script,
							Hold[s_]:>
								CloudPut[Unevaluated[s],
									installerLoc
									]
							],
					True,
						If[Not@FileExistsQ@installerLoc,
							CreateFile[installerLoc,
								CreateIntermediateDirectories->True
								]
							];
							Replace[script,
								Hold[s_]:>
									Put[Unevaluated[s],
										installerLoc
										]
								];
						installerLoc
				]
		]


(* ::Subsection:: *)
(*Upload*)



Options[PacletUpload]=
	DeleteDuplicatesBy[First]@
		Join[
			Options[PacletSiteURL],
			{
				"SiteFile"->Automatic,
				"UploadInstaller"->True,
				"UploadUninstaller"->True,
				Permissions->"Public"
				}
			];
PacletUpload[pacletFiles]~~`Package`addUsage~~
	"uploads pacletFiles to the specified server and configures installers";
PacletUpload[pacletFiles__String?FileExistsQ,ops:OptionsPattern[]]:=
	Catch@
		With[{site=
			PacletSiteURL[
				FilterRules[{ops},Options@PacletSiteURL]
				]
			},
			If[MatchQ[site,Except[_String]],Throw@$Failed];
			With[{pacletMZ=
				Replace[OptionValue["SiteFile"],
					Automatic:>
						PacletSiteBundle[pacletFiles,
							FilterRules[{ops,
								"MergePacletInfo"->
									site
								},
								Options@PacletSiteBundle
								]
							]
					]},
				Switch[OptionValue["ServerBase"],
					CloudObject|CloudDirectory|Automatic,
						With[{url=site},
							<|
								"PacletSiteFile"->
									With[{co=
										CopyFile[pacletMZ,
											CloudObject@URLBuild@{url,"PacletSite.mz"}]
										},
										SetPermissions[co,
											OptionValue@Permissions
											];
										co
										],
								"PacletFiles"->
									Map[
										With[{co=
											CloudObject[
												URLBuild@{url,"Paclets",FileNameTake@#},
												Permissions->OptionValue@Permissions
												]
												},
											CopyFile[#,co];
											Take[co,1]
											]&,
										{pacletFiles}
										],
								"PacletInstaller"->
									If[OptionValue["UploadInstaller"],
										PacletUploadInstaller[ops,
											Permissions->
												OptionValue@Permissions],
										Nothing],
								"PacletUninstaller"->
									If[OptionValue["UploadUninstaller"],
										PacletUploadUninstaller[ops,
											Permissions->
												OptionValue@Permissions],
										Nothing
										]
								|>	
							],
					_String?(StringMatchQ[FileNameJoin@{$RootDirectory,"*"}]),
						With[{dir=URLDecode@StringTrim[site,"file://"]},
							If[Not@DirectoryQ@dir,
								CreateDirectory[dir,
									CreateIntermediateDirectories->True
									]
								];
							<|
								"PacletSite"->
									CopyFile[pacletMZ,
										FileNameJoin@{dir,"PacletSite.mz"},
										OverwriteTarget->True],
								"PacletFiles"->
									Map[
										(
											Quiet@
												CreateFile[
													FileNameJoin@{dir,"Paclets",FileNameTake@#}
													];
											CopyFile[#,
												FileNameJoin@{dir,"Paclets",FileNameTake@#},
												OverwriteTarget->True]
											)&,
										{pacletFiles}
										],
								"PacletInstaller"->
									If[OptionValue["UploadInstaller"],
										PacletUploadInstaller@
											FilterRules[{ops},
												Options@PacletUploadInstaller
												],
										Nothing
										],
								"PacletUninstaller"->
									If[OptionValue["UploadUninstaller"],
										PacletUploadUninstaller@
											FilterRules[{ops},
												Options@PacletUploadUninstaller
												],
										Nothing
										]
								|>	
							],
					_?SyncPathQ,
						With[{p=SyncPath@OptionValue["ServerBase"]},
							Quiet@CreateDirectory[p,
								CreateIntermediateDirectories->True];
							PacletUpload[
								pacletFiles,
								"ServerBase"->p,
								ops
								]
							],
					_,
						$Failed
						]
				]
			];


Options[PacletSiteInstall]=
	Options@PacletSiteURL;
PacletSiteInstall[site_String]:=
	Which[
		DirectoryQ@site,
			If[FileExistsQ@FileNameJoin@{site,"Installer.m"},
				Get@FileNameJoin@{site,"Installer.m"},
				PacletInstallerScript[site]//ReleaseHold
				],
		StringMatchQ[site,"file:*"],
			With[{f=FileNameJoin@URLParse[site,"Path"]},
				If[DirectoryQ@f,
					If[FileExistsQ@FileNameJoin@{f,"Installer.m"},
						Get@FileNameJoin@{f,"Installer.m"},
						PacletInstallerScript[f]//ReleaseHold
						],
					$Failed
					]
				],
		StringMatchQ[site,"http:*"|"https:*"],
			With[{f=URLBuild@{site,"Installer.m"}},
				If[Between[URLRead[f,"StatusCode"],{200,299}],
					CloudGet@f,
					If[Quiet@Get[f]===$Failed,
						PacletInstallerScript[site]//ReleaseHold
						]
					]
				],
		True,
			$Failed
		];
PacletSiteInstall[ops:OptionsPattern[]]:=
	PacletSiteInstall[PacletSiteURL[ops]];


Options[PacletSiteUninstall]=
	Options@PacletSiteURL;
PacletSiteUninstall[site_String]:=
	Which[
		DirectoryQ@site,
			If[FileExistsQ@FileNameJoin@{site,"Uninstaller.m"},
				Get@FileNameJoin@{site,"Uninstaller.m"},
				PacletUninstallerScript[site]//ReleaseHold
				],
		StringMatchQ[site,"file:*"],
			With[{f=FileNameJoin@URLParse[site,"Path"]},
				If[DirectoryQ@f,
					If[FileExistsQ@FileNameJoin@{f,"Uninstaller.m"},
						Get@FileNameJoin@{f,"Uninstaller.m"},
						PacletUninstallerScript[f]//ReleaseHold
						],
					$Failed
					]
				],
		StringMatchQ[site,"http:*"|"https:*"],
			With[{f=URLBuild@{site,"Uninstaller.m"}},
				If[Quiet@Get[f]===$Failed,
					PacletUninstallerScript[site]//ReleaseHold
					]
				],
		True,
			$Failed
		];
PacletSiteUninstall[ops:OptionsPattern[]]:=
	PacletSiteUninstall@PacletSiteURL[ops];


End[];



