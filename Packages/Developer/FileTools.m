(* ::Package:: *)

(* Autogenerated Package *)

PartialDirectoryCopy::usage="";
CopyDirectoryFiles::usage="";
PruneDirectoryFiles::usage="";
GetMinimalFileModSpec::usage="";


Begin["`Private`"];


(* ::Subsubsection::Closed:: *)
(*PartialDirectoryCopy*)



Options[PartialDirectoryCopy]=
  {
    "RemovePaths"->{},
    "RemovePatterns"->{},
    "ModeSwitchByteCount"->0(*5*10^6*)
    };
PartialDirectoryCopy[source_, dest_, ops:OptionsPattern[]]:=
  Module[
    {
      rempaths=
        Select[
          Flatten@{OptionValue["RemovePaths"]},
          StringPattern`StringPatternQ
          ],
      rempatts=
        Select[
          Flatten@{OptionValue["RemovePatterns"]},
          StringPattern`StringPatternQ
          ],
      fullFNames,
      fileBytesTotal,
      remFiles,
      restFiles,
      targ = ExpandFileName@dest,
      src = ExpandFileName@source
      },
    If[Length@Join[rempaths, rempatts]>0,
      fullFNames=FileNames["*", src, \[Infinity]];
      remFiles=
        Join[
          FileNames[rempaths, src],
          FileNames[rempatts, src, \[Infinity]]
          ];
      restFiles=
        Select[
          Complement[fullFNames, remFiles],
          Not@*StringStartsQ[Alternatives@@remFiles]
          ];
      fileBytesTotal=
        Total[FileByteCount/@Select[remFiles, Not@*DirectoryQ]];
      If[!StringContainsQ[src, targ], (* check it's not a parent... *)
        Quiet@DeleteDirectory[targ, DeleteContents->True],
        targ = CreateDirectory[];
        DeleteDirectory[targ];
        ];
      If[TrueQ[fileBytesTotal>OptionValue["ModeSwitchByteCount"]],
        CopyDirectoryFiles[src, targ, 
          GetMinimalFileModSpec[restFiles, fullFNames]
          ],
        CopyDirectory[src, targ];
        PruneDirectoryFiles[
          targ, 
          GetMinimalFileModSpec[remFiles, fullFNames, False],
          src
          ];
        ];
      If[StringContainsQ[src, ExpandFileName[dest]],
        src = targ;
        targ = ExpandFileName@dest;
        Quiet@DeleteDirectory[targ, DeleteContents->True];
        RenameDirectory[src, targ]
        ],
      If[!StringContainsQ[src, targ], (* check it's not a parent... *)
        targ = CreateDirectory[];
        DeleteDirectory[targ];
        RenameDirectory[src, targ];
        src = targ;
        targ = ExpandFileName@dest;
        Quiet@DeleteDirectory[targ, DeleteContents->True];
        RenameDirectory[src, targ],
        If[True(*OptionValue@OverwriteTarget//TrueQ*),
          Quiet@DeleteDirectory[targ, DeleteContents->True];
          ];
        CopyDirectory[src, targ]
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*GetMinimalFileModSpec*)



(* ::Text:: *)
(*
The idea is as follows. Get a list of files:
	RF = { f1, f2, f3, ....}
Get the file list from which it originated:
	OF = { f1, f1.2, f2, f2.1, f3, ...}
Group all of RF and all of OF by directory:
	ARF = GroupBy[RF, DirectoryName]
	AOF = GroupBy[OF, DirectoryName]
For each directory, if there are files in OF that aren\[CloseCurlyQuote]t in RF, leave the RF one be. If there are no changes, replace the list with its directory name. We will only copy this directory instead.

Next we determine which directories are missing in RF that were in OF. We can\[CloseCurlyQuote]t copy these over.

With this in hand, we merge the directories in RF upwards. If the parent directory is going to be copied in full, we want to drop the child. If the parent is noted as being coped in full, but there\[CloseCurlyQuote]s actually a missing subdirectory to copy, we drop the parent.
*)



GetMinimalFileModSpec//Clear
GetMinimalFileModSpec[
  restFiles_, 
  files_,
  pruneEmpties:True|False:True
  ]:=
  Module[
    {
      emptyDirs,
      realFiles,
      g1,
      g2,
      unchangedReduction,
      changedReduction,
      containedReduction,
      parentNodeMap,
      actuallyDidChangeReduction,
      keys,
      changedKeys,
      missingDirs,
      baseSpec,
      deadDirs
      },
    (* 
			build associations mapping directories to contained files
			all the directories are keys in the Associations optimally 
			*)
    g1=Select[Not@*DirectoryQ]/@GroupBy[restFiles, DirectoryName];
    deadDirs=Complement[Select[restFiles, DirectoryQ], Keys@g1];
    g2=Select[Not@*DirectoryQ]/@GroupBy[files, DirectoryName];
    (*
			prune directories that are empty in the full set and have no children
			*)
  (*	emptyDirs=
			With[{k=Keys@g2},
				Select[Keys@g2, 
					With[{k2=#},
						Length[g2[#]]\[Equal]0&&
							!AnyTrue[k, #=!=k2&]
						]&
					]
				];
		KeyDropFrom[g1, emptyDirs];
		KeyDropFrom[g2, emptyDirs];*)
    (* find the directories that are in the full set but missing in the reduced set to prevent over reduction *)
    missingDirs=
      AssociationThread[
        Complement[Keys@g2, Keys@g1],
        0
        ];
    (* figures out which directories may be copied across wholesale *)
    unchangedReduction=
      AssociationMap[
        #[[1]]->
          If[
            (
              !ListQ@g2[#[[1]]]||(* not in the DirectoyName map...? *)
                Length@Complement[Flatten@{g2[#[[1]]]}, #[[2]]]==0
                (* nothing in the original that's gone missing *)
              )&&
              !AnyTrue[Keys@missingDirs, StringStartsQ[#[[1]]]],
            #[[1]],
            #[[2]]
            ]&,
        g1
        ];
    (* figure out which directories actually do have changes, but down in a subdirectory *)
    parentNodeMap=
      GroupBy[Keys[unchangedReduction], DirectoryName];
    Do[
        If[StringQ@unchangedReduction[node],
          If[
            AnyTrue[Lookup[unchangedReduction, parentNodeMap[node]], Not@*StringQ],
            unchangedReduction[node] = g1[node];
            ]
          ],
        {node, Reverse@SortBy[FileNameDepth]@Keys@unchangedReduction}
        ];
    (* we then find which directories we can't copy because we're already copying the parent *)
    containedReduction=
      FixedPoint[
        KeySelect[
          (*
		  	      checks if both the child *and* the parent are unchanged *and* 
  		  	      if all of the parent's child nodes are unchanged
    			    *)
          !(
              StringQ@unchangedReduction[#]&&
                unchangedReduction[DirectoryName[#]]
            )&
           ],
      unchangedReduction
      ];
    (* figure out which parent directories have changed *)
    keys=Select[containedReduction, StringQ];
    changedKeys=
      Select[keys, 
        With[{k=#}, AnyTrue[keys, StringMatchQ[k~~__]]]&
        ];
    baseSpec=
      Flatten@Values@
          KeyDrop[containedReduction, changedKeys];
    If[pruneEmpties,
      (* makes sure we're not pulling directories with no stuff to copy *)
      Select[
        !DirectoryQ[#]||
          Length@g1[#]>0||
          AnyTrue[
            Flatten@Values@
                KeySelect[g1, StringStartsQ[#]], 
            Not@*DirectoryQ
            ]&
        ],
      Union[#, deadDirs]&
      ]@baseSpec
    ]


(* ::Subsubsection::Closed:: *)
(*CopyDirectoryFiles*)



CopyDirectoryFiles[src_, targ_, files_]:=
  (
    MapThread[
      Which[
        DirectoryQ@#, 
          If[!DirectoryQ@DirectoryName[#2], 
            CreateDirectory[DirectoryName[#2], CreateIntermediateDirectories->True]
            ];
          CopyDirectory[#, #2],
        FileExistsQ@#,
          If[!DirectoryQ@DirectoryName[#2], 
            CreateDirectory[DirectoryName[#2], CreateIntermediateDirectories->True]
            ];
          CopyFile[#, #2, OverwriteTarget->True]
        ]&,
      {
        files,
        Map[FileNameJoin@{targ, #}&, StringTrim[files, src]]
        }
      ];
      )


(* ::Subsubsection::Closed:: *)
(*PruneDirectoryFiles*)



PruneDirectoryFiles[targ_, files_, src_:""]:=
  (
    Which[
      DirectoryQ@#, 
        DeleteDirectory[#, DeleteContents->True],
      FileExistsQ@#,
        DeleteFile[#]
      ]&/@
      Map[
        FileNameJoin@{targ, #}&, 
        StringTrim[files, src]
        ];
    )


End[];



