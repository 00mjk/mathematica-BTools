(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



CustomServiceConnection::usage="Builds a custom ServiceConnection paclet"


Begin["`Private`"];


CustomServiceConnection::ifkey="Import function `` missing keys ``";


Options[customServiceConnectionImportFunction]:=
	{
		"URL"->None,
		"Method"->None,
		"Headers"->None,
		"Path"->None,
		"Parameters"->None,
		"Required"->None,
		"Function"->None
		};
customServiceConnectionImportFunction[name_,ops:OptionsPattern[]]:=
	With[
		{
			basic=
				DeleteCases[None]@
					Association@{ops},
			required=
				{"URL","Path"}
			},
		With[{
			function=
				KeyMap[
					Replace[{
						"Method"->"HTTPSMethod",
						"Path"->"PathParameters",
						"Required"->"RequiredParameters",
						"Function"->"ResultsFunction"
						}],
					basic
					]
			},
			Replace[
				Select[MissingQ]@
					Lookup[function,AssociationThread[required,required]],{
					a_?(Length@#>0&):>
						(
							Message[CustomServiceConnection::ifkey,name,Keys@a];
							$Failed
							),
					_:>
						(name->Normal@function)
				}]
			]
		]


CustomServiceConnection::pfkey="Process function `` missing keys ``";


Options[customServiceConnectionProcessFunction]={
	"Call"->None,
	"Import"->None,
	"Process"->None
	};
customServiceConnectionProcessFunction[name_,ops:OptionsPattern[]]:=
	With[
		{
			function=
				DeleteCases[None]@
					Association@{ops},
			required=
				{"Import"}
			},
		Replace[
			Select[MissingQ]@
				Lookup[function,AssociationThread[required,required]],{
				a_?(Length@#>0&):>
					(
						Message[CustomServiceConnection::pfkey,name,Keys@a];
						$Failed
						),
				_:>
					(name->function)
			}]
		];
	customServiceConnectionProcessFunction[name_,func_]:=
		customServiceConnectionProcessFunction[name,
			"Call"->"Raw"<>name,
			"Import"->func
			]


$customServiceExportContext=$Context;


customServiceTemplateExport[
	name_,
	dir_,
	template_,
	params_
	]:=
	With[{
		tf=`Package`appPath[
			"Packages",
			"__Templates__",
			"$ServiceConnection",
			"Kernel",
			template<>".m"
			],
		out=
			FileNameJoin@{
				dir,
				"ServiceConnection_"<>name,
				"Kernel",
				StringReplace[
					template,
					"$ServiceConnection"->
						name
					]<>".m"
				}
		},
		Block[{$Context=$customServiceExportContext},
			Export[out,
				StringReplace[
					Import[tf,"Text"],
					With[{obj=#2,key=#},
						#->
							Switch[obj,
								Verbatim[Verbatim][_String],
									First@obj,
								_Function,
									"("<>ToString[#2,InputForm]<>")",
								_,
									If[ListQ@obj&&Length@obj>0,
										"\n"<>
											FrontEndExecute[
												ExportPacket[
													Cell[BoxData@First@NewlineateCode@obj,"Input"],
													"InputText"
													]
												][[1]],
										ToString[obj,InputForm]
										]
								]
						]&@@@params
					],
				"Text"
				]
			]
		];


$customServiceConnectionBaseFetchFunction=
	(
			With[ {params = Lookup[{##2},"Parameters",{}]},
				URLFetch[#1,
					Sequence@@FilterRules[{##2},Except["Parameters"]],
						"Parameters" -> 
							FilterRules[params, 
									Except[{"accountid", "authtoken"}]
									],
						"Username"->"accountid"/.params,
						"Password"->"authtoken"/.params
						]
				]&
			)


Options[customServiceConnectionPrep]={
	"Fetch"->
		Automatic,
	"ClientInfo"->
		Automatic,
	"ClientID"->None,
	"RedirectURI"->None,
	"AuthState"->None,
	"LoginURL"->
		None,
	"LogoutURL"->
		None,
	"UseOAuth"->
		Automatic,
	"AuthorizeEndpoint"->
		None,
	"AccessEndpoint"->
		None,
	"TermsOfServiceURL"->
		None,
	"Information"->
		None,
	"Icon"->
		None,
	"Functions"->
		None
	};
customServiceConnectionPrep[
	name_,
	dir_,
	functionData:_List?OptionQ,
	cookingData:_List?OptionQ,
	ops:OptionsPattern[]
	]:=
	With[{
		imps=
			Association[customServiceConnectionImportFunction@@@functionData],
		preps=
			Association[customServiceConnectionProcessFunction@@@cookingData]
		},
		With[{
			params=
			Flatten@{
				"$ServiceConnectionURLFetch"->
					OptionValue@"Fetch",
				"$ServiceConnectionClientInfo"->
					OptionValue@"ClientInfo",
				"$ServiceConnectionUseOAuth"->
					Replace[OptionValue@"UseOAuth",
						Except[True|False]:>
							OptionValue["AuthorizeEndpoint"]=!=None&&
								OptionValue["AccessEndpoint"]=!=None
						],
				"$ServiceConnectionAuthEndpoint"->
					OptionValue@"AuthorizeEndpoint",
				"$ServiceConnectionAccessEndpoint"->
					OptionValue@"AccessEndpoint",
				"$ServiceConnectionTermsOfServiceURL"->
					OptionValue@"TermsOfServiceURL",
				"$ServiceConnectionClientID"->
					OptionValue@"ClientID",
				"$ServiceConnectionState"->
					OptionValue@"AuthState",
				"$ServiceConnectionRedirectURI"->
					OptionValue@"RedirectURI",
				"$ServiceConnectionCalls"->
					imps,
				"$ServiceConnectionCookingFunctions"->
					preps,
					With[{r=#,b=ToUpperCase@StringTrim[#,"s"]},
						With[{
							impSpec=
								Cases[Normal@imps,
									(k_->{
										___,
										"HTTPSMethod"->_?(
											(ToUpperCase@#/.("PATCH"|"DELETE"->"POST"))===b&),
										___
										}):>k
									]
							},
						Sequence@@
							{
								"$ServiceConnectionRaw"<>r->
									impSpec,
								"$ServiceConnection"<>r->
									Join[
										Keys@
											Select[preps,
												MemberQ[impSpec,#["Call"]]&
												],
										If[r==="Gets",
											Keys@
												Select[preps,MissingQ@#["Call"]&],
											{}
											]
										]
								}
						]
					]&/@{"Gets","Posts"},
				"$ServiceConnectionInformation"->
					OptionValue@"Information",
				"$ServiceConnectionIcon"->
					OptionValue@"Icon",
				"$ServiceConnectionHelperNames"->
					Verbatim@
						StringRiffle[
							Replace[
								Flatten@DeleteCases[None]@{OptionValue@"Functions"},{
								(k_->f_):>
									ToString[k],
								e_:>
									ToString@e
								},
								1],
							"\n\n"
							],
				"$ServiceConnectionHelperFunctions"->
					Verbatim@
						StringRiffle[
							Replace[
								Flatten@DeleteCases[None]@{OptionValue@"Functions"},{
								(k_->f_):>
									(ToString[k]<>" = "<>ToString[f,InputForm]),
								e_:>
									ToString@FullDefinition@e
								},
								1],
							"\n\n"
							],
				"$ServiceConnection"->
					Verbatim@name,
				"$serviceconnection"->
					Verbatim@ToLowerCase@name
				}
			},
			customServiceTemplateExport[
				name,
				dir,
				#,
				params
				]&/@{
					"load",
					"$ServiceConnection",
					"$ServiceConnectionFunctions",
					"$ServiceConnectionLoad"
					}
			]
		]


Options[CustomServiceConnection]=
	Join[
		{
			"ImportFunctions"->{},
			"ProcessFunctions"->{},
			"Icon"->None
			},
		Options@customServiceConnectionPrep
		];


CustomServiceConnection[
	name_String?(StringMatchQ[WordCharacter..]),
	directory:_String?DirectoryQ|Automatic:Automatic,
	pack:True|False:True,
	ops:OptionsPattern[]
	]:=
	With[{dir=Replace[directory,Automatic:>$TemporaryDirectory]},
		Quiet@CreateDirectory@
			FileNameJoin@{
				dir,
				"ServiceConnection_"<>name,
				"Kernel"
				};
		With[{res=
			customServiceConnectionPrep[
				name,
				dir,
				OptionValue@"ImportFunctions",
				OptionValue@"ProcessFunctions",
				FilterRules[{
					"Icon"->
						Replace[OptionValue@"Icon",{
							Graphics[e_,o___]:>
								Graphics[e,ImageSize->24,o],
							Except[None|_Graphics]->Automatic
							}],
						ops},Options@customServiceConnectionPrep]
				]
			},
			If[AllTrue[res,StringQ@#&&FileExistsQ@#&],
				With[{
					bmdir=
						FileNameJoin@{
								dir,
								"ServiceConnection_"<>name,
								"FrontEnd",
								"SystemResources",
								"Bitmaps"
							},
					things=
						Replace[OptionValue@"Icon",{
							g_Graphics:>
								{
									Insert[g,
										ImageSize->24,
										2
										],
									Insert[g,
										ImageSize->48,
										2
										]
									},
							i_?ImageQ:>
								{
									ImageResize[i,{24}],
									ImageResize[i,{48}]
									},
							e:Except[None|{_,_}]:>
								{
									Rasterize[e,"Image",
										RasterSize->{24,24}],
									Rasterize[e,"Image",
										RasterSize->{48,48}]
									}
							}]
					},
						If[ListQ@things&&Length@things==2,
							Quiet@CreateDirectory@bmdir;
							If[MatchQ[First@things,(_File|_String)?FileExistsQ],
								CopyFile[
									First@things,
									FileNameJoin@{
										bmdir,
										ToLowerCase@name<>".png"
										}
									],
								Export[
									FileNameJoin@{
										bmdir,
										ToLowerCase@name<>".png"
										},
									First@things
									];
							If[MatchQ[Last@things,(_File|_String)?FileExistsQ],
								CopyFile[
									Last@things,
									FileNameJoin@{
										bmdir,
										ToLowerCase@name<>"@2.png"
										}
									],
								Export[
									FileNameJoin@{
										bmdir,
										ToLowerCase@name<>"@2.png"
										},
									Last@things
									]
								]
							]
						]
					];
				If[pack,
					PacletExpressionBundle[
						FileNameJoin@{dir,"ServiceConnection_"<>name}
						];
					PacletBundle@FileNameJoin@{dir,"ServiceConnection_"<>name},
					FileNameJoin@{dir,"ServiceConnection_"<>name}
					]
				]/;AllTrue[res,StringQ@#&&FileExistsQ@#&]
			]
		]


End[];



