(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ExpressionGraph::usage=
	"builds a Graph from an expression";
ExpressionGraphNode::usage=
	"Represents a node in an ExpressionGraph";
ExpressionScan::usage=
	"Applies a BFS or DFS scan to the expression tree";


NotebookGraph::usage=
	"Generates an ExpressionGraph from a Notebook expression";
NotebookGraphScan::usage=
	"Uses a variant on ExpressionScan on NotebookGraph";


Begin["`Private`"];


exprSafeNotAtomQ[expr_]:=
	Not@AtomQ@Unevaluated[expr];
exprSafeNotAtomQ~SetAttributes~HoldFirst;


expressionGraph[expr_?exprSafeNotAtomQ]:=
	Thread[
		ExpressionGraphNode[expr,nodeCount++]->
			Prepend[
				expressionGraph@@@
					Thread[ReplacePart[Hold[expr],{1,0}->List]],
				ExpressionGraphNode[Evaluate@Head@Unevaluated[expr],nodeCount++,Head]
				]
		];
expressionGraph[expr_]:=
	ExpressionGraphNode[expr,nodeCount++,AtomQ];
expressionGraphFlatten[gr_]:=
	Replace[gr,{
		(e_->r:{__Rule}):>
			Sequence@@
				Prepend[Map[First@#->expressionGraphFlatten@Last@#&,r],
					e->First@First@r
					]
		},
		1];
ExpressionGraph[expr_,styled:True|False|None:False]:=
	With[{
		edgeList=
			expressionGraphFlatten@
				Block[{nodeCount=1},
					expressionGraph[expr]
					]
		},
		Switch[styled,
			True,
				With[{nodes=VertexList@edgeList},
					Graph[edgeList,
						VertexStyle->
							Replace[nodes,{
								n:ExpressionGraphNode[_,_,Head]:>
									(n->Yellow),
								n:ExpressionGraphNode[_,_,AtomQ]:>
									(n->Red),
								n_:>
									(n->Automatic)
								},
								1]
						]
					],
			False,
				Graph[edgeList],
			None,
				edgeList
			]
		];
{expressionGraph,ExpressionGraph,ExpressionGraphNode}~SetAttributes~HoldFirst


expressionNodePattern[pat_]:=
	If[MatchQ[Unevaluated[pat],_ExpressionGraphNode],
		pat,
		ExpressionGraphNode[pat,___]
		];
expressionNodePattern~SetAttributes~HoldFirst


expressionGraphEvents[basevs_,DepthFirstScan]:=
	Merge[
		Replace[Flatten@{basevs},{
			(Rule|RuleDelayed)[{
				k:("BackEdge"|"FrontierEdge"|
					"ForwardEdge"|"CrossEdge"),
				(Rule|DirectedEdge)[pat1_,pat2_]
				},f_]:>
				k->(
					Replace[#,(
						expressionNodePattern[pat1]\[DirectedEdge]
							expressionNodePattern[pat2]
						):>f[#]]&
					),
			(Rule|RuleDelayed)[{k_,pat_},f_]:>
				k->(Replace[#,expressionNodePattern[pat]:>f[#]]&),
			(Rule|RuleDelayed)[(Rule|DirectedEdge)[pat1_,pat2_],f_]:>
				Thread[
					{"BackEdge","FrontierEdge",
						"ForwardEdge","CrossEdge"}->
					(Replace[#,
						(expressionNodePattern[pat1]\[DirectedEdge]
							expressionNodePattern[pat2]):>
							f[#]
						]&)
					],
			(Rule|RuleDelayed)[
				pat1:
					Except[
						Alternatives@@
							{
								"BackEdge","FrontierEdge",
								"ForwardEdge","CrossEdge",
								"DiscoverVertex",
								"UnvisitedVertex","VisitedVertex",
								"PrevisitVertex","PostvisitVertex"
								}
						],
				f_]:>
					Thread[
						{
							"DiscoverVertex",
							"UnvisitedVertex","VisitedVertex",
							"PrevisitVertex","PostvisitVertex"
							}->
						(Replace[#,
							(expressionNodePattern[pat1]):>
								f[#]]&)
						]
			},
			1],
		Replace[f:{__}:>
			(Through[f[#]]&)
			]
		];


expressionGraphEvents[basevs_,BreadthFirstScan]:=
	Merge[
		Replace[Flatten@{basevs},{
			(Rule|RuleDelayed)[{k:("FrontierEdge"|"CycleEdge"),
				(Rule|DirectedEdge)[pat1_,pat2_]
					},f_]:>
					k->(
						Replace[(
							expressionNodePattern[pat1]
								\[DirectedEdge]expressionNodePattern[pat2]
							):>f]
						),
			(Rule|RuleDelayed)[{k_,pat_},f_]:>
				k->(Replace[expressionNodePattern[pat]:>f]),
			(Rule|RuleDelayed)[(Rule|DirectedEdge)[pat1_,pat2_],f_]:>
				Thread[{"FrontierEdge","CycleEdge"}->
					Replace[
						(expressionNodePattern[pat1]\[DirectedEdge]
							expressionNodePattern[pat2]):>
							f
						]
					],
			(Rule|RuleDelayed)[
				pat1:
					Except[
						Alternatives@@
							{
								"FrontierEdge","CycleEdge","DiscoverVertex",
								"UnvisitedVertex","VisitedVertex",
								"PrevisitVertex","PostvisitVertex"
								}
						],
				f_]:>
				Thread[
					{"DiscoverVertex",
						"UnvisitedVertex","VisitedVertex",
						"PrevisitVertex","PostvisitVertex"}->
						Replace[
							(expressionNodePattern[pat1]):>
							f]
					]
			},
			1],
		Replace[f:{__}:>
			(Through[f[#]]&)
			]
		];


ExpressionScan[
	expr:_Graph|_?exprSafeNotAtomQ,
	scan:BreadthFirstScan|DepthFirstScan|Automatic:Automatic,
	events:_Rule|_RuleDelayed|{(_Rule|_RuleDelayed)...}:{}
	]:=
	With[{
		scanType=
			Replace[scan,
				Automatic:>
					If[FreeQ[First/@Flatten@{events},"FrontierEdge"|"CycleEdge"],
						DepthFirstScan,
						BreadthFirstScan
						]
				],
		gr=
			Replace[Unevaluated[expr],Except[_Graph]:>ExpressionGraph@expr]
		},
		scanType[gr,expressionGraphEvents[Flatten@{events},scanType]]
		];
ExpressionScan~SetAttributes~HoldFirst


notebookGraph[Notebook[expr_,___]]:=
	Thread[
		ExpressionGraphNode[Notebook,nodeCount++]->
			Map[notebookGraph,expr]
		];
notebookGraph[
	Cell[
		CellGroupData[{
			h:Cell[Except[_CellGroupData],__],
			c__},
			___],
		___]
	]:=
	Thread[
		ExpressionGraphNode[h,nodeCount++]->
			Map[notebookGraph,{c}]
		];
notebookGraph[
	Cell[
		CellGroupData[{
			h:Cell[_CellGroupData,___],
			c__}]
		]
	]:=
	With[{g=notebookGraph@h},
		Join[
			Thread[First@First@g->Map[notebookGraph,{c}]],
			g
			]
		];
notebookGraph[c_Cell]:=
	ExpressionGraphNode[c,nodeCount++]


NotebookGraph[
	nb:_Notebook|Cell[_CellGroupData,___],
	style:True|False|None:False]:=
	With[{edgeList=
		expressionGraphFlatten@
			Block[{nodeCount=1},
				notebookGraph[nb]
				]
		},
		Switch[style,
			True,
				With[{vl=VertexList@edgeList},
					Graph[edgeList,
						VertexStyle->
							MapThread[Rule,{
								vl,
								Replace[First/@vl,{
									Notebook->Red,
									Cell[_,s_String,___]:>
										ReplaceAll[s,
											Map[
												_String?(StringMatchQ[___~~First@#~~___])->
													Last@#&,
												{
													"Title"->RGBColor[0.8, 0.043, 0.008],
													"Chapter"->RGBColor[0.20584420538643472`, 0.20584420538643472`, 0.20584420538643472`],
													"Subchapter"->RGBColor[0.3, 0.3, 0.3],
													"Section"->RGBColor[0.7612268253604944, 0.29576562142366675`, 0.08555733577477684],
													"Subsection"->RGBColor[0.778286411841001, 0.4230563820859083, 0.16115053025101092`],
													"Subsubsection"->RGBColor[0.7143816281376364, 0.21776150148775464`, 0.03341725795376516],
													"Subsubsubsection"->RGBColor[0.778286411841001, 0.4230563820859083, 0.16115053025101092`],
													"Input"|"Output"->GrayLevel[0.2],
													"Item"->GrayLevel[0.2],
													_->Automatic
													}
												]
											],
									_->Automatic
									},
									1
									]
								}],
							GraphLayout->
								"LayeredDigraphEmbedding"
						]
					],
			False,
				Graph[edgeList],
			None,
				edgeList
			]
		];
NotebookGraph[nbobj_NotebookObject,
	style:True|False|None:False]:=
	NotebookGraph[NotebookGet@nbobj,style]


nbScanCellPat[pat_]:=
	Replace[pat,
		Except[_Cell|Notebook|_Pattern|_PatternTest]:>
			Cell[_,pat,___]
		];


NotebookGraphScan[
	expr:_Graph|_Notebook|_NotebookObject|Cell[_CellGroupData,___],
	scan:BreadthFirstScan|DepthFirstScan|Automatic:Automatic,
	events:_Rule|_RuleDelayed|{(_Rule|_RuleDelayed)...}:{}
	]:=
	ExpressionScan[
		Evaluate@Replace[expr,Except[_Graph]:>NotebookGraph@expr],
		scan,
		Replace[Flatten@{events},{
			(r:Rule|RuleDelayed)[{k_,(Rule|DirectedEdge)[pat1_,pat2_]},f_]:>
				r[{k,nbScanCellPat[pat1]\[DirectedEdge]nbScanCellPat[pat2]},f],
			(r:Rule|RuleDelayed)[{k_,pat_},f_]:>
				r[{k,nbScanCellPat[pat]},f],
			(r:Rule|RuleDelayed)[(Rule|DirectedEdge)[pat1_,pat2_],f_]:>
				r[(nbScanCellPat[pat1]\[DirectedEdge]nbScanCellPat[pat2]),f],
			(r:Rule|RuleDelayed)[pat_,f_]:> 
				r[nbScanCellPat[pat],f]
			},
			1]
		];


End[];



